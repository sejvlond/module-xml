# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file WSDL.qm WSDL: Web Services Description Language: http://www.w3.org/TR/wsdl

/*  WSDL.qm Copyright (C) 2012 - 2015 David Nichols

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# make sure we have the required qore version
%requires qore >= 0.8.12

# requires XML functionality
%requires xml

# need mime definitions
%requires Mime >= 1.1

# do not use $ for vars
%new-style

%disable-warning unreferenced-variable

module WSDL {
    version = "0.3.5";
    desc = "WSDL module providing functionality for SOAP";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

/*
    WSDL classes
    provides some minimal WSDL and XSD support for SOAP messaging used by the SoapClient class and the SoapHandler

    not complete, needs namespace verification, improved XSD support, element groups, etc
*/

/** @mainpage WSDL Module

    @tableofcontents

    @section wsdlintro Introduction to the WSDL Module

    The %WSDL module provides functionality for <a href="http://en.wikipedia.org/wiki/SOAP">SOAP</a> 1.1 and 1.2.

    The main purpose of this module is to provide the infrastructure for developing SOAP client and server services.

    The main components of this module are as follows:
    - @ref WSDL::WebService "WebService": represents a WSDL file; an easy way to get an object of this type from a URL is by calling WSDL::WSDLLib::getWSDL()
    - @ref WSDL::WSDLLib "WSDLLib": a class of static functions providing helper functions for the module
    - @ref WSDL::WSOperation "WSOperation": a class representing a single operation from a web service

    See the following for modules using the %WSDL module:
    - <a href="../../SoapClient/html/index.html">SoapClient user module</a>
    - <a href="../../SoapHandler/html/index.html">SoapHandler user module</a>

    @section wsdlrelnotes WSDL Module Release Notes

    @subsection wsdl_0_3_5 WSDL v0.3.5
    - fixed many message serialization and deserialization issues
    - added @ref WSDL::WebService::getOperation()
    - allow for environment variable substitution in WSDLLib::getWSDL() when retrieving files

    @subsection wsdl_0_3_4 WSDL v0.3.4
    - updated to a user module

    @subsection wsdl_0_3_3 WSDL v0.3.3
    - added initial support for the anyAttribute element of complexType
    - added initial support for SOAP header processing
    - added initial support for multiple portType and bindings in a WSDL

    @subsection wsdl_0_3_2 WSDL v0.3.2
    - fixed bugs de/serializing negative values for "int" and "short"

    @subsection wsdl_0_3_1 WSDL v0.3.1
    - improved XSD imports and namespace handling

    @subsection wsdl_0_3_0 WSDL v0.3.0
    - implemented WSDLLib class of helper functions
    - implemented support for xsd import statements in WSDLs

    @subsection wsdl_0_2_0 WSDL v0.2.0
    - use parseXMLAsData() instead of parseXML()
    - implemented initial simpleType support
    - fixed xsd:date serialization and deserialization
*/

#! main WSDL namespace
public namespace WSDL {
    #! this WSDL implementation version
    public const version     = "0.3.5";

    public const XET_ALL      = "ALL";
    public const XET_CHOICE   = "CHOICE";
    public const XET_SEQUENCE = "SEQUENCE";

    #! SOAP 1.1 envelope URI
    public const SOAP_11_ENV  = "http://schemas.xmlsoap.org/soap/envelope/";
    #! SOAP 1.2 envelope URI
    public const SOAP_12_ENV  = "http://www.w3.org/2003/05/soap-envelope";

    #! SOAP 1.1 namespace URI
    public const SOAP_11_NS   = "http://schemas.xmlsoap.org/wsdl/soap/";

    #! SOAP 1.2 namespace URI
    public const SOAP_12_NS   = "http://schemas.xmlsoap.org/wsdl/soap12/";

    #! XSD namespace URI
    public const XSD_NS       = "http://www.w3.org/2001/XMLSchema";
    #! XSI namespace URI
    public const XSI_NS       = "http://www.w3.org/2001/XMLSchema-instance";

    #! HTTP namespace URI
    public const HTTP_NS      = "http://schemas.xmlsoap.org/wsdl/http/";
    #! MIME namespace URI
    public const MIME_NS      = "http://schemas.xmlsoap.org/wsdl/mime/";

    #! soap 1.1 envelope namespaces
    public const ENVELOPE_11_NS = (
        "soapenv:Envelope": (
            "^attributes^": (
                "xmlns:soapenv": SOAP_11_ENV,
                "xmlns:xsd": XSD_NS,
                "xmlns:xsi": XSI_NS,
            ),
        ),
        );

    #! soap 1.2 envelope namespaces
    public const ENVELOPE_12_NS = (
        "soapenv:Envelope": (
            "^attributes^": (
                "xmlns:soapenv": SOAP_12_ENV,
              "xmlns:xsd": XSD_NS,
              "xmlns:xsi": XSI_NS,
            ),
        ),
        );

    #! soap encoding URI
    public const SOAP_ENCODING = "http://schemas.xmlsoap.org/soap/encoding/";

    #! mapping from Qore types to xsd types for xsd type "anyType"
    public const any_type_map = (
        Type::String      : "string",
        Type::Int         : "long",
        Type::Boolean     : "boolean",
        Type::Date        : "dateTime",
        Type::Float       : "decimal",
        Type::NothingType : "string",
        Type::NullType    : "string",
        Type::Binary      : "base64Binary",
        );

    # error codes
    const SOAP_SERIALIZATION_ERROR = "SOAP-SERIALIZATION-ERROR";
    const SOAP_DESERIALIZATION_ERROR = "SOAP-DESERIALIZATION-ERROR";
    const WSDL_ERROR = "WSDL-ERROR";

    #! SOAP HTTP transport URI
    const SOAP_TRANSPORT_HTTP = "http://schemas.xmlsoap.org/soap/http";

    #! known/supported transports
    public const SOAP_TRANSPORT = (
        SOAP_TRANSPORT_HTTP: True,
        );

    #! range of "short" values (16 bits)
    public const RANGE_SHORT = (-32768, 32767);

    #! range of "int" values (32 bits)
    public const RANGE_INT = (-2147483648, 2147483647);
}

#! contains helper methods for retrieving WSDLs from a URL
public class WSDL::WSDLLib {
    #! Mime types recognized as SOAP messages
    const SoapMimeTypes = (MimeTypeSoapXml, MimeTypeXml, MimeTypeXmlApp);

    #! retrieves a local file and returns the file's contents as a string
    /** called by WSDLLib::getFileFromURL() in case the scheme is "file"
    */
    static string getFile(string fn, bool as_string = True) {
        return as_string ? ReadOnlyFile::readTextFile(fn) : ReadOnlyFile::readBinaryFile(fn);
    }

    #! retrieves a file from a URL with HTTP and returns the file's contents as a string
    /** called by WSDLLib::getFileFromURL() in case the scheme is "http"
    */
    static string getHTTP(string url, *string path, *HTTPClient hc, *hash headers, bool as_string = True) {
        if (hc)
            hc.setURL(url);
        else
            hc = new HTTPClient(("url" : url));
        string body = hc.get(path ? path : "/", headers);
        return as_string ? body : binary(body);
    }

    #! retrieves a file from a URL with the FTP protocol and returns the file's contents as binary or string data
    /** called by WSDLLib::getFileFromURL() in case the scheme is "ftp"
    */
    static data getFTP(string url, string path, bool as_string = True) {
        string file = basename(path);
        if (!file)
            throw "WSDL-LIB-ERROR", sprintf("missing file name in URL %y", url);

        FtpClient f(url);
        f.connect();

        string dir = dirname(path);
        if (dir)
            f.cwd(dir);

        return as_string ? f.getAsString(file) : f.getAsBinary(file);
    }

    #! retrieves a file from a URL
    /** in case the URL is actually a file path, environment variable substitution
        is performed on the path string
     */
    static data getFileFromURL(string url, string def_protocol = "file", *HTTPClient http_client, *hash http_headers, bool as_string = True, *string def_path, *reference new_def_path) {
        return WSDLLib::getFileFromURL(url, parse_url(url), def_protocol, http_client, http_headers, as_string, def_path, \new_def_path);
    }

    #! retrieves a file from an already-parsed URL
    /** in case the URL is actually a file path, environment variable substitution
        is performed on the path string
     */
    static data getFileFromURL(string url, hash u, string def_protocol = "file", *HTTPClient http_client, *hash http_headers, bool as_string = False, *string def_path, *reference new_def_path) {
        if (!exists u.protocol)
            u.protocol = def_protocol;

        switch (u.protocol) {
            case "file": {
                string path;
                if (u.host)
                    path = u.host;
                if (u.path) {
                    if (path)
                        path += DirSep;
                    path += u.path;
                }
                # do environment variable substitution
                map path = replace(path, "\$" + $1, ENV.$1), (path =~ x/\$(\w+)/g);

                if (def_path && !absolute_path(path))
                    path = def_path + DirSep + path;
                else
                    new_def_path = dirname(path);
                return WSDLLib::getFile(path, as_string);
            }

            case /^http(s)?$/:
                return WSDLLib::getHTTP(url, u.path, http_client, http_headers, as_string);

            case /^ftp(s)?$/:
                return WSDLLib::getFTP(url, u.path, as_string);

            default:
                throw "WSDL-LIB-ERROR", sprintf("do not know how to retrieve data with scheme %y given in URL %y", u.protocol, url);
        }
    }

    #! returns the argument
    static WebService getWSDL(WebService wsdl) {
        return wsdl;
    }

    #! returns a WSDL string form a file name, optional HTTPClient object and optional header hash
    /** in case the \a wsdl argument is actually a file path, environment variable substitution
        is performed on the path string
     */
    static string getWSDL(string wsdl, *HTTPClient http_client, *hash http_headers, *reference new_def_path) {
        if (wsdl =~ /^<\?xml/)
            return wsdl;
        return WSDLLib::getFileFromURL(wsdl, "file", http_client, http_headers, NOTHING, NOTHING, \new_def_path);
    }

    #! takes a hash representation of a SOAP message and parses it to a Qore data structure; handles multipart messages, checks the content-type, and handles hrefs in the message
    static hash parseSOAPMessage(hash msg) {
        if (exists msg."_qore_multipart") {
            if (msg."_qore_multipart" != "related")
                throw "SOAP-MESSAGE-ERROR", sprintf("don't understand multipart/%s messages, expected multipart/related", msg."_qore_multipart");

            any bdry = msg."_qore_multipart_boundary";
            if (!strlen(bdry))
                throw "SOAP-MESSAGE-ERROR", sprintf("multipart message received without multipart boundary; headers: %y", msg - "body");

            hash mpmsg;
            list l = split("\r\n--" + bdry, msg.body);

            for (int i = 1; i < (elements l - 1); ++i) {
                string m = l[i];

                int ie = index(m, "\r\n\r\n");
                if (ie == -1) {
                    throw "SOAP-MESSAGE-ERROR", sprintf("part %d has no headers: %y", i, m);
                }
                hash hh;
                foreach string hl in (split("\r\n", substr(m, 2, ie))) {
                    trim hl;
                    my (string hi, any ignore, string ha) = hl =~ x/^(.*):([ \t])*(.*)$/;
                    hi = tolower(hi);
                    #printf("hl: %y hi: %y ha: %y\n", hl, hi, ha);exit();
                    hh{hi} = ha;
                }
                if (!exists hh."content-id")
                    throw "SOAP-MESSAGE-ERROR", sprintf("expecting part header Content-ID in part %d; headers: %y", i, hh);

                any b;
                if (hh."content-transfer-encoding" == "binary") {
                    # unfortunately we have to do some tricks to get the binary data out here
                    # FIXME: tricks probably not necessary with qore 0.8.1+
                    m = force_encoding(m, "ascii");
                    # recalculate byte offset
                    ie = index(m, "\r\n\r\n");
                    #printf("ie: %d m: %d\n", ie, strlen(m));exit();
                    b = binary(substr(m, ie + 4));

                    #File f(); f.open2("t.bin", O_CREAT|O_WRONLY|O_TRUNC); f.write(b); exit();
                }
                else {
                    b = substr(m, ie + 4);

                    if (hh."content-type" =~ /charset=/) {
                        string c = (hh."content-type" =~ x/charset=([^;]+)/)[0];
                        b = force_encoding(b, c);
                    }
                }

                if (hh."content-id" !~ /^\<.*\>$/)
                    throw "SOAP-MESSAGE-ERROR", sprintf("expected part ID to have the following format: <id>, instead got %s", hh."content-id");

                hash p = ( "hdr" : hh,
                               "body" : b );

                if ((!exists msg."_qore_multipart_start" && i == 1)
                    || (exists msg."_qore_multipart_start" && msg."_qore_multipart_start" == hh."content-id")) {
                    mpmsg.body = p;
                }
                else {
                    string id = substr(hh."content-id", 1, -1);
                    mpmsg.part{id} = p;
                }
            }
            # check content-type
            WSDLLib::checkSOAPContentType(mpmsg.body.hdr."content-type");

            #printf("part %d hh: %Y\nbody: %s (%d)\n", i, hh, type(b), elements(b)); #exit();
            hash xmldata = parseXMLAsData(mpmsg.body.body);

            # parse entire data structure to find "href"s or href attributes
            WSDLLib::substHref(\xmldata, mpmsg.part);
            return xmldata;
        }

        WSDLLib::checkSOAPContentType(msg."_qore_orig_content_type");

        return parseXMLAsData(msg.body);
    }

    private static checkSOAPContentType(string ct) {
        foreach string sct in (SoapMimeTypes) {
            if (bindex(ct, sct) != -1)
                return;
        }

        throw "SOAP-MESSAGE-ERROR", sprintf("don't know how to handle content-type %y (expecting one of: %y)", ct, SoapMimeTypes);
    }

    private static processHref(reference xmldata, string hr, hash parts) {
        if (hr !~ /^cid:/)
            throw "SOAP-MESSAGE-ERROR", sprintf("messages references non-local part %y; cannot handle non-local parts", hr);
        hr = substr(hr, 4);
        if (!exists parts{hr})
            throw "SOAP-MESSAGE-ERROR", sprintf("message references non-existent part %y", hr);
        xmldata = parts{hr}.body;
    }

    private static substHref(reference xmldata, hash parts) {
        foreach string k in (keys xmldata) {
            if (exists xmldata{k}."^attributes^".href)
                WSDLLib::processHref(\xmldata{k}, xmldata{k}."^attributes^".href, parts);
            else if (exists xmldata{k}.href)
                WSDLLib::processHref(\xmldata{k}, xmldata{k}.href, parts);
            else if (xmldata{k}.typeCode() == NT_LIST) {
                foreach any e in (\xmldata{k})
                    WSDLLib::substHref(\e, parts);
            }
            else if (xmldata{k}.typeCode() == NT_HASH)
                WSDLLib::substHref(\xmldata{k}, parts);
        }
    }
}

#! base class with helper methods for XSD data processing
public class WSDL::XsdBase {
    /*
    static private hash doType(string t) {
        #printf("DEBUG: XsdBase::doType(%y)\n", t);
        my (*string ns, *string type) = t =~ x/(\w+):(\w+)/;
        return !exists type ? ("val": t) : ("ns": ns, "val": type);
    }
    */

    static removeNS(reference v) {
        foreach hash h in (\v) {
            foreach string k in (h.keyIterator()) {
                my (*string ns, *string name) = k =~ x/(\w+):(\w+)/;
                if (ns) {
                    if (h{k}.typeCode() == NT_HASH)
                        h{k}.ns = ns;
                    if (h{name}) {
                        softlist l = h{name};
                        l += remove h{k};
                        h{name} = l;
                    }
                    else
                        h{name} = remove h{k};
                }
            }
        }
    }

    static removeNS2(reference v) {
        foreach hash h in (\v) {
            foreach string k in (h.keyIterator()) {
                my (*string ns, *string name) = k =~ x/(\w+):(\w+)/;
                if (ns) {
                    if (h{k}.typeCode() == NT_HASH)
                        h{k}.".ns" = ns;
                    if (h{name}) {
                        softlist l = h{name};
                        l += remove h{k};
                        h{name} = l;
                    }
                    else
                        h{name} = remove h{k};
                }
            }
        }
    }
}

#! base class for XSD data classes
public class WSDL::XsdData inherits WSDL::XsdBase {
    any getValue(*hash mrh, any val) {
        if (exists val."^attributes^".href) {
            string href = substr(val."^attributes^".href, 1);

            if (!exists mrh.mrh{href})
                throw "INVALID-REFERENCE", sprintf("multiRef id: %y does not exist", href);

            return mrh.mrh{href};
        }
        return val;
    }
}

#! base class for XSD classes with a "name" attribute
public class WSDL::XsdNamedData inherits WSDL::XsdData {
    public {
        # name of object
        string name;
        #! input namespace prefix (if any given)
        *string ns;
    }

    constructor(string n_name, string n_ns) {
        name = n_name;
        ns = n_ns;
    }

    constructor(reference e) {
        WSDL::XsdBase::removeNS(\e);
        *hash a = e."^attributes^";
        if (a.name)
            name = a.name;
        else if (a.ref) {
            # remove namespace
            my (*string ns, *string n_name) = a.ref =~ x/(\w+):(\w+)/;
            name = n_name ?? a.ref;
        }
        else
            name = "<unnamed type>";
    }

    string getName() {
        return name;
    }

    *string getInputNamespacePrefix() {
        return ns;
    }
}

public class WSDL::XsdAbstractType inherits WSDL::XsdNamedData {
    public {
        #! reference to namespaces
        Namespaces nsc;

        #! my namespace output prefix
        string ons;
    }

    constructor(reference e, Namespaces n_nsc) : XsdNamedData(\e) {
        nsc = n_nsc;
        resolveNamespace();
    }

    constructor(string name, string ns, Namespaces n_nsc) : XsdNamedData(name, ns) {
        nsc = n_nsc;
        resolveNamespace();
    }

    private resolveNamespace() {
        if (!ns) {
            *string tns = nsc.getTargetNamespaceUri();
            if (!tns)
                throw "WSDL-NAMESPACE-ERROR", sprintf("input namespace for %s %y was not given and there is no current target namespace", self.className(), name);
            ons = nsc.getOutputNamespacePrefix(tns);
        }
        else
            ons = nsc.translateOutputNamespacePrefix(ns);
        #printf("DEBUG: type %y ns: %y ons: %y\n", name, ns, ons);
    }

    checkExtends(XsdAbstractType t, string ename) {
        throw SOAP_SERIALIZATION_ERROR, sprintf("explicit type %y given for element %y, type %y, however the types are not compatible", name, ename, t.name);
    }

    string getNameWithNS() {
        return ons + ":" + name;
    }

    bool required() {
        return True;
    }

    string getOutputNamespacePrefix() {
        return ons;
    }

    abstract any serialize(any val, *softbool omit_type, *softbool omit_ns);
    abstract any deserialize(string en, *hash types, *hash mrh, any val);
}

#! class for XSD base types
public class WSDL::XsdBaseType inherits WSDL::XsdAbstractType {
    public {
    }

    constructor(string t, Namespaces nsc, string ns = "xsd") : XsdAbstractType(t, ns, nsc) {
    }

    any serialize(any val, *softbool omit_type, *softbool omit_ns) {
        *string type;
        # set type according to Qore type if xsd type is anyType
        if (name == "anyType") {
            # we have to specify the type in this case
            omit_type = False;
            type = any_type_map{val.type()};
            if (!type)
                throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize xsd type anyType from Qore type %y", val.type());
        }
        else {
            type = name;
        }

        switch (type) {
            case "byte": {
                int v = int(val);
                if ((v & 0xff) != v)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "short": {
                int v = int(val);
                if (v < RANGE_SHORT[0] || v > RANGE_SHORT[1])
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "int": {
                int v = int(val);
                if (v < RANGE_INT[0] || v > RANGE_INT[1])
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "unsignedByte": {
                int v = int(val);
                if ((v & 0xff) != v)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                if (v < 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", type, v);
                break;
            }

            case "unsignedShort": {
                int v = int(val);
                if (v < 0 || v > RANGE_SHORT[1])
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "unsignedInt": {
                int v = int(val);
                if (v < 0 || v > RANGE_INT[1])
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "unsignedLong": {
                int v = int(val);
                if (v < 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", type, v);
                break;
            }

            case "positiveInteger":
                if (val <= 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y only accepts positive values (value supplied: %d)", type, val);
                break;

            case "date":
                val = format_date("YYYY-MM-DD", date(val));
                break;

            case "dateTime":
                val = format_date("YYYY-MM-DDTHH:mm:SS", date(val));
                break;

            case "boolean":
                val = val ? "true" : "false";
                break;

            case "time":
                val = format_date("hh:mm:ss.ms", date(val));
                break;

            case "base64Binary":
                val = make_base64_string(val);
                break;

            case "hexBinary":
                val = make_hex_string(val);
                break;
        }

        #printf("DEBUG: FORCE: type: %y, nstype: %y, val: %y\n", type, nstype, val);
        if (omit_type == "ns")
            return ("^attributes^": (
                        "xmlns:xsi": XSI_NS,
                        "xsi:type": sprintf("%s:%s", ons, type),
                    ),
                    "^value^": val,
            );
        if (omit_type)
            return val;
        else
            return (
                "^attributes^": (
                    "xsi:type": sprintf("%s:%s", ons, type),
                ),
                "^value^": val,
            );
    }

    any deserialize(string en, *hash types, *hash mrh, any val) {
        string type;
        if (val.typeCode() == NT_HASH && val."^attributes^") {
            if (val."^attributes^"."xsi:type") {
                type = val."^attributes^"."xsi:type";
                string t = (type =~ x/\w+:(\w+)/)[0];
                if (exists t)
                    type = t;

                if (name != "anyType" && type != name)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("expecting base type %y, got %y", name, val."^attributes^"."xsi:type");
            }
            else
                type = name;
            val = val."^value^";
        }
        else
            type = name;

        switch (type) {
            case "string":
            case "anyURI":
            # note that we do not convert xsd:integer to a qore integer to avoid losing precision
            case "integer":
                return val;

            case "byte":
                val = int(val);
                if ((val & 0xff) != val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                return val;

            case "short":
                val = int(val);
                if (val < RANGE_SHORT[0] || val > RANGE_SHORT[1])
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                return val;

            case "int":
                val = int(val);
                if (val < RANGE_INT[0] || val > RANGE_INT[1])
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                return val;

            case "long":
                return int(val);

            case "unsignedByte":
                val = int(val);
                if ((val & 0xff) != val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                if (val < 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", name, val);
                return val;

            case "unsignedShort":
                val = int(val);
                if ((val & 0xffff) != val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                if (val < 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", name, val);
                return val;

            case "unsignedInt":
                val = int(val);
                if ((val & 0xffffffff) != val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                if (val < 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", name, val);
                return val;

            case "unsignedLong":
                if (val < 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", name, val);
                return int(val);

            case "positiveInteger":
                if (val <= 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y only accepts positive values (value supplied: %d)", name, val);
                return int(val);

            case "date":
                # remove dashes from date
                val =~ s/-//g;
                return date(val);

            case "dateTime":
                return date(substr(val, 0, 4) + substr(val, 5, 2) + substr(val, 8, 2) +
                            substr(val, 11, 2) + substr(val, 14, 2) + substr(val, 17, 2));

            case "time":
                return date("19700101" + substr(val, 0, 2) + substr(val, 3, 2) + substr(val, 6, 2)) +
                       milliseconds(substr(val, 9, 3));

            case "boolean":
                if (val =~ /true/i)
                    return True;
                if (val =~ /false/i)
                    return False;
                return boolean(val);

            case "decimal":
                return float(val);

            case "base64Binary":
                return parse_base64_string(val);

            case "hexBinary":
                return parse_hex_string(val);

            default: {
                if (name == "anyType")  {
                    if (exists types{type})
                        return types{type}.deserialize(en, types, mrh, val);
                }
                throw SOAP_DESERIALIZATION_ERROR, sprintf("don't know how to handle type %y", name);
            }
        }
    }
}

#! class for XSD array types; currently only supports "binary"; used, for example with HTTP MultiPart messages
public class WSDL::XsdArrayType inherits WSDL::XsdAbstractType {
    constructor(string t, Namespaces nsc) : XsdAbstractType(t, "ns1", nsc) {
        if (t != "binary")
            throw "XSD-ARRAYTYPE-ERROR", sprintf("don't know how to handle arrays of type %y", t);
    }

    any serialize(any val, *softbool omit_type, *softbool omit_ns) {
        switch (name) {
            case "binary": {
                int t = val.typeCode();
                if (t === NT_STRING)
                    val = binary(val);
                else if (t !== NT_BINARY)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize type %y from type %y; requires string or binary", name, t);
                return val;
            }

            default: {
                throw SOAP_SERIALIZATION_ERROR, sprintf("don't know how to handle type %y", name);
            }
        }
    }

    any deserialize(string en, *hash types, *hash mrh, any val) {
        switch (name) {
            case "binary": {
                if (val.typeCode() != NT_BINARY)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("cannot deserialize type %y from type %y; requires binary", name, val.typeName());
                return val;
            }

            default: {
                throw SOAP_DESERIALIZATION_ERROR, sprintf("don't know how to handle type %y", name);
            }
        }
    }
}

#! XSD typed data class
public class WSDL::XsdTypedData inherits WSDL::XsdNamedData {
    public {
        any type;
    }

    constructor(reference e) : XsdNamedData(\e) {
    }
}

#! XSD attribute class
public class WSDL::XsdAttribute inherits WSDL::XsdTypedData {
    public {
        string use = "optional";

        const AllowedUseValues = (
            "optional": True,
            "required": True,
            "prohibited": True,
            );
    }

    constructor(hash attr, Namespaces nsc, *XsdAbstractType n_type, XsdLateResolverHelper unresolved) : XsdTypedData(\attr) {
        if (attr.type) {
            type = nsc.doType(attr.type);

            if (attr.use) {
                if (!AllowedUseValues.(attr.use))
                    throw "XSD-ATTRIBUTE-ERROR", sprintf("attribute %y: use %y is unrecognized; recognized use values: %y", name, attr.use, AllowedUseValues.keys());
                use = attr.use;
            }

            # add self to unresolved list if element type cannot be resolved
            if (!(type instanceof XsdAbstractType))
                unresolved.add(self);
        }
    }
}

#! XSD element class
public class WSDL::XsdElement inherits WSDL::XsdTypedData {
    public {
        int minOccurs = 1;
        int maxOccurs = 1;
        bool nillable = False;
        *string ref;
    }

    constructor(hash e, Namespaces nsc, *XsdAbstractType n_type, XsdLateResolverHelper unresolved) : XsdTypedData(\e) {
        if (n_type) {
            type = n_type;
            return;
        }

        *hash a = e."^attributes^";

        if (exists a.minOccurs)
            minOccurs = int(a.minOccurs);

        if (exists a.maxOccurs)
            if (a.maxOccurs == "unbounded")
                maxOccurs = -1;
            else
                maxOccurs = int(a.maxOccurs);

        if (maxOccurs != -1 && minOccurs > maxOccurs)
            throw "XSD-ELEMENT-ERROR", sprintf("minOccurs (%d) > maxOccurs (%d) for element %s", minOccurs, maxOccurs, name);

        if (a.nillable == "true")
            nillable = True;

        if (a.type) {
            type = nsc.doType(a.type);

            # add self to unresolved list if element type cannot be resolved
            if (!(type instanceof XsdAbstractType)) {
                #printf("DEBUG: self: %y\n", self);
                unresolved.add(self);
            }
        }
        else if (e.simpleType)
            type = new XsdSimpleType(e.simpleType, nsc, unresolved);
        else if (e.hasKey("complexType")) {
            type = new XsdComplexType(e.complexType, nsc, unresolved);
            if (!type.required() && !exists a.minOccurs)
                minOccurs = 0;
        }
        else if (e."^attributes^".ref) {
            ref = e."^attributes^".ref;
            unresolved.add(self);
        }
    }

    assimilate(WSDL::XsdElement other) {
        map self.$1 = other.$1, other.keyIterator(), !exists self.$1;
    }

    bool required() {
        return !nillable && minOccurs && ((type instanceof XsdAbstractType && type.required()) | True);
    }

    any serialize(any h, *softbool omit_type, *softbool omit_ns, string key, string typename, reference ons) {
        return serializeAsIntern(type, h, omit_type, omit_ns, key, typename, \ons);
    }

    any serializeAs(XsdAbstractType type, any h, *softbool omit_type, *softbool omit_ns, string key, string typename, reference ons) {
        type.checkExtends(type, name);
        return serializeAsIntern(type, h, omit_type, omit_ns, key, name, \ons);
    }

    private any serializeAsIntern(XsdAbstractType type, any h, *softbool omit_type, *softbool omit_ns, string key, string typename, reference ons) {
        #printf("DEBUG: XsdElement::serializeAsIntern() name: %y h: %y key: %y typename: %y (%y) minOccurs: %y nillable: %y (%y %y)\n", name, h, key, typename, type.getName(), minOccurs, nillable, !exists h, !minOccurs);
        ons = type.getOutputNamespacePrefix();

        if (h.typeCode() == NT_LIST && h.size() == 1)
            h = h[0];

        if (!exists h) {
            if (!minOccurs)
                return;

            if (nillable) {
                hash rh = ("xsi:nil" : "true");
                if (!omit_type)
                    rh += ("xsi:type" : type.getNameWithNS());
                return ("^attributes^" : rh);
            }

            if (!type.required())
                return;

            throw SOAP_SERIALIZATION_ERROR, sprintf("missing element %y value for %s::%s (minOccurs: %d, type %y)", name, typename, key, minOccurs, type.getName());
        }

        *hash pf;
        if (omit_type && type != type)
            pf = ("^attributes^": ("xsi:type": omit_ns ? type.getName() : type.getNameWithNS()));

        if (h.typeCode() == NT_LIST) {
            if (maxOccurs == 1)
                throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize element %y of type %y from a list because maxOccurs = 1", name, type.getName());
            if (elements h > maxOccurs && maxOccurs > 0)
                throw SOAP_SERIALIZATION_ERROR, sprintf("list for element %y of type %y has %d element%s, but maxOccurs = %d", name, type.getName(), elements h, elements h == 1 ? "" : "s", maxOccurs);
            if (elements h < minOccurs)
                throw SOAP_SERIALIZATION_ERROR, sprintf("list for element %y of type %y has %d element%s, but minOccurs = %d", name, type.getName(), elements h, elements h == 1 ? "" : "s", minOccurs);

            list l = ();
            foreach any e in (h) {
                l += (pf + type.serialize(e, omit_type, omit_ns));
            }
            return l;
        }
        if (minOccurs > 1)
            throw SOAP_SERIALIZATION_ERROR, sprintf("only one element passed to element %y of type %y, but minOccurs = %d", name, type.getName(), minOccurs);

        #printf("DEBUG: element %y type %s: %y omit_type: %y omit_ns: %y h: %y\n", name, type.className(), type.name, omit_type, omit_ns, h);
        return (pf + type.serialize(h, omit_type, omit_ns));
    }

    any deserialize(*hash types, *hash mrh, any val) {
        any a = val."^attributes^";
        WSDL::XsdBase::removeNS(\a);

        if (!exists val || a.nil == "true" && !mrh.body.hasKey(name)) {
            if (nillable || !minOccurs)
                return;
            throw SOAP_DESERIALIZATION_ERROR, sprintf("NOTHING passed for element %y, but nillable=False and minOccurs: %d", name, minOccurs);
        }

        if (val.typeCode() == NT_LIST) {
            int el = elements val;
            if (maxOccurs != -1 && el > maxOccurs)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("error deserializing element %y, maxOccurs: %d but list is %d elements long", name, maxOccurs, el);
            if (el < minOccurs)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("error deserializing element %y, minOccurs: %d but list is %d elements long", name, minOccurs, el);

            list l;
            foreach any e in (val)
                l[elements l] = type.deserialize(name, types, mrh, getValue(mrh, e));
            return l;
        }

        if (minOccurs > 1)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("single value passed for element %y, but minOccurs: %d", name, minOccurs);

        return type.deserialize(name, types, mrh, getValue(mrh, val));
    }
}

#! XSD simple type class
public class WSDL::XsdSimpleType inherits WSDL::XsdAbstractType {
    public {
        hash enum;
        any type;
    }

    constructor(hash st, Namespaces nsc, XsdLateResolverHelper unresolved) : XsdAbstractType(\st, nsc) {
        #any a = st."^attributes^";
        delete st."^attributes^";

        WSDL::XsdBase::removeNS(\st);

        if (st.restriction) {
            *hash r = st.restriction;

            any base = r."^attributes^".base;
            if (!base)
                throw "XSD-SIMPLETYPE-ERROR", sprintf("missing 'base' attribute in simpleType %y restriction", name);

            type = nsc.doType(base);

            # add base type to unresolved list if type cannot be resolved
            if (!(type instanceof XsdData))
                unresolved.add(self);

            WSDL::XsdBase::removeNS(\r);

            if (r.enumeration)
                map enum.($1."^attributes^".value) = True, r.enumeration;
            #enum = map $1."^attributes^".value, r.enumeration;
            /*
            else
                throw "XSD-SIMPLETYPE-ERROR", sprintf("missing enumeration element in simpleType %y restriction", name);
            */
        }
        else
            throw "XSD-SIMPLETYPE-ERROR", sprintf("missing restriction element in simpleType %y", name);

        #printf("DEBUG: st: %Y\n", self); exit();
    }

    any serialize(any val, *softbool omit_type, *softbool omit_ns) {
        if (enum && !enum{val})
            throw "SOAP-SERIALIZATION-ERROR", sprintf("value %y passed to simpleType %y is not in the enumeration list (%y)", val, name, enum.keys());

        return type.serialize(val, omit_type, omit_ns);
    }

    any deserialize(string en, *hash types, *hash mrh, any val) {
        any v = type.deserialize(en, types, mrh, val);

        if (enum && !enum{v})
            throw "SOAP-DESERIALIZATION-ERROR", sprintf("value %y passed to simpleType %y is not in the enumeration list (%y)", v, name, enum.keys());

        return v;
    }
}

#! XSD complex type class
public class WSDL::XsdComplexType inherits WSDL::XsdAbstractType {
    public {
        any array;
        any restriction;
        *string extension;
        any hash_type;
        *hash elementmap;

        bool anyAttribute = False;

        bool required = False;

        # attributes
        hash attrs;

        # any annotated documentation
        *string documentation;
    }

    constructor(hash ct, Namespaces nsc, XsdLateResolverHelper unresolved) : XsdAbstractType(\ct, nsc) {
        #any a = ct."^attributes^";
        delete ct."^attributes^";

        any d = ct.complexContent;
        if (d) {
            WSDL::XsdBase::removeNS(\d);
            if (d.restriction) {
                WSDL::XsdBase::removeNS(\d.restriction);

                any base = d.restriction."^attributes^".base;

                # FIXME: handle namespace
                my (any ns, any tn) = base =~ x/(\w+):(\w+)/;
                if (exists tn) {
                    if (tn == "Array") {
                        # FIXME check that namespace is SOAP encoding
                        any aa = d.restriction.attribute."^attributes^";
                        WSDL::XsdBase::removeNS(\aa);
                        if (!exists aa.arrayType)
                            throw WSDL_ERROR, sprintf("cannot parse complexType restriction: %y", d.restriction);

                        # FIXME: handle multiple dimensions?
                        my (any ans, any atn) = aa.arrayType =~ x/(\w+):(\w+)\[\]$/;
                        if (exists atn) {
                            array.val = atn;
                            array.ns  = ans;
                        }
                        else
                            array.val = aa.arrayType;

                        delete d.restriction.attribute;
                        #printf("DEBUG: ans: %y atn: %y aa: %Y\n", ans, atn, aa);
                        return;
                    }
                    else {
                        restriction = tn;
                    }
                }

                delete d.restriction."^attributes^";

                parseData(d.restriction, unresolved);
            }
            else if (d.extension) {
                extension = d.extension."^attributes^".base;

                # FIXME: check for soap encoding namespace
                extension =~ s/(.*:)(.*)/$2/;
                delete d.extension."^attributes^";
                WSDL::XsdBase::removeNS(\d.extension);

                parseData(d.extension, unresolved);
            }
            else
                throw "XSD-COMPLEXCONTENT-ERROR", sprintf("can't parse complexContent %y information", d.firstKey());
        }
        else if (ct)
            parseData(ct, unresolved);
    }

    checkExtends(XsdAbstractType t, string ename) {
        if (extension == t.name)
            return;
        throw SOAP_SERIALIZATION_ERROR, sprintf("explicit type %y given for element %y, type %y, however the types are not compatible%s", name, ename, t.name, extension ? sprintf("; %y extends %y", name, extension) : "");
    }

    private parseData(any d, XsdLateResolverHelper unresolved) {
        delete d.ns;
        if (d.annotation) {
            *hash ah = remove d.annotation;
            if (ah.size() == 1 && ah.firstKey() =~ /documentation$/)
                documentation = trim(ah.firstValue());
        }
        if (!d)
            return;

        list el = keys d;
        if (inlist("anyAttribute", el)) {
            anyAttribute = True;
            delete d.anyAttribute;
            el = keys d;
        }

        # process attributes if any
        foreach hash ah in (remove d.attribute) {
            if (ah."^attributes^") {
                XsdAttribute attr(ah, nsc, NOTHING, unresolved);
                attrs.(attr.name) = attr;
            }
        }

        if (elements d > 1)
            throw WSDL_ERROR, sprintf("%s: expecting a single element in the complexType hash, got: %y", name, el);

        string k = el[0];
        if (k == "all") {
            hash_type = XET_ALL;
            WSDL::XsdBase::removeNS(\d.all);
            elementmap = parseElements(d.all.element, unresolved);
        }
        else if (k == "choice") {
            hash_type = XET_CHOICE;
            WSDL::XsdBase::removeNS(\d.choice);
            elementmap = parseElements(d.choice.element, unresolved);
        }
        else if (k == "sequence") {
            hash_type = XET_SEQUENCE;
            WSDL::XsdBase::removeNS(\d.sequence);
            if (d.sequence.element)
                elementmap = parseElements(d.sequence.element, unresolved);
        }
        else
            throw "XSD-COMPLEXTYPE-ERROR", sprintf("unknown keys in %y", d);
    }

    bool required() {
        return required;
    }

    private *hash parseElements(any el, XsdLateResolverHelper unresolved) {
        #printf("DEBUG: XsdComplexType::parseElements(%y)\n", el);
        hash h;
        foreach any e in (el) {
            #printf("DEBUG: XsdComplexType::parseElements() ns: %y e: %y\n", nsc.getTargetNamespaceUri(), e);
            XsdElement elem(e, nsc, NOTHING, unresolved);
            h.(elem.name) = elem;
            if (!required && elem.required())
                required = True;
        }
        return h;
    }

    private *hash serializeElement(string key, any h, *softbool omit_type, *softbool omit_ns) {
        any e;
        any v = h{key};
        string e_ons;
        #printf("DEBUG: XsdComplexType::serializeElement() key: %y v: %y h: %y ns: %y\n", key, v, h, nsc.getTargetNamespaceUri());
        if (v."^type^" && v."^type^" instanceof XsdAbstractType && v.hasKey("^val^")) {
            #printf("DBG: type: %s: %y val: %y\n", v."^type^".className(), v."^type^".name, v."^val^");
            e = elementmap{key}.serializeAs(v."^type^", v."^val^", omit_type, omit_ns, key, name, \e_ons);
        }
        else
            e = elementmap{key}.serialize(v, omit_type, omit_ns, key, name, \e_ons);

        if (!exists e)
            return;

        /*
        if (e_ons != ons && e_ons != "xsd") {
            if (e.typeCode() != NT_HASH)
                e = ("^value^": e);
            e."^attributes^" = ("xmlns": nsc.getOutputNamespaceUri(ons));
        }
        */

        hash rv.(omit_ns ? key : (ons + ":" + key)) = e;
        return rv;
    }

    *hash serialize(any h, *softbool omit_type, *softbool omit_ns) {
        if (exists array)
            return array.serialize(h, omit_type, omit_ns);

        if (h.typeCode() != NT_HASH)
            throw SOAP_SERIALIZATION_ERROR, sprintf("expecting hash argument to serialize from complexType %y (got %y, type %y)", getName(), h, type(h));

        # process attributes first
        *hash ah;
        if (h."^attributes^") {
            hash mah = remove h."^attributes^";
            foreach string k in (mah.keyIterator()) {
                if (!attrs{k})
                    throw SOAP_SERIALIZATION_ERROR, sprintf("cannot set unknown attribute %y of element %y; known attributes: %y", k, getName(), attrs.keys());
                if (attrs{k}.use == "prohibited")
                    throw SOAP_SERIALIZATION_ERROR, sprintf("cannot set attribute %y of element %y; the WSDL marks this attribute as prohibited", k, getName());
                ah{k} = mah{k};
            }
        }
        # check for required attributes
        foreach XsdAttribute attr in (attrs.iterator()) {
            if (attr.use == "required" && !exists ah.(attr.name))
                throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize element %y without attribute %y; the WSDL marks this attribute as required", getName(), attr.name);
        }

        hash rh;

        if (hash_type == XET_SEQUENCE || hash_type == XET_ALL) {
            foreach string p in (elementmap.keyIterator()) {
                #printf("DEBUG element: %y (%y)\nvalue: %y\n", p, elementmap{p}, h{p});
                rh += serializeElement(p, h, omit_type, omit_ns);
                delete h{p};
            }
            if (elements h) {
                any kl = h.size() == 1 ? h.firstKey() : h.keys();
                throw SOAP_SERIALIZATION_ERROR, sprintf("%y %s of type %y (valid elements: %y)", kl, kl.lsize() == 1 ? "is an invalid member" : "are invalid members", getName(), elementmap.keys());
            }
        }
        else { # "choice" - union
            if (elements h > 1)
                throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize type %s with more than 1 member (%y)", getName(), keys h);
            *string key = h.firstKey();
            if (!elementmap{key})
                throw SOAP_SERIALIZATION_ERROR, sprintf("%y is an invalid member of type %y", key, getName());

            # add namespace if necessary
            rh = serializeElement(key, h, omit_type, omit_ns);
        }

        if (name && !omit_type)
            rh."^attributes^" = ("xsi:type": "ns1:" + name) + ah;
        else if (ah)
            rh."^attributes^" = ah;
        #printf("complex type %s returning %y from %y\n", name, rh, h);
        return rh;
    }

    *hash deserialize(string en, *hash types, *hash mrh, any oval) {
        if (exists array)
            return array.deserialize(en, types, mrh, oval);

        if (!exists oval) {
            if (!required)
                return;
        }

        if (oval.typeCode() != NT_HASH)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("cannot deserialize element %y type %y from qore type %y (expecting hash)", en, getName(), type(oval));

        hash rh;

        hash val = oval;
        any attr = val."^attributes^";

        # parse incoming valid attributes
        *hash ah;
        foreach XsdAttribute xa in (attrs.iterator()) {
            *string attr_val = val."^attributes^".(xa.name);
            if (xa.use == "required" && !exists attr_val)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("cannot deserialize element %y without attribute %y; the WSDL marks this attribute as required", getName(), xa.name);
            if (exists attr_val) {
                if (attr.use == "prohibited")
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("cannot deserialize element %y with attribute %y; the WSDL marks this attribute as prohibited", getName(), xa.name);
                ah.(xa.name) = attr_val;
            }
        }

        delete val."^attributes^";

        # ensure types match
        any tn = attr."xsi:type";
        if (exists tn) {
            my (any ns, any name) = tn =~ x/(.*):(.*)/;
            if (exists name)
                tn = name;
            if (tn != name) {
                #printf("DEBUG: %y: %s\n", tn, types{tn} ? types{tn}.className() : "n/a");
                # check for compatible extension
                if (types{tn}) {
                    types{tn}.checkExtends(self, en);
                    return types{tn}.deserialize(en, types, mrh, oval);
                }

                throw SOAP_DESERIALIZATION_ERROR, sprintf("expecting ComplexType type %y for element %y, got %y", getName(), en, tn);
            }
        }

        WSDL::XsdBase::removeNS2(\val);

        #any ns = val.".ns";
        val -= ".ns";

        if (hash_type == XET_SEQUENCE || hash_type == XET_ALL) {
            foreach string p in (elementmap.keyIterator()) {
                #printf("element %y\n", p);
                rh{p} = elementmap{p}.deserialize(types, mrh, getValue(mrh, val{p}));
                delete val{p};
            }
            delete val."^attributes^";
            if (elements val)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("invalid element %y passed in type %y for element %y (expecting %y)", (keys val)[0], getName(), en, keys elementmap);
        }
        else { # "choice" - union
            any kl = keys val;
            if (elements kl > 1)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("too many elements supplied for union type %y for element %y (%y)", getName(), en, kl);
            kl = kl[0];
            if (!exists elementmap{kl})
                throw SOAP_DESERIALIZATION_ERROR, sprintf("element %y is not a valid element for union type %y for element %y", kl, getName(), en);

            rh{kl} = elementmap{kl}.deserialize(types, mrh, getValue(mrh, val{kl}));
        }
        if (ah)
            rh."^attributes^" = ah;
        return rh;
    }
}

#! web service operation class
public class WSDL::WSOperation inherits WSDL::XsdNamedData {
    public {
        WSMessage input;
        WSMessage output;
        *string input_name;
        *string output_name;
        any types;

        Namespaces nsc;

        bool usedocns = False;
        *string soapAction;
        *string request_name;
        *hash inp;
         outp;
        bool docstyle = False;

        # info about soap header requirements
        hash iheader;
        hash oheader;
    }

    constructor(any p, *hash n_types, Namespaces n_nsc, *hash messages, bool n_usedocns = False) : XsdNamedData(\p) {
        types = n_types;
        nsc = n_nsc;
        usedocns = n_usedocns;

        hash msghash = processNSValue(p.input."^attributes^");

        *WSMessage msg = messages.(msghash.message.val);
        if (!msg)
            throw WSDL_ERROR, sprintf("missing definition for input message %y required by operation %y", msghash.name.val, name);
        input = msg;

        #printf("DBG: WSOperation::constructor() name: %y msghash: %y\n", name, msghash);
        if (msghash.name)
            input_name = msghash.name.val ? msghash.name.val : msghash.name;

        if (p.output) {
            msghash = processNSValue(p.output."^attributes^");

            msg = messages.(msghash.message.val);
            if (!exists msg)
                throw WSDL_ERROR, sprintf("missing definition for output message %y required by operation %y", msghash.name.val, name);

            output = msg;
            if (msghash.name)
                output_name = msghash.name.val ? msghash.name.val : msghash.name;
        }

        *string op_ns = nsc.getTargetNamespaceUri();
        if (op_ns && op_ns !~ /\/$/)
            op_ns += "/";
        soapAction = op_ns ? op_ns + name : name;
    }

    setDocStyle(reference idocmap) {
        docstyle = True;

        foreach string key in (input.args.keyIterator()) {
            string element = input.args{key}.element.name;
            idocmap{element} = input.args{key}.element;
            if (!request_name)
                request_name = element;
        }
    }

    setTopLevelRequestElement(string name) {
        request_name = name;
    }

    string getTopLevelRequestName() {
        return request_name ? request_name : name;
    }

    #! serializes a request to an XML string for the operation
    /** @param h the request to serialize
        @param header optional soap header info to serialize if required (ex: authorization info)
        @param enc the optional encoding to use; if this argument is not present, then the default encoding will be used

        @return a hash with keys:
        - \c body: XML string in the SOAP request format
        - \c hdr: hash of HTTP headers
        */
    hash serializeRequest(any h, *hash header, *string enc, *hash nsh) {
        # setup namespaces for SOAP envelope
        hash rh = nsc.hasSoap12() ? WSDL::ENVELOPE_12_NS : WSDL::ENVELOPE_11_NS;

        # ns1 (( "^attributes^" :
        rh."soapenv:Envelope"."^attributes^" += nsc.getOutputNamespaceHash(nsh);

        #printf("DEBUG header: %y\n", header);

        if (header) {
            if (iheader) {
                hash hh.(iheader.part) = header;
                rh."soapenv:Envelope"."soapenv:Header" = iheader.msg.serializeDocument(iheader.part, NOTHING, NOTHING, hh, usedocns);
            }
            else {
                rh."soapenv:Envelope"."soapenv:Header" = header;
            }
        }

        MultiPartRelatedMessage mpm;
        # do we have mime/multipart input format?
        if (exists inp.multipart)
            mpm = new MultiPartRelatedMessage();

        #printf("DEBUG: docstyle: %y\n", docstyle);
        if (docstyle)
            rh."soapenv:Envelope"."soapenv:Body" = input.serializeDocument(NOTHING, inp, mpm, h, usedocns);
        else {
            string mname = input_name ? input_name : name;
            rh."soapenv:Envelope"."soapenv:Body" = input.serialize(inp, mpm, mname, h);
        }

        string body = HAVE_LIBRARY_DEBUGGING ? makeFormattedXMLString(rh, enc) : makeXMLString(rh, enc);

        if (mpm) {
            mpm.splicePart(body, sprintf("<%s>", inp.body.parts), nsc.hasSoap12() ? MimeTypeSoapXml : MimeTypeXml);

            hash rv = mpm.getMsgAndHeaders();
            if (soapAction) {
                if (nsc.hasSoap12())
                    rv.hdr."Content-Type" += sprintf(";action: %s", soapAction);
                rv.hdr += ("SOAPAction" : soapAction);
            }

            rv.hdr."Content-Type" += sprintf(";charset: %s", exists enc ? enc : get_default_encoding());
            return rv;
        }

        string ct;
        if (nsc.hasSoap12()) {
            ct = MimeTypeSoapXml;
            if (soapAction)
                ct += sprintf(";action: %s", soapAction);
        }
        else
            ct = MimeTypeXml;

        ct += sprintf(";charset: %s", exists enc ? enc : get_default_encoding());

        hash rv = ("hdr": ("Content-Type": ct),
                       "body": body );

        if (soapAction)
            rv.hdr += ("SOAPAction": soapAction);

        return rv;
    }

    #! serializes a SOAP response to an XML string for the operation
    /** @param h the response to serialize
        @param header SOAP header hash
        @param enc the optional encoding to use; if this argument is not present, then the default encoding will be used
        @param nsh namespace hash
        @param soap12 set to True if the response should use SOAP 1.2 encoding

        @return a hash with keys:
        - \c body: XML string in the SOAP request format
        - \c hdr: hash of HTTP headers
    */
    hash serializeResponse(any h, *hash header, *string enc, *hash nsh, *bool soap12) {
        if (soap12) {
            if (!nsc.hasSoap12())
                throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize response for operation %y with SOAP 1.2 encoding; this operation does not support SOAP 1.2", name);
        }
        else {
            if (!nsc.hasSoap11())
                throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize response for operation %y with SOAP 1.1 encoding; this operation does not support SOAP 1.1", name);
        }
        # setup namespaces for SOAP envelope
        hash rh = soap12 ? WSDL::ENVELOPE_12_NS : WSDL::ENVELOPE_11_NS;

        rh."soapenv:Envelope"."^attributes^" += nsc.getOutputNamespaceHash(nsh);

        if (header) {
            if (oheader) {
                hash hh.(oheader.part) = header;
                rh."soapenv:Envelope"."soapenv:Header" = oheader.msg.serializeDocument(oheader.part, NOTHING, NOTHING, hh, usedocns);
            }
            else {
                rh."soapenv:Envelope"."soapenv:Header" = header;
            }
        }

        MultiPartRelatedMessage mpm;
        # do we have mime/multipart output format?
        if (exists outp.multipart)
            mpm = new MultiPartRelatedMessage();

        #printf("DEBUG: docstyle: %y\n", docstyle);
        if (docstyle)
            rh."soapenv:Envelope"."soapenv:Body" = output.serializeDocument(NOTHING, outp, mpm, h, usedocns);
        else {
            string mname = input_name ? input_name : name + "Response";
            rh."soapenv:Envelope"."soapenv:Body" = output.serialize(outp, mpm, mname, h);
        }

        string body = HAVE_LIBRARY_DEBUGGING ? makeFormattedXMLString(rh, enc) : makeXMLString(rh, enc);

        string ct = soap12 ? MimeTypeSoapXml : MimeTypeXml;
        if (exists mpm) {
            mpm.splicePart(body, sprintf("<%s>", outp.body.parts), ct);
            return mpm.getMsgAndHeaders();
        }

        ct += sprintf(";charset: %s", exists enc ? enc : get_default_encoding());

        return ( "hdr"  : ( "Content-Type" : ct ),
                 "body" : body );
    }

    private list processMultiRef(hash body) {
        # setup message info hash and multiRef lookup hash key, if any are present
        hash mrh = (
            # save original msg body hash
            "body": body,
            );
        # remove namespacr prefixes from body element keys
        WSDL::XsdBase::removeNS2(\mrh.body);

        if (body.multiRef) {
            foreach any mr in (body.multiRef)
                mrh.mrh.(mr."^attributes^".id) = mr;

            # resolve interior references to multiRefs
            foreach string id in (mrh.mrh.keyIterator()) {
                foreach string key in (mrh.mrh{id}.keyIterator()) {
                    if (key == "^attributes^")
                        continue;

                    #printf("multiRef id: %y key: %y val: %y\n", id, key, mrh.mrh{id}{key});

                    if (mrh.mrh{id}{key}.typeCode() == NT_LIST) {
                        foreach any e in (\mrh.mrh{id}{key}) {
                            any href = substr(e."^attributes^".href, 1);
                            if (exists href) {
                                if (!exists mrh.mrh{href})
                                    throw "INVALID-MULTIREF", sprintf("multiRef id: %y does not exist", href);
                                e = mrh.mrh{href};
                            }
                        }
                    }
                    else if (mrh.mrh{id}{key}.typeCode() == NT_HASH) {
                        any href = substr(mrh.mrh{id}{key}."^attributes^".href, 1);
                        if (exists href) {
                            if (!exists mrh.mrh{href})
                                throw "INVALID-MULTIREF", sprintf("multiRef id: %y does not exist", href);
                            mrh.mrh{id}{key} = mrh.mrh{href};
                        }
                    }
                }
            }

            delete body.multiRef;
        }
        #printf("mrh: %Y\n", mrh.mrh);
        #printf("operation: %Y\n", self);

        # remove namespace tags from element names
        WSDL::XsdBase::removeNS2(\body);
        remove body.".ns";

        return (mrh, body);
    }

    #! parses a hash representing a parsed XML request (parsed with parseXMLAsData()) for the operation and returns the corresponding Qore data structure
    /** @param o the parsed XML request (parsed with parseXMLAsData()) for the operation
    @return the Qore data structure corresponding to the request data
    */
    any deserializeRequest(hash o) {
        WSDL::XsdBase::removeNS(\o);
        WSDL::XsdBase::removeNS(\o.Envelope);

        hash body = o.Envelope.Body;

        my (*hash mrh, hash msg) = processMultiRef(body);

        #any ns = msg.".ns";
        msg -= ("ns", ".ns");

        if (docstyle)
            return input.deserializeDocument(types, mrh, msg);

        string mname = input_name ? input_name : name;
        if (!msg{mname})
            throw SOAP_DESERIALIZATION_ERROR, sprintf("missing input message name %y as top-level element; got elements: %y", mname, keys msg);
        msg = remove msg{mname};
        XsdBase::removeNS2(\msg);
        remove msg.".ns";

        return input.deserialize(types, mrh, msg);
    }

    #! parses a hash representing a parsed XML response (parsed with parseXMLAsData()) for the operation and returns the corresponding Qore data structure
    /** @param o the parsed XML response (parsed with parseXMLAsData()) for the operation
    @return the Qore data structure corresponding to the response data
    */
    any deserializeResponse(hash o) {
        WSDL::XsdBase::removeNS2(\o);
        WSDL::XsdBase::removeNS2(\o.Envelope);

        hash body = o.Envelope.Body;

        my (*hash mrh, hash msg) = processMultiRef(body);

        # check for Soap Fault, if so raise an exception immediately with the fault info
        WSDL::XsdBase::removeNS2(\body);

        if (body.Fault) {
            WSDL::XsdBase::removeNS(\body.Fault);
            delete body.Fault.".ns";
            if (nsc.hasSoap12()) {
                WSDL::XsdBase::removeNS(\body.Fault.Code);
                WSDL::XsdBase::removeNS(\body.Fault.Reason);
                string desc = sprintf("The following fault response was received from the server: code: %y", body.Fault.Code.Value);
                any sc = body.Fault.Code.Subcode;
                while (exists sc) {
                    WSDL::XsdBase::removeNS(\sc);
                    desc += sprintf(", subcode: %y", sc.Value);
                    sc = sc.Subcode;
                }
                foreach any rn in (body.Fault.Reason.Text) {
                    desc += sprintf(", text: %y", rn);
                }

                throw "SOAP-SERVER-FAULT-RESPONSE", desc, body.Fault;
            }
            else {
                string desc = sprintf("The following fault response was received from the server: code: %y", body.Fault.faultcode);
                if (exists body.Fault.faultstring)
                    desc += sprintf(", faultstring: %y", body.Fault.faultstring);
                if (exists body.Fault.desc)
                    desc += sprintf(", desc: %y", body.Fault.desc);

                throw "SOAP-SERVER-FAULT-RESPONSE", desc, body.Fault;
            }
        }

        if (docstyle)
            return output.deserializeDocument(types, mrh, msg);

        string mname = input_name ? input_name : name + "Response";
        if (!msg{mname})
            throw SOAP_DESERIALIZATION_ERROR, sprintf("missing output message name %y as top-level element; got elements: %y", mname, keys msg);
        msg = remove msg{mname};
        XsdBase::removeNS2(\msg);
        msg -= (".ns", "ns");

        return output.deserialize(types, mrh, msg);
    }

    private hash processNSValue(hash h) {
        foreach string k in (keys h) {
            my (*string ns, *string name) = h{k} =~ x/(\w+):(\w+)/;
            if (!name)
                h{k}.val = h{k};
            else {
                h{k}.ns = ns;
                h{k}.val = name;
            }
        }
        return h;
    }

    #! returns True if the operation is a SOAP 1.2 operation
    /** @return True if the operation is a SOAP 1.2 operation
    */
    bool isSoap12() {
        return nsc.hasSoap12();
    }

    #! returns the target namespace for the operation
    /** @return the target namespace for the operation
    */
    string getTargetNS() {
        return nsc.getTargetNamespaceUri();
    }

    setOutputMultipart(any v) {
        outp.multipart = v;
        outp.parts = ();
    }

    private parsePart(reference msg, any part) {
        WSDL::XsdBase::removeNS(\part);
        #any a = part."^attributes^";
        part -= "^attributes^";

        if (exists part.body) {
            any pa = part.body."^attributes^";
            if (pa.use != "literal")
                throw WSDL_ERROR, sprintf("unsupported body part without use=\"literal\": %y", part.body);
            msg.body = pa;
        }
        else if (exists part.content) {
            foreach any c in (part.content) {
                any pa = c."^attributes^";
                any name = pa.part;
                if (!exists name)
                    throw WSDL_ERROR, sprintf("unsupported content part without part attribute: %y", c);
                any type = pa.type;
                if (!exists type)
                    throw WSDL_ERROR, sprintf("unsupported content part without type attribute: %y", c);

                if (!exists msg.parts{name})
                    msg.parts{name} = type;
                else {
                    if (msg.parts{name}.typeCode() != NT_LIST)
                        msg.parts{name} = list(msg.parts{name});
                    msg.parts{name} += type;
                }
            }
        }
        else
            throw WSDL_ERROR, sprintf("cannot parse part: %y", part);

        #printf("DEBUG: part: %Y\nmsg: %Y\n", part, msg);#exit();
    }

    addOutputPart(any part) {
        if (!exists outp.multipart)
            throw WSDL_ERROR, sprintf("WSOperation::addOutputPart(): internal error: cannot add a part to a non-multipart message; part: %y", part);

        parsePart(\outp, part);
    }

    setInputMultipart(any v) {
        inp.multipart = v;
        inp.parts = ();
    }

    addInputPart(any part) {
        if (!exists inp.multipart)
            throw WSDL_ERROR, sprintf("WSOperation::addInputPart(): internal error: cannot add a part to a non-multipart message; part: %y", part);

        parsePart(\inp, part);
    }

    setInputHeader(string part, WSMessage msg, bool encoded) {
        # FIXME: additional header parts are ignored!!!
        if (!iheader)
            iheader = ("part": part, "msg": msg, "encoded": encoded);
    }
}

#! web service message class
public class WSDL::WSMessage inherits WSDL::XsdNamedData {
    public {
        hash args;
        # part map; maps element names to part names
        hash pmap;
        bool encoded = False;

        # keep a reference to Namespaces
        Namespaces nsc;
    }

    constructor(hash m, *hash elementmap, Namespaces n_nsc) : XsdNamedData(\m) {
        nsc = n_nsc;

        #printf("DEBUG: WSMessage::constructor() m: %y elementmap: %y\n", m, elementmap);

        name = m."^attributes^".name;
        foreach any p in (m.part) {
            any arg = p."^attributes^";
            if (arg.element) {
                my (*string ns, *string name) = arg.element =~ x/(\w+):(\w+)/;
                if (!name)
                    name = arg.element;

                if (arg.name && arg.name != name)
                    pmap{name} = arg.name;

                if (!elementmap{name}) {
                    #printf("DEBUG: WSMessage::constructor() message %y element %y (%y)\n", name, arg.element, keys elementmap);
                    throw WSDL_ERROR, sprintf("message %y references unknown element %y (known elements: %y)", name, name, elementmap.keys());
                }
                args{name}.element = elementmap{name};
            }
            else {
                args{arg.name} = arg;
                args{arg.name}.type = nsc.doType(p."^attributes^".type);
            }
        }
    }

    hash serialize(any msginfo, any mpm, string n_name, any h) {
        hash rh;
        #printf("DEBUG: message %s: h: %y\n", name ,h);

        foreach string k in (args.keyIterator()) {
            any v;
            if (h.hasKey(k))
                v = remove h{k};
            else if (pmap{k} && !exists h{k})
                v = remove h.(pmap{k});

            /*
            if (!exists h{k}) {
                if (pmap{k} && !exists h{k})
                    h{k} = remove h.(pmap{k});
                else
                    throw SOAP_SERIALIZATION_ERROR, sprintf("missing message argument %y (got %y instead)", k, h.keys());
            }
            */

            any hv;
            #printf("DEBUG: arg %y with %y\n", k, args{k});
            string ons;
            if (args{k}.element)
                hv = args{k}.element.serialize(v, !encoded, NOTHING, k, name, \ons);
            else {
                hv = args{k}.type.serialize(v, !encoded, True);
                ons = args{k}.type.getOutputNamespacePrefix();
            }
            #printf("DEBUG: arg %s got %y from %y (%y)\n", k, hv, v, exists args{k}.element ? args{k}.element : args{k}.type);

            #printf("DEBUG: WSMessage::serialize() k: %y args: %y, parts: %y\n", k, keys args, msginfo.parts);
            if (msginfo.parts{k}) {
                any ct = msginfo.parts{k};
                if (ct.typeCode() == NT_LIST)
                    ct = shift ct;
                mpm.addPart(hv, sprintf("<%s>", k), ct);
                hv."^attributes^".href = "cid:" + k;
            }

            string en = args{k}.element ? (ons + ":" +  k) : k;
            rh{en} = hv;
        }

        if (h.typeCode() == NT_HASH && h)
            throw SOAP_SERIALIZATION_ERROR, sprintf("additional keys %y included in %y message hash", h.keys(), name);

        if (encoded)
            rh."^attributes^" +=
            ( "soapenv:encodingStyle" : SOAP_ENCODING,
              "xmlns:soapenc"         : SOAP_ENCODING );

        hash rvh.("ns1:" + n_name) = rh;

        return rvh;
    }

    hash serializeDocument(*string k, any msginfo, any mpm, any h, bool force_ns) {
        hash rh;

        if (encoded)
            rh."^attributes^" += (
                "soapenv:encodingStyle": SOAP_ENCODING,
                "xmlns:soapenc": SOAP_ENCODING,
            );

        if (!k && args.size() == 1) {
            string key = args.firstKey();
            any v = (h.typeCode() == NT_HASH && h.hasKey(key)) ? remove h{key} : remove h;
            XsdBase::removeNS2(\v);
            string ons;
            any th = args{key}.element.serialize(v, !encoded, !force_ns, key, name, \ons);
            rh.(ons + ":" + args{key}.element.name) = th;
        }
        else {
            foreach string key in (k ? k : args.keyIterator()) {
                any val = remove h{key};
                if (val.typeCode() == NT_HASH)
                    XsdBase::removeNS2(\val);

                string ons;
                any th = args{key}.element.serialize(val, !encoded, !force_ns, key, name, \ons);
                rh.(ons + ":" + args{key}.element.name) = th;
            }
        }

        if (h.typeCode() == NT_HASH && h)
            throw SOAP_SERIALIZATION_ERROR, sprintf("additional keys %y included in %y message hash", h.keys(), name);

        #printf("DEBUG: message %s: force_ns: %y args: %y h: %y\n", name, force_ns, keys args, h);

        return rh;
    }

    any deserialize(*hash types, *hash mrh, hash val) {
        #printf("DBG WSMessage::deserialize() args: %y pmap: %y val: %y\n", args.keys(), pmap, val);
        hash ro;

        foreach string key in (args.keyIterator()) {
            any v = remove val{key};
            if (v.typeCode() == NT_HASH)
                XsdBase::removeNS2(\v);

            string rk = key;
            if (pmap{key} && !args.(pmap{key}))
                rk = pmap{key};

            ro{rk} = args{key}.element
                ? args{key}.element.deserialize(types, mrh, getValue(mrh, v))
                : args{key}.type.deserialize(name, types, mrh, getValue(mrh, v));
        }

        if (val)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("additional keys %y included in %y message hash", val.keys(), name);

        # if there is only one argument, return it directly
        return ro.size() == 1 ? ro.firstValue() : ro;
    }

    any deserializeDocument(*hash types, *hash mrh, any val) {
        any rh;

        *hash attr = remove val."^attributes^";

        #printf("DBG WSMessage::deserializeDocument() args: %y val: %y\n", args.keys(), val);
        if (args.size() == 1) {
            string key = args.firstKey();
            any v = (val.typeCode() == NT_HASH && val.hasKey(key)) ? remove val{key} : remove val;
            XsdBase::removeNS2(\v);
            rh = args.firstValue().element.deserialize(types, mrh, v);
        }
        else {
            foreach string key in (args.keyIterator()) {
                any v = remove val{key};
                XsdBase::removeNS2(\v);
                rh{key} = args{key}.element.deserialize(types, mrh, v);
            }
        }

        if (val)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("additional keys %y included in %y message hash", val.keys(), name);

        #printf("DBG WSMessage::deserializeDocument() args: %y val: %y\nRH: %y\n", args.keys(), val, rh);
        return rh;
    }
}

# private helper class for lazy name resolution
class WSDL::XsdLateResolverHelper {
    private { list l = (); }

    constructor() {
    }

    add(any v) {
        l += v;
    }

    list getList() {
        return l;
    }
}

#! class for WSDL bindings
public class WSDL::Binding inherits WSDL::XsdNamedData {
    public {
        bool docStyle = False;
    }

    constructor(hash data, Namespaces nsc, hash opmap, reference idocmap, *hash messages) : XsdNamedData(\data) {
        # get binding attributes
        #*hash ba = data."^attributes^";

        if (exists data.binding) {
            *hash bba = data.binding."^attributes^";
            if (exists bba.transport && !SOAP_TRANSPORT.(bba.transport))
                throw WSDL_ERROR, sprintf("unsupported transport %y in binding %y (known transports: %y)", bba.transport, name, SOAP_TRANSPORT.keys());
            if (bba.style == "document")
                docStyle = True;
        }

        foreach hash ophash in (data.operation) {
            string opname = ophash."^attributes^".name;

            *WSOperation op = opmap{opname};
            if (!exists op)
                throw WSDL_ERROR, sprintf("binding for %y references unknown operation %y", data.name, opname);

            WSDL::XsdBase::removeNS(\ophash);

            *string sa = ophash.operation."^attributes^".soapAction;
            if (exists sa) {
                #printf("GOT: %s sa: %y\n", opname, sa);
                op.soapAction = sa ? sa : opname + "Action";
            }

            if (docStyle || ophash.operation."^attributes^".style == "document") {
                op.setDocStyle(\idocmap);
            }

            my WSDL::WSMessage input = op.input;

            WSDL::XsdBase::removeNS(\ophash.input);
            if (exists ophash.input.body) {
                if (ophash.input.body."^attributes^".use == "encoded") {
                    input.encoded = True;
                    #printf("DEBUG: setting encoding = True for %y.%y input\n", data.name, opname);
                }
            }
            else if (exists ophash.input.multipartRelated) {
                op.setInputMultipart(Mime::MPT_RELATED);
                WSDL::XsdBase::removeNS(\ophash.input.multipartRelated);

                if (!exists ophash.input.multipartRelated.part)
                    throw WSDL_ERROR, sprintf("missing part definition(s) in input message definition for operation %y: %y", opname, ophash);

                foreach any part in (ophash.input.multipartRelated.part) {
                    WSDL::XsdBase::removeNS(\part);
                    op.addInputPart(part);
                }
            }
            else
                throw WSDL_ERROR, sprintf("cannot parse input message definition for operation %y: %y", opname, ophash);

            # check for header
            foreach hash hh in (ophash.input.header) {
                *hash ma = hh."^attributes^";

                if (!ma.message)
                    throw WSDL_ERROR, sprintf("input binding %y for operation %y specifies a soap header element without a 'message' attribute (attr: %y)", name, opname, ma);

                if (!ma.part)
                    throw WSDL_ERROR, sprintf("input binding %y for operation %y specifies a soap header element without a 'part' attribute (attr: %y)", name, opname, ma);

                hash h = nsc.doType(ma.message);
                *WSMessage msg = messages.(h.val);
                if (!exists msg)
                    throw WSDL_ERROR, sprintf("input binding %y for operation %y references unknown message %y in the soap header element", name, opname, msg);

                #printf("header msg: %y part: %y use: %y\n", ma.message, ma.part, ma.use);
                #printf("op.input: %Y\n", input);

                op.setInputHeader(ma.part, msg, ma.use == "encoded");
            }

            WSDL::XsdBase::removeNS(\ophash.output);
            if (exists ophash.output.body) {
                if (ophash.output.body."^attributes^".use == "encoded") {
                    op.output.encoded = True;
                    #printf("DEBUG: setting encoding = True for %y.%y output\n", data.name, opname);
                }
            }
            else if (exists ophash.output.multipartRelated) {
                op.setOutputMultipart(Mime::MPT_RELATED);
                WSDL::XsdBase::removeNS(\ophash.output.multipartRelated);

                if (!exists ophash.output.multipartRelated.part)
                    throw WSDL_ERROR, sprintf("missing part definition(s) in output message definition for operation %y: %y", opname, ophash);

                foreach any part in (ophash.output.multipartRelated.part) {
                    WSDL::XsdBase::removeNS(\part);
                    op.addOutputPart(part);
                }
            }
            else
                throw WSDL_ERROR, sprintf("cannot parse output message definition for operation %y: %y", opname, ophash);
        }

        #binding = data;
    }
}

#! namespace container class
public class WSDL::Namespaces {
    public {
    }

    private {
        #! maps output namespace prefixes to namespace URIs
        hash ns = (
            "xsd": XSD_NS,
            );

        #! maps namespace URIs to output namespace prefixes
        hash nsr = (
            XSD_NS: "xsd",
            );

        #! hash for valid XSD namespaces, maps input namespace prefixes -> True if it refers to an XSD schema
        hash xml_schema;

        #! hash mapping input namespace prefixes to namespaces URIs
        hash imap = (
            "xsd": XSD_NS,
            );

        #! hash mapping input namespace URIs to input namespace prefixes
        hash imapr = (
            XSD_NS: "xsd",
            );

        #! integer providing a sequence for output namespace prefixes
        int nsn;

        #! if True then has SOAP 1.1
        bool hassoap11 = False;

        #! if True then has SOAP 1.2
        bool hassoap12 = False;

        #! current target namespace
        *string target_ns;

        #! target namespace stack;
        list nss = ();
    }

    #! creates the object with the WSDL definitions attribute hash
    constructor(hash nsh, *Namespaces nsc) {
        nsn = nsc ? nsc.nsn : 1;

        if (nsh.targetNamespace)
            target_ns = nsh.targetNamespace;

        #printf("*** DEBUG: Namespaces::constructor() %y\n", nsh);
        foreach string k in (nsh.keyIterator()) {
            *string ns = (k =~ x/xmlns:(\w+)/)[0];

            if (!ns)
                continue;
            imap{ns} = nsh{k};
            imapr{nsh{k}} = ns;

            if (nsh{k} == XSD_NS)
                xml_schema{ns} = True;

            if (nsh{k} == SOAP_11_NS)
                hassoap11 = True;

            if (nsh{k} == SOAP_12_NS)
                hassoap12 = True;
        }
        # "default" has to be quoted because it's a reserved word
        if (nsh.xmlns)
            ns."default" = nsh.xmlns;
        #ns.target = nsh.targetNamespace;
        #printf("*** DEBUG: Namespaces::constructor() imap: %y\n", imap);
    }

    #! merges namespaces when parsing imported schemas
    merge(Namespaces nsc) {
        nsn = nsc.nsn;
        foreach string k in (nsc.ns.keyIterator()) {
            string v = nsc.ns{k};

            if (ns{k}) {
                if (ns{k} == v)
                    continue;
                throw "WSDL-NAMESPACE-ERROR", sprintf("imported schema uses prefix %y to refer to %y, however this prefix was previously defined with %y", k, v, ns{k});
            }
            if (!nsr{v}) {
                ns{k} = v;
                nsr{v} = k;
            }
        }
        # merge input namespace mappings
        foreach string k in (nsc.imap.keyIterator()) {
            string v = nsc.imap{k};
            if (imap{k}) {
                if (imap{k} == v)
                    continue;
                throw "WSDL-NAMESPACE-ERROR", sprintf("imported schema uses prefix %y to refer to %y, however this prefix was previously defined with %y", k, v, imap{k});
            }
            imap{k} = v;
        }
    }

    #! returns the namespace URI for the given output namespace prefix
    string getOutputNamespaceUri(string nsp) {
        *string n_ns = ns{nsp};
        if (!n_ns)
            throw "WSDL-NAMESPACE-ERROR", sprintf("output namespace prefix %y is unknown (known output namespace prefixes: %y)", nsp, ns.keys());
        return n_ns;
    }

    #! returns a hash of namespace attributes for outgoing SOAP messages
    *hash getOutputNamespaceHash(*hash nsh) {
        hash h;
        map h.("xmlns:" + $1.key) = $1.value, ns.pairIterator();

        foreach string k in (nsh.keyIterator()) {
            string xs = "xmlns:" + k;
            if (h{xs}) {
                if (h{xs} != nsh{k})
                    throw "WSDL-NAMESPACE-ERROR", sprintf("namespace %y has already been added automatically as %y and therefore cannot be overridden as %y", k, h{xs}, nsh{k});
            }
            else
                h{xs} = nsh{k};
        }

        return h;
    }

    #! returns the primary target namespace Uri
    *string getTargetNamespaceUri() {
        return target_ns;
    }

    #! pushes the previous target namespace URI on the stack when parsing schemas and sets the current target namespace URI to the current value
    pushTargetNamespace(string ns) {
        nss += target_ns;
        target_ns = ns;
    }

    #! restores any previous target namespace URI from the stack to the current target namespace URI
    popTargetNamespace() {
        target_ns = pop nss;
    }

    #! looks up and registers a namespace if necessary, returns the namespace's prefix
    string getOutputNamespacePrefix(string ns) {
        *string nsa = nsr{ns};
        if (nsa)
            return nsa;
        return registerNamespaceIntern(ns);
    }

    #! looks up and registers a namespace if necessary, returns the namespace's prefix
    string getTargetNamespaceInputPrefix() {
        if (!target_ns)
            throw "NAMESPACE-ERROR", sprintf("no target namespace");
        return imapr{target_ns};
    }

    #! registers a namespace internally
    private string registerNamespaceIntern(string n_ns) {
        # create namespace prefix
        string nsa = sprintf("ns%d", nsn++);
        # register namespace in forward and reverse maps
        ns{nsa} = n_ns;
        nsr{n_ns} = nsa;

        return nsa;
    }

    #! returns a hash of namespace prefixes to namespaces URIs actually used
    *hash getReferencedNamespaceMap() {
        return ns;
    }

    #! returns True if using SOAP 1.1, False if not
    bool hasSoap11() {
        return hassoap11;
    }

    #! returns True if using SOAP 1.2, False if not
    bool hasSoap12() {
        return hassoap12;
    }

    #! returns True if if the input namespace prefix refers to the XSD namespace URI
    *bool isSchema(string ns) {
        return xml_schema{ns};
    }

    #! returns the input namespace URI from the input namespace prefix
    string getInputNamespaceUri(string nsa) {
        *string rv = imap{nsa};
        if (!rv)
            throw "WSDL-NAMESPACE-ERROR", sprintf("input namespace %y is unknown (known input namespaces: %y)", nsa, imap.keys());
        return rv;
    }

    any doType(string t) {
        #printf("DEBUG: XsdBase::doType(%y)\n", t);
        (*string ns, *string type) = t =~ x/(\w+):(\w+)/;
        if (!type)
            return ("val": t);

        # if this is in the XML Schema namespace, then it's a base type
        if (xml_schema{ns})
            return new XsdBaseType(type, self, getTargetNamespaceInputPrefix());

        return ("ns": getOutputNamespacePrefix(getInputNamespaceUri(ns)), "val": type);
    }

    #! returns the output namespace prefix for the given input namespace prefix
    string translateOutputNamespacePrefix(*string nsa) {
        return getOutputNamespacePrefix(getInputNamespaceUri(nsa));
    }
}

#! main class representing a parsed WSDL file
/** This is the main class for handling SOAP communication and is based on a WSDL file
*/
public class WSDL::WebService inherits WSDL::XsdBase {
    public {
        #! the WSDL string
        string wsdl;

        #! namespace container
        Namespaces nsc;

        hash base_type;
        hash services;
        list wsdl_services = ();
        hash idocmap;
        hash opmap;
        hash binding;
        hash elementmap;
        hash messages;
        hash types;
        bool usedocns = False;
        hash portType;
        *code try_import;
        #! default path for retrieving XSD references
        *string def_path;
    }

    #! creates the WebService object
    /** @param str the XML string representing the WSDL
        @param opts an optional hash of options with the following possible keys:
        - \c "def_path": the default path to use when retrieving referenced XSDs
        - \c "try_import": a call reference or closure to be passed a string name for XSD imports without any scheme to retrieve the data, must take a string argument (the resource name) and return a string (the resource data)
        - \c "http_client": a HTTPClient object for retrieving data from import commands
        - \c "http_headers": a hash of optional HTTP header info to use when retrieving data from import commands
    */
    constructor(string str, *hash opts) {
        hash h = parseXMLAsData(str);

        # save WSDL text
        wsdl = str;

        try_import = opts.try_import;
        def_path = opts.def_path;

        # remove namespace (normally "wsdl:") prefix from keys if present
        WSDL::XsdBase::removeNS(\h);
        WSDL::XsdBase::removeNS(\h.definitions);
        nsc = new Namespaces(h.definitions."^attributes^");
        #getNSPrefixes(h.definitions."^attributes^");
        #printf("%Y\n", h.definitions.types);

        if (exists h.definitions.types)
            parseTypes(h.definitions.types, opts.http_client instanceof HTTPClient ? opts.http_client : NOTHING, opts.http_headers);

        if (exists h.definitions.message)
            parseMessages(h.definitions.message);

        if (exists h.definitions.portType)
            parsePortType(h.definitions.portType);

        if (exists h.definitions.binding)
            parseBinding(h.definitions.binding);

        if (exists h.definitions.service)
            parseService(h.definitions.service);
    }

    #! returns the given operation or throws an exception if it cannot be found; operations are searched in portTypes in the order they are declared
    WSOperation getOperation(string opname) {
        foreach hash pt in (portType.iterator()) {
            if (pt.operations{opname})
                return pt.operations{opname};
        }
        list l = ();
        map l += $1.operations.keys(), portType.iterator();
        throw "WSDL-OPERATION-ERROR", sprintf("cannot retrieve operation %y; known operations: %y", opname, l);
    }

    #! returns the given operation or throws an exception if it cannot be found; operations are searched in portTypes in the order they are declared
    WSOperation getOperation(string port, string opname) {
        *WSOperation op = portType{port}.opname;
        if (op)
            return op;
        if (!portType{port})
            throw "WSDL-OPERATION-ERROR", sprintf("port %y is not a defined port; known ports: %y", port, portType.keys());
        throw "WSDL-OPERATION-ERROR", sprintf("operation %y is not known in port %y; known operations: %y", opname, port, portType{port}.operations.keys());
    }

    hash getType(string name, any v) {
        #printf("DBG getType() %y: %Y\n", name, types{name});
        if (!types{name})
            throw "WSDL-TYPE-ERROR", sprintf("cannot find requested type %y (known types: %y)", name, keys types);
        return ("^type^": types{name}, "^val^": v);
    }

    #! returns a map of top-level element names to WSOperation objects
    /** @return a map of top-level element names to WSOperation objects
    */
    *hash getOperationMap(any name) {
        if (!exists name) {
            if (elements wsdl_services > 2)
                throw "WSDL-GET-INPUT-OPERATION-MAP-ERROR", sprintf("no service argument passed to WSDL::getOperationMap() but the WSDL defines more than one service (%y)", keys (services - "port"));
            #name = wsdl_services[0];
        }
        else if (!inlist(name, (services - "port")))
            throw "WSDL-GET-INPUT-OPERATION-MAP-ERROR", sprintf("service argument %y passed to WSDL::getOperationMap() is not defined by this WSDL (vaild services: %y)", name, keys (services - "port"));

        return idocmap;
    }

    private XsdBaseType getBaseType(string t) {
        if (exists base_type{t})
            return base_type{t};

        return base_type{t} = new XsdBaseType(t, nsc);
    }

    private resolveType(XsdElement xe) {
        if (xe.ref) {
            # find element
            my (*string ns, string name) = (xe.ref =~ x/^(?:(\w+):)(\w+)$/);
            *XsdElement e = elementmap{name};
            if (!e)
                throw WSDL_ERROR, sprintf("cannot resolve element reference %y; known elements: %y", name, elementmap.keys());
            xe.assimilate(e);
            #throw "OOPS", sprintf("e: %y", xe);
        }
        else
            xe.type = resolveType(xe.type);
    }

    private resolveType(XsdTypedData xd) {
        xd.type = resolveType(xd.type);
    }

    private XsdAbstractType resolveType(hash v) {
        if (v.ns && nsc.isSchema(v.ns))
            return getBaseType(v.val);

        # find type
        if (!types.(v.val)) {
            string tn = v.val;
            if (v.ns)
                tn = v.ns + ":" + v.val;
            throw WSDL_ERROR, sprintf("cannot resolve type %y; known types: %y", tn, types.keys());
        }

        return types.(v.val);
    }

    # parse XSD schema types
    private parseTypes(*hash data, any http_client, any http_headers) {
        WSDL::XsdBase::removeNS(\data);

        *hash sa = data.schema."^attributes^";
        if (sa.elementFormDefault == "qualified")
            usedocns = True;
        if (sa.targetNamespace)
            nsc.pushTargetNamespace(sa.targetNamespace);
        on_exit if (sa.targetNamespace)
            nsc.popTargetNamespace();

        XsdLateResolverHelper unresolved();

        foreach *hash schema in (data.schema) {
            #printf("DEBUG: schema tn: %y\n", schema."^attributes^"."targetNamespace");
            WSDL::XsdBase::removeNS(\schema);
            #printf("DEBUG: WebService::parseTypes() schema: %Y\n", schema);

            # process XSD import if present
            foreach hash import in (schema.import) {
                *hash a = import."^attributes^";
                # import file
                if (a.schemaLocation) {
                    hash h = parse_url(a.schemaLocation);
                    string xsd;
                    if (!h.protocol && try_import)
                        xsd = call_function(try_import, a.schemaLocation);
                    else
                        xsd = WSDLLib::getFileFromURL(a.schemaLocation, "file", http_client, http_headers, NOTHING, def_path);

                    # parse XML to Qore data structure ignoring XML element order
                    hash xh = parseXMLAsData(xsd);

                    # parse namespace definitions in schema attributes
                    if (xh.size() != 1)
                        throw WSDL_ERROR, sprintf("expecing a single element indicating an XSD schema in the imported file; got instead: %y", xh.keys());

                    # get schema member name
                    any sk = xh.firstKey();

                    #printf("*** DEBUG %y: sk: %y a: %y\n", a.schemaLocation, sk, xh{sk}."^attributes^");

                    # use temporary Namespaces object for import
                    Namespaces n_nsc = nsc;
                    nsc = new Namespaces(xh{sk}."^attributes^", nsc);
                    on_exit
                        nsc = n_nsc;
                    on_success
                        n_nsc.merge(nsc);

                    # verify that the top-level key indicates an XSD schema definition
                    (*string ns, *string mem) = (sk =~ x/^(\w+):(\w+)$/);
                    if (ns && !nsc.isSchema(ns))
                        throw WSDL_ERROR, sprintf("expecing imported schema definition to be in XSD namespace %y, got %y: %y instead", XSD_NS, ns, nsc.getInputNamespaceUri(ns));

                    parseTypes(xh);
                }
            }

            foreach hash st in (schema.simpleType) {
                XsdSimpleType t(st, nsc, unresolved);
                types.(t.name) = t;
                #printf("DEBUG: st: %y\n", t.name);
            }

            foreach hash ct in (schema.complexType) {
                XsdComplexType t(ct, nsc, unresolved);
                types.(t.name) = t;
                #printf("DEBUG: ct: %y\n", t.name);
            }

            # make element map
            foreach any el in (schema.element) {
                any attr = el."^attributes^";
                if (exists attr.type) {
                    any t = nsc.doType(attr.type);
                    if (!(t instanceof XsdData)) {
                        t = t.val;
                        if (!exists types{t})
                            throw WSDL_ERROR, sprintf("cannot resolve element %y type %y", el, t);
                        #printf("DEBUG: adding element %y type %y\n", attr.name, t);
                        elementmap.(attr.name) = new WSDL::XsdElement(("^attributes^":("name":attr.name)), nsc, types{t}, unresolved);
                    }
                    else {
                        #printf("DEBUG: adding element %y type %y\n", attr.name, t);
                        elementmap.(attr.name) = new WSDL::XsdElement(("^attributes^":("name":attr.name)), nsc, t, unresolved);
                    }
                }
                else {
                    #printf("DEBUG: adding element %y\n", attr.name);
                    elementmap.(attr.name) = new WSDL::XsdElement(el, nsc, NOTHING, unresolved);
                }
            }
        }

        # resolve types
        map resolveType($1), unresolved.getList();
        #foreach XsdTypedData e in (unresolved.getList())
        #    e.type = resolveType(e.type);

        foreach string t in (types.keyIterator()) {
            if (types{t} instanceof XsdComplexType) {
                #foreach any e in (keys types{t}."elements")
                #    if (!(types{t}."elements"{e}.type instanceof XsdData))
                #           types{t}."elements"{e}.type = resolveType(types{t}."elements"{e}.type);

                # process restriction info
                if (types{t}.restriction) {
                    any et = types{t}.restriction;
                    if (!exists types{et})
                        throw WSDL_ERROR, sprintf("complexType %s should be restricted from base type %y, but type %y is not defined", t, et, et);
                    # combine base type and new type
                    types{t}.elements = types{et}.elements + types{t}.elements;
                    #printf("DEBUG: extended %s with %s (%y)\n", t, et, keys types{t}.elements);
                }

                # process extension info
                if (types{t}.extension) {
                    any et = types{t}.extension;
                    if (!exists types{et})
                        throw WSDL_ERROR, sprintf("complexType %s should be extended by %y, but type %y is not defined", t, et, et);
                    # combine base type and new type
                    types{t}.elements = types{et}.elements + types{t}.elements;
                    #printf("DEBUG: extended %s with %s (%y)\n", t, et, keys types{t}.elements);
                }

                # process array info
                if (types{t}.array) {
                    any et = types{t}.array.val;
                    types{t}.array = new XsdArrayType(types{et} ? types{et} : et, nsc);
                }
            }
        }

        # resolve types
        map resolveType($1), unresolved.getList(), !($1.type instanceof XsdData);
        /*
        foreach any e in (unresolved.getList())
            if (!(e.type instanceof XsdData))
                e.type = resolveType(e.type);
        */
    }

    private parseMessages(*softlist message) {
        # parse messages
        foreach hash m in (message) {
            WSMessage msg(m, elementmap, nsc);
            foreach string arg in (msg.args.keyIterator()) {
                #printf("DEBUG: WebService::parseMessages(): %y: %y\n", arg, msg);
                #printf("DEBUG: WebService::parseMessages(): %y: %y\n", arg, msg.args{arg}.type);
                if (exists msg.args{arg}.type && !(msg.args{arg}.type instanceof XsdData))
                    msg.args{arg}.type = resolveType(msg.args{arg}.type);
            }
            messages.(msg.name) = msg;
        }
    }

    private parseService(any svc) {
        WSDL::XsdBase::removeNS(\svc);
        services.name = svc."^attributes^".name;
        foreach any port in (svc.port) {
            WSDL::XsdBase::removeNS(\port);
            string name = port."^attributes^".name;
            services.port{name} = port."^attributes^";
            services.port{name} += (
                "address": port.address."^attributes^".location,
                "binding": nsc.doType(services.port{name}.binding),
                );
        }
    }

    private parsePortType(any data) {
        # setup list of services defined in this WSDL
        foreach any port in (data) {
            WSDL::XsdBase::removeNS(\port);
            #printf("DEBUG: portType: %Y\n", port);
            string name = port."^attributes^".name;
            wsdl_services += name;
            foreach any p in (port.operation) {
                WSOperation op(p, types, nsc, messages, usedocns);
                portType{name}.operations.(op.name) = op;
                #printf("DEBUG: %y registered operation %y\n", name, op.name);
                opmap.(op.name) = op;
            }
        }
    }

    private parseBinding(any bindings) {
        foreach hash data in (bindings) {
            my WSDL::Binding b(data, nsc, opmap, \idocmap, messages);

            binding.(b.getName()) = b;
        }
    }

    #! returns True if the WSDL describes a SOAP 1.2 service
    /** @return True if the WSDL describes a SOAP 1.2 service
    */
    bool isSoap12() {
        return nsc.hasSoap12();
    }

    #! returns the XML string for the WSDL
    /** @return the XML string for the WSDL
    */
    string getWSDL() {
        return wsdl;
    }
}
