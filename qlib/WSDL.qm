# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file WSDL.qm WSDL: Web Services Description Language: http://www.w3.org/TR/wsdl, SOAP 1.1: https://www.w3.org/TR/2000/NOTE-SOAP-20000508/, SOAP 1.2: https://www.w3.org/TR/soap12-part1/

/*  WSDL.qm Copyright (C) 2012 - 2016 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# make sure we have the required qore version
%requires qore >= 0.8.12

# requires XML functionality
%requires xml

# need mime definitions
%requires Mime >= 1.3.4.1

# do not use $ for vars
%new-style

%disable-warning unreferenced-variable

module WSDL {
    version = "0.3.6";
    desc = "WSDL module providing functionality for SOAP";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

/*
    WSDL classes
    provides some minimal WSDL and XSD support for SOAP messaging used by the SoapClient class and the SoapHandler

    not complete, needs namespace verification, improved XSD support, element groups, etc
*/

/** @mainpage WSDL Module

    @tableofcontents

    @section wsdlintro Introduction to the WSDL Module

    The %WSDL module provides functionality for <a href="http://en.wikipedia.org/wiki/SOAP">SOAP</a> 1.1 and 1.2.

    The main purpose of this module is to provide the infrastructure for developing SOAP client and server services.

    The main components of this module are as follows:
    - @ref WSDL::WebService "WebService": represents a WSDL file; an easy way to get an object of this type from a URL is by calling WSDL::WSDLLib::getWSDL()
    - @ref WSDL::WSDLLib "WSDLLib": a class of static functions providing helper functions for the module
    - @ref WSDL::WSOperation "WSOperation": a class representing a single operation from a web service
    - @ref WSDL::WSMessageHelper "WSMessageHelper": a class to create sample message used by operation

    See the following for modules using the %WSDL module:
    - <a href="../../SoapClient/html/index.html">SoapClient user module</a>
    - <a href="../../SoapHandler/html/index.html">SoapHandler user module</a>

    @section wsdlrelnotes WSDL Module Release Notes

    @subsection wsdl_0_3_6 WSDL v0.3.6
    - reimplmented operation to support multi binding, operation can be assigned to more bindings
    - support for HTTP binding and content-types, "^content-type^" attribute can identify content type to be used
    - extended SOAP binding serialization and deserialization with support to both body and header

    @subsection wsdl_0_3_5_1 WSDL v0.3.5.1
    - supress emitting a SOAPAction header in requests if the binding gives an empty string (<a href="https://github.com/qorelanguage/qore/issues/1226">issue 1226</a>)
    - updated @ref WSDL::WSOperation::serializeRequest() to allow the SOAPAction header to be overridden in each request (<a href="https://github.com/qorelanguage/qore/issues/1226">issue 1226</a>)
    - respect XML generation flags in request generation
    - fixed parsing empty base64Binary and hexBinary elements (<a href="https://github.com/qorelanguage/qore/issues/1227">issue 1227</a>)

    @subsection wsdl_0_3_5 WSDL v0.3.5
    - fixed many message serialization and deserialization issues
    - added @ref WSDL::WebService::getOperation()
    - allow for environment variable substitution in WSDLLib::getWSDL() when retrieving files
    - fixed charset=... header value
    - added @ref WSDL::WSMessageHelper
    - added @ref WSDL::WebService::getReport()

    @subsection wsdl_0_3_4 WSDL v0.3.4
    - updated to a user module

    @subsection wsdl_0_3_3 WSDL v0.3.3
    - added initial support for the anyAttribute element of complexType
    - added initial support for SOAP header processing
    - added initial support for multiple portType and bindings in a WSDL

    @subsection wsdl_0_3_2 WSDL v0.3.2
    - fixed bugs de/serializing negative values for "int" and "short"

    @subsection wsdl_0_3_1 WSDL v0.3.1
    - improved XSD imports and namespace handling

    @subsection wsdl_0_3_0 WSDL v0.3.0
    - implemented WSDLLib class of helper functions
    - implemented support for xsd import statements in WSDLs

    @subsection wsdl_0_2_0 WSDL v0.2.0
    - use parseXMLAsData() instead of parseXML()
    - implemented initial simpleType support
    - fixed xsd:date serialization and deserialization
*/

#! main WSDL namespace
public namespace WSDL {
    #! this WSDL implementation version
    public const version     = "0.3.6";

    #! SOAP 1.1 envelope URI
    public const SOAP_11_ENV  = "http://schemas.xmlsoap.org/soap/envelope/";
    #! SOAP 1.2 envelope URI
    public const SOAP_12_ENV  = "http://www.w3.org/2003/05/soap-envelope";

    #! SOAP 1.1 namespace URI
    public const SOAP_11_NS   = "http://schemas.xmlsoap.org/wsdl/soap/";

    #! SOAP 1.2 namespace URI
    public const SOAP_12_NS   = "http://schemas.xmlsoap.org/wsdl/soap12/";

    #! XSD namespace URI
    public const XSD_NS       = "http://www.w3.org/2001/XMLSchema";
    #! XSI namespace URI
    public const XSI_NS       = "http://www.w3.org/2001/XMLSchema-instance";

    #! HTTP namespace URI
    public const HTTP_NS      = "http://schemas.xmlsoap.org/wsdl/http/";
    #! MIME namespace URI
    public const MIME_NS      = "http://schemas.xmlsoap.org/wsdl/mime/";

    #! soap 1.1 envelope namespaces
    public const ENVELOPE_11_NS = (
        "soapenv:Envelope": (
            "^attributes^": (
                "xmlns:soapenv": SOAP_11_ENV,
                "xmlns:xsd": XSD_NS,
                "xmlns:xsi": XSI_NS,
            ),
        ),
    );

    #! soap 1.2 envelope namespaces
    public const ENVELOPE_12_NS = (
        "soapenv:Envelope": (
            "^attributes^": (
                "xmlns:soapenv": SOAP_12_ENV,
              "xmlns:xsd": XSD_NS,
              "xmlns:xsi": XSI_NS,
            ),
        ),
    );

    #! soap encoding URI
    public const SOAP_ENCODING = "http://schemas.xmlsoap.org/soap/encoding/";

    #! mapping from Qore types to xsd types for xsd type "anyType"
    public const any_type_map = (
        Type::String      : "string",
        Type::Int         : "long",
        Type::Boolean     : "boolean",
        Type::Date        : "dateTime",
        Type::Float       : "decimal",
        Type::NothingType : "string",
        Type::NullType    : "string",
        Type::Binary      : "base64Binary",
    );

    # error codes
    const SOAP_SERIALIZATION_ERROR = "SOAP-SERIALIZATION-ERROR";
    const SOAP_DESERIALIZATION_ERROR = "SOAP-DESERIALIZATION-ERROR";
    const WSDL_ERROR = "WSDL-ERROR";

    #! SOAP HTTP transport URI
    const SOAP_TRANSPORT_HTTP = "http://schemas.xmlsoap.org/soap/http";

    #! known/supported transports
    public const SOAP_TRANSPORT = (
        SOAP_TRANSPORT_HTTP: True,
        );

    #! range of "short" values (16 bits)
    public const RANGE_SHORT = (-32768, 32767);

    #! range of "int" values (32 bits)
    public const RANGE_INT = (-2147483648, 2147483647);
}

#! contains helper methods for retrieving WSDLs from a URL
public class WSDL::WSDLLib {
    #! Mime types recognized as SOAP messages
    const SoapMimeTypes = (MimeTypeSoapXml, MimeTypeXml, MimeTypeXmlApp);

    static string getSoapMimeType12(bool soap12) {
        return soap12 ? MimeTypeSoapXml : MimeTypeXml;
    }

    #! retrieves a local file and returns the file's contents as a string
    /** called by WSDLLib::getFileFromURL() in case the scheme is "file"
    */
    static data getFile(string fn, bool as_string = True) {
        *data rv = as_string ? ReadOnlyFile::readTextFile(fn) : ReadOnlyFile::readBinaryFile(fn);
        if (!exists rv)
            throw "WSDL-LIB-ERROR", sprintf("file %y is empty or could not be read as a normal file", fn);
        return rv;
    }

    #! retrieves a file from a URL with HTTP and returns the file's contents as a string
    /** called by WSDLLib::getFileFromURL() in case the scheme is "http"
    */
    static string getHTTP(string url, *string path, *HTTPClient hc, *hash headers, bool as_string = True) {
        if (hc)
            hc.setURL(url);
        else
            hc = new HTTPClient(("url": url));
        string body = hc.get(path ? path : "/", headers);
        return as_string ? body : binary(body);
    }

    #! retrieves a file from a URL with the FTP protocol and returns the file's contents as binary or string data
    /** called by WSDLLib::getFileFromURL() in case the scheme is "ftp"
    */
    static data getFTP(string url, string path, bool as_string = True) {
        string file = basename(path);
        if (!file)
            throw "WSDL-LIB-ERROR", sprintf("missing file name in URL %y", url);

        FtpClient f(url);
        f.connect();

        string dir = dirname(path);
        if (dir)
            f.cwd(dir);

        return as_string ? f.getAsString(file) : f.getAsBinary(file);
    }

    #! retrieves a file from a URL
    /** in case the URL is actually a file path, environment variable substitution
        is performed on the path string
     */
    static data getFileFromURL(string url, string def_protocol = "file", *HTTPClient http_client, *hash http_headers, bool as_string = True, *string def_path, *reference new_def_path) {
        return WSDLLib::getFileFromURL(url, parse_url(url), def_protocol, http_client, http_headers, as_string, def_path, \new_def_path);
    }

    #! retrieves a file from an already-parsed URL
    /** in case the URL is actually a file path, environment variable substitution
        is performed on the path string
     */
    static data getFileFromURL(string url, hash u, string def_protocol = "file", *HTTPClient http_client, *hash http_headers, bool as_string = False, *string def_path, *reference new_def_path) {
        if (!exists u.protocol)
            u.protocol = def_protocol;

        switch (u.protocol) {
            case "file": {
                string path;
                if (u.host)
                    path = u.host;
                if (u.path) {
                    if (path)
                        path += DirSep;
                    path += u.path;
                }
                # do environment variable substitution
                map path = replace(path, "\$" + $1, ENV.$1), (path =~ x/\$(\w+)/g);

                if (def_path && !absolute_path(path))
                    path = def_path + DirSep + path;
                else
                    new_def_path = dirname(path);
                return WSDLLib::getFile(path, as_string);
            }

            case /^http(s)?$/:
                return WSDLLib::getHTTP(url, u.path, http_client, http_headers, as_string);

            case /^ftp(s)?$/:
                return WSDLLib::getFTP(url, u.path, as_string);

            default:
                throw "WSDL-LIB-ERROR", sprintf("do not know how to retrieve data with scheme %y given in URL %y", u.protocol, url);
        }
    }

    #! returns the argument
    static WebService getWSDL(WebService wsdl) {
        return wsdl;
    }

    #! returns a WSDL string form a file name, optional HTTPClient object and optional header hash
    /** in case the \a wsdl argument is actually a file path, environment variable substitution
        is performed on the path string
     */
    static string getWSDL(string wsdl, *HTTPClient http_client, *hash http_headers, *reference new_def_path) {
        if (wsdl =~ /^<\?xml/)
            return wsdl;
        return WSDLLib::getFileFromURL(wsdl, "file", http_client, http_headers, NOTHING, NOTHING, \new_def_path);
    }

    #! takes a hash representation of a SOAP message and handles multipart messages, checks the content-type, and handles hrefs in the message
    static hash parseMultiPartSOAPMessage(hash msg) {
        if (exists msg."_qore_multipart") {
            if (msg."_qore_multipart" != "related")
                throw "SOAP-MESSAGE-ERROR", sprintf("don't understand multipart/%s messages, expected multipart/related", msg."_qore_multipart");

            any bdry = msg."_qore_multipart_boundary";
            if (!strlen(bdry))
                throw "SOAP-MESSAGE-ERROR", sprintf("multipart message received without multipart boundary; headers: %y", msg - "body");

            hash mpmsg;
            list l = split("\r\n--" + bdry, msg.body);

            for (int i = 1; i < (elements l - 1); ++i) {
                string m = l[i];

                int ie = index(m, "\r\n\r\n");
                if (ie == -1) {
                    throw "SOAP-MESSAGE-ERROR", sprintf("part %d has no headers: %y", i, m);
                }
                hash hh;
                foreach string hl in (split("\r\n", substr(m, 2, ie))) {
                    trim hl;
                    (string hi, any ignore, string ha) = hl =~ x/^(.*):([ \t])*(.*)$/;
                    hi = tolower(hi);
                    #printf("hl: %y hi: %y ha: %y\n", hl, hi, ha);exit();
                    hh{hi} = ha;
                }
                if (!exists hh."content-id")
                    throw "SOAP-MESSAGE-ERROR", sprintf("expecting part header Content-ID in part %d; headers: %y", i, hh);

                any b;
                if (hh."content-transfer-encoding" == "binary") {
                    # unfortunately we have to do some tricks to get the binary data out here
                    # FIXME: tricks probably not necessary with qore 0.8.1+
                    m = force_encoding(m, "ascii");
                    # recalculate byte offset
                    ie = index(m, "\r\n\r\n");
                    #printf("ie: %d m: %d\n", ie, strlen(m));exit();
                    b = binary(substr(m, ie + 4));

                    #File f(); f.open2("t.bin", O_CREAT|O_WRONLY|O_TRUNC); f.write(b); exit();
                }
                else {
                    b = substr(m, ie + 4);

                    if (hh."content-type" =~ /charset=/) {
                        string c = (hh."content-type" =~ x/charset=([^;]+)/)[0];
                        b = force_encoding(b, c);
                    }
                }

                if (hh."content-id" !~ /^\<.*\>$/)
                    throw "SOAP-MESSAGE-ERROR", sprintf("expected part ID to have the following format: <id>, instead got %s", hh."content-id");

                hash p = (
                    "hdr": hh,
                    "body": b,
                    );

                if ((!exists msg."_qore_multipart_start" && i == 1)
                    || (exists msg."_qore_multipart_start" && msg."_qore_multipart_start" == hh."content-id")) {
                    mpmsg.body = p;
                }
                else {
                    string id = substr(hh."content-id", 1, -1);
                    mpmsg.part{id} = p;
                }
            }
            return {
                'content-type': mpmsg.body.hdr."content-type",
                'header': msg.header + mpmsg.body.hdr,
                'body': mpmsg.body.body,
                'parts': mpmsg.part,
            };
        } else {
            return {
                'content-type': msg."_qore_orig_content_type",
                'header': msg.header,
                'body': msg.body,
            };
        }
    }

    #! returns True is the message has a SOAP mime type
    static bool isSOAPMessage(hash msg) {
        return WSDLLib::isContentType(msg."content-type", SoapMimeTypes);
    }

    /**!
    takes a hash representation returned by parseMultiPartSOAPMessage and parses it to a Qore data structure, checks the content-type, and handles hrefs in the message.
    Operation is not yet known if SoapAction header is not presented
    */
    static *hash parseSOAPMessage(hash msg) {

        if (!msg.body) {
            hash h."content-type" = msg."content-type" ?? "text/plain";
            h.body = NOTHING;
            return h;
        } else if (WSDLLib::isSOAPMessage(msg)) {
            hash xmldata;
            if (msg.body) {
                xmldata = parse_xml(msg.body);
            }
            if (msg.parts) {
                # parse entire data structure to find "href"s or href attributes
                WSDLLib::substHref(\xmldata, msg.parts);
            }
            return xmldata;
        } else {
            string ct = msg."content-type";
            hash h."content-type" = (ct =~ x/^([^;]+)/)[0];
            if (ct =~ /charset=/) {
                string c = (ct =~ x/charset=([^;]+)/)[0];
                h.body = force_encoding(msg.body, c);
            } else {
                h.body = binary(msg.body);  # needed or is it already ?
            }
            return h;
        }
    }

    /*private in module*/ static bool isContentType(string ct, list MimeTypes) {
        ct = ltrim(ct);
        foreach string sct in (MimeTypes) {
            # Content-Type := type "/" subtype *[";" parameter] ... so we can test if string is starting at index 0
            if (bindex(ct, sct) == 0)
                return True;
        }
        return False;
    }


    /*private in module*/ static checkContentType(string ct, list MimeTypes) {
        if (!WSDLLib::isContentType(ct, MimeTypes)) {
            throw "SOAP-MESSAGE-ERROR", sprintf("don't know how to handle content-type %y (expecting one of: %y)", ct, MimeTypes);
        }
    }

    private static processHref(reference xmldata, string hr, hash parts) {
        if (hr !~ /^cid:/)
            throw "SOAP-MESSAGE-ERROR", sprintf("messages references non-local part %y; cannot handle non-local parts", hr);
        hr = substr(hr, 4);
        if (!exists parts{hr})
            throw "SOAP-MESSAGE-ERROR", sprintf("message references non-existent part %y", hr);
        xmldata = parts{hr}.body;
    }

    private static substHref(reference xmldata, hash parts) {
        foreach string k in (keys xmldata) {
            if (exists xmldata{k}."^attributes^".href)
                WSDLLib::processHref(\xmldata{k}, xmldata{k}."^attributes^".href, parts);
            else if (exists xmldata{k}.href)
                WSDLLib::processHref(\xmldata{k}, xmldata{k}.href, parts);
            else if (xmldata{k}.typeCode() == NT_LIST) {
                foreach any e in (\xmldata{k})
                    WSDLLib::substHref(\e, parts);
            }
            else if (xmldata{k}.typeCode() == NT_HASH)
                WSDLLib::substHref(\xmldata{k}, parts);
        }
    }
}

#! base class with helper methods for XSD data processing
public class WSDL::XsdBase {
    /*
    static private hash doType(string t) {
        #printf("DEBUG: XsdBase::doType(%y)\n", t);
        (*string ns, *string type) = t =~ x/(\w+):(\w+)/;
        return !exists type ? ("val": t) : ("ns": ns, "val": type);
    }
    */

    static removeNS(reference v) {
        foreach hash h in (\v) {
            foreach string k in (h.keyIterator()) {
                (*string ns, *string name) = k =~ x/(\w+):(\w+)/;
                if (ns) {
                    if (h{k}.typeCode() == NT_HASH)
                        h{k}.ns = ns;
                    if (h{name}) {
                        softlist l = h{name};
                        l += remove h{k};
                        h{name} = l;
                    }
                    else
                        h{name} = remove h{k};
                }
            }
        }
    }

    static removeNS2(reference v) {
        foreach hash h in (\v) {
            foreach string k in (h.keyIterator()) {
                (*string ns, *string name) = k =~ x/(\w+):(\w+)/;
                if (ns) {
                    if (h{k}.typeCode() == NT_HASH)
                        h{k}.".ns" = ns;
                    if (h{name}) {
                        softlist l = h{name};
                        l += remove h{k};
                        h{name} = l;
                    }
                    else
                        h{name} = remove h{k};
                }
            }
        }
    }
}

#! base class for XSD data classes
public class WSDL::XsdData inherits WSDL::XsdBase {
    any getValue(*hash mrh, any val) {
        if (exists val."^attributes^".href) {
            string href = substr(val."^attributes^".href, 1);

            if (!exists mrh.mrh{href})
                throw "INVALID-REFERENCE", sprintf("multiRef id: %y does not exist", href);

            return mrh.mrh{href};
        }
        return val;
    }
}

#! base class for XSD classes with a "name" attribute
public class WSDL::XsdNamedData inherits WSDL::XsdData {
    public {
        # name of object
        string name;
        #! input namespace prefix (if any given)
        *string ns;
        #! descriptive name flag
        descriptive_name;
    }

    constructor(string n_name, string n_ns) {
        name = n_name;
        ns = n_ns;
        # if the name has a space in it, then it's a descriptive name
        descriptive_name = (name =~ / /);
    }

    constructor(reference e, *string desc_name) {
        WSDL::XsdBase::removeNS(\e);
        *hash a = e."^attributes^";
        if (a.name)
            name = a.name;
        else if (a.ref) {
            # remove namespace
            (*string ns, *string n_name) = a.ref =~ x/(\w+):(\w+)/;
            name = n_name ?? a.ref;
        }
        else
            name = desc_name ?? "<unnamed type>";
        # if the name has a space in it, then it's a descriptive name
        descriptive_name = (name =~ / /);
    }

    string getName() {
        return name;
    }

    *string getInputNamespacePrefix() {
        return ns;
    }

    bool hasRealName() {
        return !descriptive_name;
    }
}

public class WSDL::XsdAbstractType inherits WSDL::XsdNamedData {
    public {
        #! reference to namespaces
        Namespaces nsc;

        #! my namespace output prefix
        string ons;
    }

    constructor(reference e, Namespaces n_nsc, *string desc_name) : XsdNamedData(\e, desc_name) {
        nsc = n_nsc;
        resolveNamespace();
    }

    constructor(string name, string ns, Namespaces n_nsc) : XsdNamedData(name, ns) {
        nsc = n_nsc;
        resolveNamespace();
    }

    private resolveNamespace() {
        if (!ns) {
            *string tns = nsc.getTargetNamespaceUri();
            if (!tns)
                throw "WSDL-NAMESPACE-ERROR", sprintf("input namespace for %s %y was not given and there is no current target namespace", self.className(), name);
            ons = nsc.getOutputNamespacePrefix(tns);
        }
        else
            ons = nsc.translateOutputNamespacePrefix(ns);
        #printf("DEBUG: type %y ns: %y ons: %y\n", name, ns, ons);
    }

    checkExtends(XsdAbstractType t, string ename) {
        throw SOAP_SERIALIZATION_ERROR, sprintf("explicit type %y given for element %y, type %y, however the types are not compatible", name, ename, t.name);
    }

    string getNameWithNS() {
        return ons + ":" + name;
    }

    bool isNillable() {
        return False;
    }

    bool isRequired() {
        return True;
    }

    bool requiresValue() {
        return !isNillable() && isRequired();
    }

    string getOutputNamespacePrefix() {
        return ons;
    }

    abstract any serialize(any val, *softbool omitType);
    abstract any deserialize(string en, *TypeMap tmap, *hash mrh, any val);
}

#! class for XSD base types
public class WSDL::XsdBaseType inherits WSDL::XsdAbstractType {
    public {
    }

    constructor(string t, Namespaces nsc, string ns = "xsd") : XsdAbstractType(t, ns, nsc) {
    }

    any serialize(any val, *softbool omitType) {
        *hash comments;
        if (val.typeCode() == NT_HASH) {
            foreach string k in (val.keyIterator()) {
                if (k =~ /^\^comment/) {
                    comments{k} = val{k};
                }
            }
            val = val."^value^";
        }
        *string type;
        # set type according to Qore type if xsd type is anyType
        if (name == "anyType") {
            # we have to specify the type in this case
            omitType = False;
            type = any_type_map{val.type()};
            if (!type)
                throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize xsd type anyType from Qore type %y", val.type());
        }
        else {
            type = name;
        }
        switch (type) {
            case "byte": {
                int v = int(val);
                if ((v & 0xff) != v)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "short": {
                int v = int(val);
                if (v < RANGE_SHORT[0] || v > RANGE_SHORT[1])
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "int": {
                int v = int(val);
                if (v < RANGE_INT[0] || v > RANGE_INT[1])
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "unsignedByte": {
                int v = int(val);
                if ((v & 0xff) != v)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                if (v < 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", type, v);
                break;
            }

            case "unsignedShort": {
                int v = int(val);
                if (v < 0 || v > RANGE_SHORT[1])
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "unsignedInt": {
                int v = int(val);
                if (v < 0 || v > RANGE_INT[1])
                    throw SOAP_SERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", v, type);
                break;
            }

            case "unsignedLong": {
                int v = int(val);
                if (v < 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", type, v);
                break;
            }

            case "negativeInteger": {
                int v = int(val);
                if (v >= 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y only accepts negative values (value supplied: %d)", name, v);
                break;
            }

            case "nonNegativeInteger": {
                int v = int(val);
                if (v < 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y only accepts non-negative values (value supplied: %d)", name, v);
                break;
            }

            case "nonPositiveInteger": {
                int v = int(val);
                if (v > 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y only accepts non-positive values (value supplied: %d)", name, v);
                break;
            }

            case "positiveInteger": {
                int v = int(val);
                if (v <= 0)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("type %y only accepts positive values (value supplied: %d)", type, v);
                break;
            }

            case "date":
                val = format_date("YYYY-MM-DD", date(val));
                break;

            case "dateTime":
                val = format_date("YYYY-MM-DDTHH:mm:SS", date(val));
                break;

            case "boolean":
                val = val ? "true" : "false";
                break;

            case "time":
                val = format_date("hh:mm:ss.ms", date(val));
                break;

            case "base64Binary":
                val = make_base64_string(val);
                break;

            case "hexBinary":
                val = make_hex_string(val);
                break;

            case "binary":
                # used for HTTP binding only
                val = binary(val);
                break;
        }

        #printf("DEBUG: FORCE: type: %y, nstype: %y, val: %y\n", type, nstype, val);
        if (omitType)
            if (comments) {
                return comments + (
                    "^value^": val
                );
            } else
                return val;
        else
            return (
                comments +
                "^attributes^": (
                    "xsi:type": sprintf("%s:%s", ons, type),
                ),
                "^value^": val,
            );
    }

    any deserialize(string en, *TypeMap tmap, *hash mrh, any val) {
        string type;
        if (val.typeCode() == NT_HASH && val.hasKey("^value^")) {
            if (val."^attributes^"."xsi:type") {
                type = val."^attributes^"."xsi:type";
                string t = (type =~ x/\w+:(\w+)/)[0];
                if (exists t)
                    type = t;

                if (name != "anyType" && type != name)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("expecting base type %y, got %y", name, val."^attributes^"."xsi:type");
            }
            else
                type = name;
            val = val."^value^";
        }
        else
            type = name;

        switch (type) {
            case "string":
            case "anyURI":
                return string(val);

            case "integer": {
                # note that we do not convert xsd:integer to a qore integer if we would lose precision
                int v = int(val);
                return v == val ? v : val;
            }

            case "byte":
                val = int(val);
                if ((val & 0xff) != val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                return val;

            case "short":
                val = int(val);
                if (val < RANGE_SHORT[0] || val > RANGE_SHORT[1])
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                return val;

            case "int":
                val = int(val);
                if (val < RANGE_INT[0] || val > RANGE_INT[1])
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                return val;

            case "long":
                return int(val);

            case "unsignedByte":
                val = int(val);
                if ((val & 0xff) != val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                if (val < 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", name, val);
                return val;

            case "unsignedShort":
                val = int(val);
                if ((val & 0xffff) != val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                if (val < 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", name, val);
                return val;

            case "unsignedInt":
                val = int(val);
                if ((val & 0xffffffff) != val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("value %d is out of range for type %y", val, name);
                if (val < 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", name, val);
                return val;

            case "unsignedLong":
                if (val < 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y does not accept negative values (value supplied: %d)", name, val);
                return int(val);

            case "negativeInteger":
                if (val >= 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y only accepts negative values (value supplied: %d)", name, val);
                return int(val);

            case "nonNegativeInteger":
                if (val < 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y only accepts non-negative values (value supplied: %d)", name, val);
                return int(val);

            case "nonPositiveInteger":
                if (val > 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y only accepts non-positive values (value supplied: %d)", name, val);
                return int(val);

            case "positiveInteger":
                if (val <= 0)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("type %y only accepts positive values (value supplied: %d)", name, val);
                return int(val);

            case "date":
                # remove dashes from date
                val =~ s/-//g;
                return date(val);

            case "dateTime":
                return date(substr(val, 0, 4) + substr(val, 5, 2) + substr(val, 8, 2) +
                            substr(val, 11, 2) + substr(val, 14, 2) + substr(val, 17, 2));

            case "time":
                return date("19700101" + substr(val, 0, 2) + substr(val, 3, 2) + substr(val, 6, 2)) +
                       milliseconds(substr(val, 9, 3));

            case "boolean":
                if (val =~ /true/i)
                    return True;
                if (val =~ /false/i)
                    return False;
                return boolean(val);

            case "decimal":
                return float(val);

            case "base64Binary":
                if (val.typeCode() == NT_BINARY) {
                    return val;
                } else {
                    return val.empty() ? binary() : parse_base64_string(val);
                }

            case "hexBinary":
                if (val.typeCode() == NT_BINARY) {
                    return val;
                } else {
                    return val.empty() ? binary() : parse_hex_string(val);
                }

            case "binary":
                # used for HTTP binding only
                if (val.typeCode() == NT_BINARY) {
                    return val;
                } else {
                    return val.empty() ? binary() : binary(val);
                }

            default: {
                if (name == "anyType")  {
                    *XsdAbstractType t = tmap.tryGet(type);
                    if (t)
                        return t.deserialize(en, tmap, mrh, val);
                }
                throw SOAP_DESERIALIZATION_ERROR, sprintf("don't know how to handle type %y", name);
            }
        }
    }
}

#! class for XSD array types; currently only supports "binary"; used, for example with HTTP MultiPart messages
public class WSDL::XsdArrayType inherits WSDL::XsdAbstractType {
    constructor(string t, Namespaces nsc) : XsdAbstractType(t, "ns1", nsc) {
        if (t != "binary")
            throw "XSD-ARRAYTYPE-ERROR", sprintf("don't know how to handle arrays of type %y", t);
    }

    any serialize(any val, *softbool omitType) {
        switch (name) {
            case "binary": {
                int t = val.typeCode();
                if (t === NT_STRING)
                    val = binary(val);
                else if (t !== NT_BINARY)
                    throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize type %y from type %y; requires string or binary", name, t);
                return val;
            }

            default: {
                throw SOAP_SERIALIZATION_ERROR, sprintf("don't know how to handle type %y", name);
            }
        }
    }

    any deserialize(string en, *TypeMap tmap, *hash mrh, any val) {
        switch (name) {
            case "binary": {
                if (val.typeCode() != NT_BINARY)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("cannot deserialize type %y from type %y; requires binary", name, val.typeName());
                return val;
            }

            default: {
                throw SOAP_DESERIALIZATION_ERROR, sprintf("don't know how to handle type %y", name);
            }
        }
    }
}

#! XSD typed data class
public class WSDL::XsdTypedData inherits WSDL::XsdNamedData {
    public {
        any type;
    }

    constructor(reference e) : XsdNamedData(\e) {
    }
}

#! XSD attribute class
public class WSDL::XsdAttribute inherits WSDL::XsdTypedData {
    public {
        string use = "optional";

        const AllowedUseValues = (
            "optional": True,
            "required": True,
            "prohibited": True,
            );
    }

    constructor(hash attr, Namespaces nsc, *XsdAbstractType n_type, XsdLateResolverHelper unresolved) : XsdTypedData(\attr) {
        *hash aa = attr."^attributes^";
        if (aa.type) {
            type = nsc.doType(aa.type);

            if (aa.use) {
                if (!AllowedUseValues.(aa.use))
                    throw "XSD-ATTRIBUTE-ERROR", sprintf("attribute %y: use %y is unrecognized; recognized use values: %y", name, aa.use, AllowedUseValues.keys());
                use = aa.use;
            }

            # add self to unresolved list if element type cannot be resolved
            if (!(type instanceof XsdAbstractType))
                unresolved.add(self);
        }
    }

    any getValue(string val) {
        return type.deserialize(name, NOTHING, NOTHING, val);
    }
}

#! XSD element class
public class WSDL::XsdElement inherits WSDL::XsdTypedData {
    public {
        int minOccurs = 1;
        int maxOccurs = 1;
        bool nillable = False;
        *string ref;
        bool usedocns;
    }

    constructor(hash e, Namespaces nsc, *XsdAbstractType n_type, XsdLateResolverHelper unresolved, bool n_usedocns) : XsdTypedData(\e) {
        usedocns = n_usedocns;

        if (!ns)
            ns = nsc.getTargetNamespaceUri();

        if (n_type) {
            type = n_type;
            return;
        }

        *hash a = e."^attributes^";

        if (exists a.minOccurs)
            minOccurs = int(a.minOccurs);

        if (exists a.maxOccurs)
            if (a.maxOccurs == "unbounded")
                maxOccurs = -1;
            else
                maxOccurs = int(a.maxOccurs);

        if (maxOccurs != -1 && minOccurs > maxOccurs)
            throw "XSD-ELEMENT-ERROR", sprintf("minOccurs (%d) > maxOccurs (%d) for element %s", minOccurs, maxOccurs, name);

        if (a.nillable == "true")
            nillable = True;

        if (a.type) {
            type = nsc.doType(a.type);

            # add self to unresolved list if element type cannot be resolved
            if (!(type instanceof XsdAbstractType)) {
                #printf("DEBUG: self: %y\n", self);
                unresolved.add(self);
            }
        }
        else if (e.simpleType)
            type = new XsdSimpleType(e.simpleType, nsc, unresolved, usedocns, sprintf("simpleType for element %y", name));
        else if (e.hasKey("complexType")) {
            type = new XsdComplexType(e.complexType, nsc, unresolved, usedocns, sprintf("complexType for element %y", name));
            if (!type.isRequired() && !exists a.minOccurs)
                minOccurs = 0;
            if (type.isNillable() && !exists a.nillable)
                nillable = True;
        }
        else if (e."^attributes^".ref) {
            ref = e."^attributes^".ref;
            unresolved.add(self);
        }
    }

    assimilate(WSDL::XsdElement other) {
        map self.$1 = other.$1, other.keyIterator(), !exists self.$1;
        # we have to use the namespace of the referenced element
        ns = other.ns;
    }

    bool isRequired() {
        return minOccurs > 0;
    }

    bool isNillable() {
        return nillable;
    }

    /*
    bool isRequired() {
        #printf("DBG %y: required nillable: %y minOccurs: %y type: %y\n", name, nillable, minOccurs, ((type instanceof XsdAbstractType && type.isRequired()) | True));
        return !nillable && minOccurs && ((type instanceof XsdAbstractType && type.isRequired()) | True);
    }
    */

    any serialize(any h, *softbool omitType, string key, string typename) {

        if (h."^type^" && h."^type^" instanceof XsdAbstractType && h.hasKey("^val^")) {
            XsdAbstractType ntype = cast<XsdAbstractType>(h."^type^");
            ntype.checkExtends(type, name);
            return serializeAsIntern(ntype, h."^val^", omitType, key, name);
        }

        return serializeAsIntern(type, h, omitType, key, typename);
    }

    private any serializeAsIntern(XsdAbstractType type, any h, *softbool omitType, string key, string typename) {
        #printf("DEBUG: XsdElement::serializeAsIntern() name: %y (with type: %y) h: %y key: %y typename: %y (%y) minOccurs: %y nillable: %y (%y %y)\n", name, ((!omitType || type != self.type) && type.hasRealName()), h, key, typename, type.getName(), minOccurs, nillable, !exists h, !minOccurs);

        int tc = h.typeCode();
        if (tc == NT_LIST && h.size() == 1)
            h = h[0];

        if (!exists h || (tc == NT_LIST && h.empty())) {
            if (!minOccurs)
                return;

            if (nillable || type.isNillable()) {
                hash rh = ("xsi:nil": "true");
                if ((!omitType || type != self.type) && type.hasRealName())
                    rh += ("xsi:type": type.getNameWithNS());
                return ("^attributes^": rh);
            }

            if (!type.isRequired())
                return;

            if (!type.requiresValue())
                return ("^value^": NOTHING);

            throw SOAP_SERIALIZATION_ERROR, sprintf("missing element %y value for %s::%s (minOccurs: %d, type %y)", name, typename, key, minOccurs, type.getName());
        }

        *hash pf;
        if ((!omitType || type != self.type) && type.hasRealName())
            pf = ("^attributes^": ("xsi:type": !usedocns ? type.getName() : type.getNameWithNS()));

        if (tc == NT_LIST) {
            int len = h.size();
            if (maxOccurs == 1 && len > 1)
                throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize element %y of type %y from a list with %d elements because maxOccurs = 1", name, type.getName(), len);
            if (len > maxOccurs && maxOccurs > 0)
                throw SOAP_SERIALIZATION_ERROR, sprintf("list for element %y of type %y has %d element%s, but maxOccurs = %d", name, type.getName(), elements h, elements h == 1 ? "" : "s", maxOccurs);
            if (len < minOccurs)
                throw SOAP_SERIALIZATION_ERROR, sprintf("list for element %y of type %y has %d element%s, but minOccurs = %d", name, type.getName(), elements h, elements h == 1 ? "" : "s", minOccurs);

            list l = ();
            foreach any e in (h) {
                l += (pf + type.serialize(e, omitType));
            }
            return l;
        }
        if (minOccurs > 1)
            throw SOAP_SERIALIZATION_ERROR, sprintf("only one element passed to element %y of type %y, but minOccurs = %d", name, type.getName(), minOccurs);

        #printf("DEBUG: element %y type %s: %y omitType: %y h: %y\n", name, type.className(), type.name, omitType, h);
        return (pf + type.serialize(h, omitType));
    }

    any deserialize(*TypeMap tmap, *hash mrh, any val, bool present) {
        #printf("XsdElement::deserialize() name: %y type: %y (nillable: %y) val: %y present: %y\n", name, type.getName(), type.isNillable(), val, present);
        *hash a = val."^attributes^";
        if (a)
            WSDL::XsdBase::removeNS(\a);

        if ((!exists val && !present) || a.nil == "true") {
            if (nillable || type.isNillable() || !minOccurs)
                return;
            throw SOAP_DESERIALIZATION_ERROR, sprintf("NOTHING passed for element %y type %y, but nillable=False and minOccurs: %d", name, type.getName(), minOccurs);
        }

        if (val.typeCode() == NT_LIST) {
            int el = elements val;
            if (maxOccurs != -1 && el > maxOccurs)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("error deserializing element %y, maxOccurs: %d but list is %d elements long", name, maxOccurs, el);
            if (el < minOccurs)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("error deserializing element %y, minOccurs: %d but list is %d elements long", name, minOccurs, el);

            list l;
            foreach any e in (val)
                l[elements l] = type.deserialize(name, tmap, mrh, getValue(mrh, e));
            return l;
        }

        if (minOccurs > 1)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("single value passed for element %y, but minOccurs: %d", name, minOccurs);

        return type.deserialize(name, tmap, mrh, getValue(mrh, val));
    }
}

#! XSD simple type class
public class WSDL::XsdSimpleType inherits WSDL::XsdAbstractType {
    public {
        hash enum;
        any type;
        bool usedocns;
    }

    constructor(hash st, Namespaces nsc, XsdLateResolverHelper unresolved, bool n_usedocns, *string desc_name) : XsdAbstractType(\st, nsc, desc_name) {
        usedocns = n_usedocns;
        #any a = st."^attributes^";
        delete st."^attributes^";

        WSDL::XsdBase::removeNS(\st);

        if (st.restriction) {
            *hash r = st.restriction;

            any base = r."^attributes^".base;
            if (!base)
                throw "XSD-SIMPLETYPE-ERROR", sprintf("missing 'base' attribute in simpleType %y restriction", name);

            type = nsc.doType(base);

            # add base type to unresolved list if type cannot be resolved
            if (!(type instanceof XsdData))
                unresolved.add(self);

            WSDL::XsdBase::removeNS(\r);

            if (r.enumeration)
                enum = map {$1."^attributes^".value: True}, r.enumeration;
        }
        else
            throw "XSD-SIMPLETYPE-ERROR", sprintf("missing restriction element in simpleType %y", name);

        #printf("DEBUG: st: %y\n", self); exit();
    }

    any serialize(any val, *softbool omitType) {
        *hash rh;
        if (val.typeCode() == NT_HASH) {
            foreach string k in (val.keyIterator()) {
                if (k =~ /^\^comment/) {
                    rh{k} = remove val{k};
                }
            }
            if (val.size() == 1 && val.firstKey() == "^value^")
                val = val."^value^";
        }
        if (enum && !enum{val})
            throw "SOAP-SERIALIZATION-ERROR", sprintf("value %y passed to simpleType %y is not in the enumeration list (%y)", val, name, enum.keys());

        return rh + type.serialize(val, omitType);
    }

    any deserialize(string en, *TypeMap tmap, *hash mrh, any val) {
        any v = type.deserialize(en, tmap, mrh, val);

        if (enum && !enum{v})
            throw "SOAP-DESERIALIZATION-ERROR", sprintf("value %y passed to simpleType %y while deserializing element %y is not in the enumeration list (%y)", v, name, en, enum.keys());

        return v;
    }
}

#! XSD complex type class
public class WSDL::XsdComplexType inherits WSDL::XsdAbstractType {
    public {
        any array;
        any restriction;
        *string extension;

        bool usedocns;

        *hash elementmap;
        bool anyAttribute = False;

        bool nillable = False;
        bool required = False;
        bool requires_value = False;

        # attributes
        hash attrs;

        # any annotated documentation
        *string documentation;

        # simpleContent type
        any simpleType;

        # finalization flag
        bool finalized = False;

        # multiple choice blocks
        list choices = ();
    }

    private {
        #! type of complexType object
        string cx_type;

        const XET_ALL      = "ALL";
        const XET_CHOICE   = "CHOICE";
        const XET_SEQUENCE = "SEQUENCE";
        const XET_SIMPLE   = "SIMPLE";
        const XET_NONE     = "NONE";
    }

    # ct can be NOTHING in case of an empty complex type
    constructor(*hash ct, Namespaces nsc, XsdLateResolverHelper unresolved, bool n_usedocns, *string desc_name) : XsdAbstractType(\ct, nsc, desc_name) {
        usedocns = n_usedocns;
        #any a = ct."^attributes^";
        delete ct."^attributes^";

        *hash d = ct.complexContent;
        if (d) {
            WSDL::XsdBase::removeNS(\d);
            if (d.restriction) {
                WSDL::XsdBase::removeNS(\d.restriction);

                any base = d.restriction."^attributes^".base;

                # FIXME: handle namespace
                (*string ns, *string tn) = base =~ x/(\w+):(\w+)/;
                if (exists tn) {
                    if (tn == "Array") {
                        # FIXME check that namespace is SOAP encoding
                        any aa = d.restriction.attribute."^attributes^";
                        WSDL::XsdBase::removeNS(\aa);
                        if (!exists aa.arrayType)
                            throw WSDL_ERROR, sprintf("cannot parse complexType restriction: %y", d.restriction);

                        # FIXME: handle multiple dimensions?
                        (*string ans, *string atn) = aa.arrayType =~ x/(\w+):(\w+)\[\]$/;
                        if (exists atn) {
                            array.val = atn;
                            array.ns  = ans;
                        }
                        else
                            array.val = aa.arrayType;

                        delete d.restriction.attribute;
                        #printf("DEBUG: ans: %y atn: %y aa: %y\n", ans, atn, aa);
                        return;
                    }
                    else {
                        restriction = tn;
                    }
                }

                delete d.restriction."^attributes^";

                parseData(d.restriction, unresolved);
            }
            else if (d.extension) {
                #any etype = nsc.doType(d.extension."^attributes^".base);
                #if (!(etype instanceof XsdAbstractType))
                #    unresolved.add(self);
                extension = d.extension."^attributes^".base;

                # FIXME: check for soap encoding namespace
                extension =~ s/(.*:)(.*)/$2/;
                delete d.extension."^attributes^";
                WSDL::XsdBase::removeNS(\d.extension);

                parseData(d.extension, unresolved);
            }
            else
                throw "XSD-COMPLEXCONTENT-ERROR", sprintf("can't parse complexContent %y %y information", getName(), d.firstKey());
        }
        else if (ct.simpleContent) {
            d = ct.simpleContent;
            WSDL::XsdBase::removeNS(\d);
            cx_type = XET_SIMPLE;
            simpleType = nsc.doType(d.extension."^attributes^".base);
            remove d.extension."^attributes^";
            if (!(simpleType instanceof XsdAbstractType))
                unresolved.add(self);
            WSDL::XsdBase::removeNS(\d.extension);
            parseAttributes(\d.extension, unresolved);
        }
        else if (ct)
            parseData(ct, unresolved);
        else {
            # empty complex type
            cx_type = XET_NONE;
            required = True;
            requires_value = False;
        }
    }

    finalize(TypeMap tmap, Namespaces nsc) {
        if (finalized)
            return;
        finalized = True;

        # process restriction info
        if (restriction) {
            # combine base type and new type
            XsdAbstractType t = tmap.get(restriction);
            if (!(t instanceof XsdComplexType))
                throw WSDL_ERROR, sprintf("cannot restrict complexType %y with type %y", name, t.name);
            cast<XsdComplexType>(t).finalize(tmap, nsc);
            elementmap = cast<XsdComplexType>(t).elementmap + elementmap;
            #printf("DEBUG: extended %s with %s (%y)\n", name, restriction, cast<XsdComplexType>(t).elementmap.keys());
        }
        # process extension info
        else if (extension) {
            XsdAbstractType t = tmap.get(extension);
            if (!(t instanceof XsdComplexType))
                throw WSDL_ERROR, sprintf("cannot extend complexType %y with type %y", name, t.name);
            cast<XsdComplexType>(t).finalize(tmap, nsc);
            # combine base type and new type
            elementmap = cast<XsdComplexType>(t).elementmap + elementmap;
            #printf("DEBUG: extended %s (%s) with %s (%y) elements: %y\n", name, self.uniqueHash(), extension, cast<XsdComplexType>(t).elementmap.keys(), elementmap.keys());
        }

        # process array info
        if (array) {
            any et = array.val;
            *XsdAbstractType t = tmap.tryGet(et);
            array = new XsdArrayType(t ? t : et, nsc);
        }
    }

    #! throws an exception if the types are not compatible
    checkExtends(XsdAbstractType t, string ename) {
        if (extension == t.name || t == self)
            return;
        throw SOAP_SERIALIZATION_ERROR, sprintf("explicit type %y given for element %y, type %y, however the types are not compatible%s", name, ename, t.name, extension ? sprintf("; %y extends %y", name, extension) : "");
    }

    private parseData(hash d, XsdLateResolverHelper unresolved) {
        delete d.ns;
        if (d.annotation) {
            *hash ah = remove d.annotation;
            if (ah.size() == 1 && ah.firstKey() =~ /documentation$/)
                documentation = trim(ah.firstValue());
        }
        if (!d)
            return;

        parseAttributes(\d, unresolved);

        if (!d) {
            cx_type = XET_NONE;
            required = True;
            requires_value = False;
            return;
        }

        if (d.size() > 1)
            throw WSDL_ERROR, sprintf("%s: expecting a single element in the complexType hash, got: %y", name, d.keys());

        string k = d.firstKey();
        if (k == "all") {
            cx_type = XET_ALL;
            WSDL::XsdBase::removeNS(\d.all);
            elementmap = parseElements(d.all.element, unresolved);
        }
        else if (k == "choice") {
            cx_type = XET_CHOICE;
            WSDL::XsdBase::removeNS(\d.choice);
            elementmap = parseElements(d.choice.element, unresolved);
        }
        else if (k == "sequence") {
            cx_type = XET_SEQUENCE;
            WSDL::XsdBase::removeNS(\d.sequence);
            if (d.sequence.element)
                elementmap = parseElements(d.sequence.element, unresolved);
            WSDL::XsdBase::removeNS(\d.sequence.choice);
            foreach hash ch in (d.sequence.choice) {
                #printf("ch: %y\n", ch);
                *hash h = parseElements(ch.element, unresolved, False);
                if (h) {
                    hash ech.elementmap = h;
                    if (ch."^attributes^".minOccurs > 0)
                        ech.required = True;
                    choices += ech;
                }
            }
        }
        else
            throw "XSD-COMPLEXTYPE-ERROR", sprintf("unknown keys in %y", d);
    }

    private parseAttributes(reference d, XsdLateResolverHelper unresolved) {
        # process attributes if any
        foreach hash ah in (remove d.attribute) {
            if (ah."^attributes^") {
                XsdAttribute attr(ah, nsc, NOTHING, unresolved);
                attrs.(attr.name) = attr;
            }
        }

        if (d.hasKey("anyAttribute")) {
            anyAttribute = True;
            delete d.anyAttribute;
        }
    }

    bool isNillable() {
        return nillable;
    }

    bool isRequired() {
        return required;
    }

    bool requiresValue() {
        return requires_value;
    }

    private *hash parseElements(softlist el, XsdLateResolverHelper unresolved, bool for_object = True) {
        #printf("DEBUG: XsdComplexType::parseElements(%y)\n", el);
        hash h;
        foreach hash e in (el) {
            #printf("DEBUG: XsdComplexType::parseElements() ns: %y e: %y\n", nsc.getTargetNamespaceUri(), e);
            XsdElement elem(e, nsc, NOTHING, unresolved, usedocns);
            h.(elem.name) = elem;

            if (for_object && !required && elem.isRequired())
                required = True;
        }

        if (for_object) {
            if (h.size() == 1 && h.firstValue().isNillable())
                nillable = True;
        }

        if (for_object && required && !nillable)
            requires_value = True;

        return h;
    }

    private *hash serializeElement(string key, XsdElement element, any h, *softbool omitType) {
        any v = h{key};
        string e_ons;
        #printf("DEBUG: XsdComplexType::serializeElement() key: %y v: %y h: %y ns: %y\n", key, v, h, nsc.getTargetNamespaceUri());
        any e = element.serialize(v, omitType, key, name);

        if (!exists e && !element.isRequired())
            return;

        /*
        if (e_ons != ons && e_ons != "xsd") {
            if (e.typeCode() != NT_HASH)
                e = ("^value^": e);
            e."^attributes^" = ("xmlns": nsc.getOutputNamespaceUri(ons));
        }
        */

        hash rv.(!usedocns ? key : (nsc.getOutputNamespacePrefix(element.ns) + ":" + key)) = e;
        return rv;
    }

    *hash serialize(any h, *softbool omitType) {
        if (exists array)
            return array.serialize(h, omitType);

        # process attributes first
        *hash ah;
        hash rh;
        if (h.typeCode() == NT_HASH) {
            if (h."^attributes^") {
                hash mah = remove h."^attributes^";
                foreach string k in (mah.keyIterator()) {
                    if (!attrs{k})
                        throw SOAP_SERIALIZATION_ERROR, sprintf("cannot set unknown attribute %y of element %y; known attributes: %y", k, getName(), attrs.keys());
                    if (attrs{k}.use == "prohibited")
                        throw SOAP_SERIALIZATION_ERROR, sprintf("cannot set attribute %y of element %y; the WSDL marks this attribute as prohibited", k, getName());
                    ah{k} = mah{k};
                }
            }
            # check for required attributes
            foreach XsdAttribute attr in (attrs.iterator()) {
                if (attr.use == "required" && !exists ah.(attr.name))
                    throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize element %y without attribute %y; the WSDL marks this attribute as required", getName(), attr.name);
            }
            foreach string k in (h.keyIterator()) {
                if (k =~ /^\^comment/) {
                    rh{k} = remove h{k};
                }
            }
        }


        if (cx_type == XET_SIMPLE) {
            if (exists h."^value^")
                h = h."^value^";
            rh."^value^" = simpleType.serialize(h, omitType);
        }
        else if (cx_type != XET_NONE) {
            if (exists h && h.typeCode() != NT_HASH)
                throw SOAP_SERIALIZATION_ERROR, sprintf("expecting hash argument to serialize from complexType %y (got %y, type %y)", getName(), h, type(h));

            if (cx_type == XET_SEQUENCE || cx_type == XET_ALL) {
                foreach string p in (elementmap.keyIterator()) {
                    #printf("DEBUG element: %y (%y)\nvalue: %y\n", p, elementmap{p}, h{p});
                    rh += serializeElement(p, elementmap{p}, h, omitType);
                    delete h{p};
                }

                # when generating example messages we need generate all choices, in this case extra ^choices^ tag is used
                # choice name is unique in element so ne merge all choices together first
                *hash hch;
                foreach string k in (h.keyIterator()) {
                    if (k =~ /^\^choices/) {
                        hch += remove h{k};
                    }
                }
                # also serialize each choice block, if any
                foreach hash ch in (choices) {
                    *hash vh = h.(ch.elementmap.keys());
                    *hash vhch = hch.(ch.elementmap.keys());
                    if (!vh && !vhch) {
                        if (ch.required)
                            throw SOAP_SERIALIZATION_ERROR, sprintf("expecting one of %y to serialize choice / union in complexType %y but no such keys were supplied", ch.elementmap.keys(), getName());
                    }
                    else {
                        if (vh) {
                            rh += serializeChoice(ch.elementmap, vh, omitType, False);
                            # remove the serialized key from the input hash for the check below
                            map remove h{$1}, keys vh;
                        }
                        if (vhch) {
                            rh += serializeChoice(ch.elementmap, vhch, omitType, True);
                            map remove hch{$1}, keys vhch;
                        }
                    }
                }

                if (h) {
                    any kl = h.size() == 1 ? h.firstKey() : h.keys();
                    throw SOAP_SERIALIZATION_ERROR, sprintf("%y %s of type %y (valid elements: %y)", kl, kl.lsize() == 1 ? "is an invalid member" : "are invalid members", getName(), elementmap.keys());
                }
                if (hch) {
                    throw SOAP_SERIALIZATION_ERROR, sprintf("unknown choice members %y provided via ^choices^ in %y", keys hch, getName());
                }
            }
            else { # "choice" - union
                rh = serializeChoice(elementmap, h, omitType, False);
            }
        }
        else { # "none"
            rh."^value^" = NOTHING;
        }

        #printf("DEBUG name: %y desc: %y\n", name, descriptive_name);
        if (name && !omitType && !descriptive_name)
            rh."^attributes^" += ("xsi:type": "ns1:" + name) + ah;
        else if (ah)
            rh."^attributes^" += ah;
        #printf("DEBUG complex type %s returning %y from %y\n", name, rh, h);
        return rh;
    }

    private hash serializeChoice(hash emap, hash h, *softbool omitType, bool all_members) {
        # normally there is only one choice but we also need output example message where all options are enumerated
        if (!all_members && elements h > 1)
            throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize choice / union in complexType %y with more than 1 member (%y)", getName(), h.keys());
        *hash rh;
        foreach string key in (keys h) {
            if (!emap{key})
                throw SOAP_SERIALIZATION_ERROR, sprintf("%y is an invalid member of choice / union in complexType %y; expecting one of: %y", key, getName(), emap.keys());

            # add namespace if necessary
            rh += serializeElement(key, emap{key}, h, omitType);
        }
        # add namespace if necessary
        return rh;
    }

    *hash deserialize(string en, *TypeMap tmap, *hash mrh, any oval) {
        if (exists array)
            return array.deserialize(en, tmap, mrh, oval);

        if (!exists oval) {
            if (!required)
                return;
        }

        hash rh;

        *hash val = oval;
        *hash attr = val."^attributes^";

        # attribute hash
        *hash ah;
        if (attr) {
            # parse incoming valid attributes
            foreach XsdAttribute xa in (attrs.iterator()) {
                *string attr_val = val."^attributes^".(xa.name);
                if (xa.use == "required" && !exists attr_val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("cannot deserialize element %y without attribute %y; the WSDL marks this attribute as required", getName(), xa.name);
                if (exists attr_val) {
                    if (attr.use == "prohibited")
                        throw SOAP_DESERIALIZATION_ERROR, sprintf("cannot deserialize element %y with attribute %y; the WSDL marks this attribute as prohibited", getName(), xa.name);
                    ah.(xa.name) = xa.getValue(attr_val);
                }
            }

            delete val."^attributes^";

            # ensure types match
            *string tn = attr."xsi:type";
            if (exists tn) {
                (*string ns, *string tname) = tn =~ x/(.*):(.*)/;
                if (exists tname)
                    tn = tname;
                if (tn != name) {
                    # check for compatible extension
                    *XsdAbstractType t = tmap.tryGet(tn);
                    #printf("DEBUG: type provided %y: %y\n", tn, t.name);
                    if (t) {
                        t.checkExtends(self, en);
                        return t.deserialize(en, tmap, mrh, oval);
                    }

                    throw SOAP_DESERIALIZATION_ERROR, sprintf("expecting ComplexType type %y for element %y, got %y", getName(), en, tn);
                }
            }
        }

        if (val.typeCode() == NT_HASH) {
            WSDL::XsdBase::removeNS2(\val);

            #any ns = val.".ns";
            val -= ".ns";
        }

        if (cx_type == XET_SIMPLE) {
            if (!exists val && !required)
                return;
            any sv = simpleType.deserialize(name, tmap, mrh, val);
            if (sv.typeCode() == NT_HASH)
                rh = sv;
            else
                rh."^value^" = sv;
        }
        else if (cx_type != XET_NONE) {
            if (exists val && val.typeCode() != NT_HASH)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("cannot deserialize element %y type %y from qore type %y (expecting hash)", en, getName(), val.type());

            if (cx_type == XET_SEQUENCE || cx_type == XET_ALL) {
                #printf("XsdComplexType::deserialize() name: %y val: %y required: %y\n", getName(), val, required);
                # if we have one element
                if (elementmap.size() == 1 && val.size() == 1
                    && val.firstKey() == elementmap.firstKey()
                    && !exists val{elementmap.firstKey()} && !required && !choices)
                    return;

                foreach string p in (elementmap.keyIterator()) {
                    #printf("element %y\n", p);
                    rh{p} = elementmap{p}.deserialize(tmap, mrh, getValue(mrh, val{p}), val.hasKey(p));
                    delete val{p};
                }
                # also parse each choice block, if any
                foreach hash ch in (choices) {
                    *hash vh = val.(ch.elementmap.keys());
                    *hash h = parseChoice(vh, ch.elementmap, en, tmap, mrh, ch.required);
                    if (h)
                        rh += h;
                    delete val.(h.keys());
                    #printf("choice em: %y h: %y\n", ch.elementmap.keys(), h);
                }
                delete val."^attributes^";
                if (val)
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("invalid element %y passed in type %y for element %y (expecting %y)", (keys val)[0], getName(), en, keys elementmap);
            }
            else { # "choice" - union
                rh += parseChoice(val, elementmap, en, tmap, mrh, True);
            }
        }

        if (ah)
            rh."^attributes^" = ah;
        return rh;
    }

    private *hash parseChoice(hash val, hash emap, string en, *TypeMap tmap, *hash mrh, *bool required) {
        list kl = val.keys();
        if (elements kl > 1)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("too many elements supplied for choice / union in type %y for element %y (%y)", getName(), en, kl);
        *string key = kl[0];
        if (!exists key) {
            if (required)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("missing element for choice / union in type %y for element %y (expecting one of: %y)", getName(), en, emap.keys());
            return;
        }
        if (!exists emap{key})
            throw SOAP_DESERIALIZATION_ERROR, sprintf("element %y is not a valid element for choice / union in type %y for element %y (valid elements: %y)", key, getName(), en, emap.keys());

        return (key: emap{key}.deserialize(tmap, mrh, getValue(mrh, val{key}), val.hasKey(key)));
    }
}

#! web service operation class
public class WSDL::WSOperation inherits WSDL::XsdNamedData {
    public {
        WSMessage input;
        WSMessage output;
        *string input_name;
        *string output_name;
        TypeMap tmap;

        Namespaces nsc;

        *string soapAction;  # TODO: remove   SoapHandler, SoapClient
        *string request_name;

        # params per associated binding
        hash bindings;
    }

    constructor(any p, TypeMap n_tmap, Namespaces n_nsc, *hash messages) : XsdNamedData(\p) {
        tmap = n_tmap;
        nsc = n_nsc;

        if (p.input) {
            hash msghash = processNSValue(p.input."^attributes^");

            *WSMessage msg = messages.(msghash.message.val);
            if (!msg)
                throw WSDL_ERROR, sprintf("missing definition for input message %y required by operation %y", msghash.name.val, name);
            input = msg;

            #printf("DBG: WSOperation::constructor() name: %y msghash: %y\n", name, msghash);
            if (msghash.name)
                input_name = msghash.name.val ? msghash.name.val : msghash.name;
        }

        if (p.output) {
            hash msghash = processNSValue(p.output."^attributes^");

            *WSMessage msg = messages.(msghash.message.val);
            if (!msg)
                throw WSDL_ERROR, sprintf("missing definition for output message %y required by operation %y", msghash.name.val, name);

            output = msg;
            if (msghash.name)
                output_name = msghash.name.val ? msghash.name.val : msghash.name;
        }

        *string op_ns = nsc.getTargetNamespaceUri();
        if (op_ns && op_ns !~ /\/$/)
            op_ns += "/";
        soapAction = op_ns ? op_ns + name : name;
    }

    setDocStyle(reference idocmap) {
        # docstyle = True;  # property per binding

        foreach string key in (input.args.keyIterator()) {
            # FIXME: could be a type here instead of an element
            if (!input.args{key}.element.name) {
                return;
            }

            string element = input.args{key}.element.name;
            idocmap{element} = input.args{key}.element;
            if (!request_name)
                request_name = element;   # TODO: should not affect operation when calling from binding ??
        }
    }

    setTopLevelRequestElement(string name) {
        request_name = name;
    }

    string getTopLevelRequestName() {
        return request_name ? request_name : name;
    }

    #! returns a hash representing the given binding
    /** @param bname the name of the binding, if not provided then uses the first assigned binding

        @return a binding param hash describing the binding with the following keys:
        - \c "httpMethod"
        - \c "soapTransport"

        @throw WSDL-BINDING-ERROR unknown binding
     */
    hash getBinding(*string bname) {
        if (bindings && !exists bname)
            return bindings.firstValue();
        if (!exists bindings{bname})
            throw "WSDL-BINDING-ERROR", sprintf("binding %y is not a known binding for operation %y; known bindings: %y", bname, name, bindings.keys());
        return bindings{bname};
    }

    #! adds the given binding
    /** @param bname binding name, must be unique in operation
        @param opparams a hash with the following keys:
        - \c "httpMethod"
        - \c "soapTransport"

        @throw WSDL-BINDING-ERROR when binding already registered
     */
    addBinding(string bname, hash opparams) {
        if (bindings{bname}) {
            throw "WSDL-BINDING-ERROR", sprintf("binding %y is already registered in operation %y", bname, name);
        }
        opparams.name = bname;
        bindings{bname} = opparams;
    }

    private:internal hash serializeSoapMessage(any val, hash binding, *hash header, *hash nsh, bool request, bool soap12, reference mpm) {
        string io = request ? "input" : "output";
        # setup namespaces for SOAP envelope
        #printf("DEBUG: serializeSoapMessage: io:%s, h: %y, header: %y, binding: %y\n", io, val, header, binding);
        hash rh = nsc.hasSoap12() ? WSDL::ENVELOPE_12_NS : WSDL::ENVELOPE_11_NS;
        string soapenvEnvelope = rh.firstKey();
        rh{soapenvEnvelope}."^attributes^" += nsc.getOutputNamespaceHash(nsh);

        # do we have mime/multipart io format?
        if (exists binding{io}.multipart)
            mpm = new MultiPartRelatedMessage();

        #printf("DEBUG: docstyle: %y\n", binding.docstyle);
        *hash body;
        if (self{io}) {
            if (binding.docstyle)
                body = self{io}.serializeDocument(binding{io}.body.parts, binding{io}, mpm, binding{io}.body.encoded, \val);
            else {
                string mname = input_name ? input_name : name + (request ? "":"Response");
                if (binding{io})
                    body = self{io}.serializeRpc(binding{io}.body.parts, binding{io}, mpm, mname, binding{io}.body.encoded, \val);
            }

        }

        if (binding{io}.header) {
            #printf("DEBUG: %s, header: %y\n", io, header);
            hash outh;
            foreach hash hdr in (binding{io}.header) {
                #printf("DEBUG: hdr: %y, hdr.msg.name/part: %y/%y, val:%y\n", hdr, hdr.msg.name, hdr.part, val);
                if (binding.docstyle) {
                    *hash h = hdr.msg.serializeDocument(hdr.part, NOTHING, NOTHING, hdr.encoded, \header);
                    if (!h && val) {
                        # data provided in val ?
                        h = hdr.msg.serializeDocument(hdr.part, NOTHING, NOTHING, hdr.encoded, \val);
                    }
                    if (h) {
                        remove h."^attributes^".("soapenv:encodingStyle", "xmlns:soapenc");
                        outh += h;
                    }
                } else {
                    *hash h = hdr.msg.serializeRpc(hdr.part, NOTHING, NOTHING, hdr.part, hdr.encoded, \header);
                    if (!h && val) {
                        # data provided in val ?
                        #printf("DEBUG: testing val\n");
                        h = hdr.msg.serializeRpc(hdr.part, NOTHING, NOTHING, hdr.part, hdr.encoded, \val);
                    }
                    if (h) {
                        #printf("DEBUG: result: %y\n", h);
                        # tricky part, flatten hash, TODO: make it more transparently
                        string fk = h.firstKey();
                        h{fk} = h.firstValue().firstValue();   # "ns1:name" : ("ns1: name" | "name": val) -> "ns1:name": val
                        #printf("DEBUG: flatten result: %y\n", h);
                        if (exists outh{fk}) {
                            # it could in theory happen when two message parts are equal
                            if (outh{fk}.typeCode() != NT_LIST) {
                                outh{fk} = () + outh{fk};
                            }
                            outh{fk} += h{fk};
                        } else {
                            outh += h;
                        }
                    }
                }
            }
/*            if (header) {
                # append unprocessed values TODO: it's obsolete as it violates WSDL definition
                outh += header;
                header = NOTHING;
            } */
            #printf("DEBUG: outh: %y\n", outh);
            rh{soapenvEnvelope}."soapenv:Header" = outh;
        }
        if (header.typeCode() == NT_HASH && header)
            throw SOAP_SERIALIZATION_ERROR, sprintf("some %s header data provided for operation %y remains unserialized: %y", io, name, header);
        if (val.typeCode() == NT_HASH && val)
            throw SOAP_SERIALIZATION_ERROR, sprintf("some %s data provided for operation %y remains unserialized: %y", io, name, val);

        if (body) {
            rh{soapenvEnvelope}."soapenv:Body" = body;
        }
        return rh;
    }


    private:internal *data serializeHttpMessage(any h, hash binding, bool request, reference ct, reference enc) {
        string io = request ? "input" : "output";
        if (binding{io}.content.formUrlEncoded) {
            ct = MimeTypeFormUrlEncoded;
            # application/x-www-form-urlencoded Content-Type does not have any parameters
            delete enc;
            # TODO: throws exception when character is > 127, discussed e.g. https://www.w3.org/TR/html5/forms.html#application/x-www-form-urlencoded-encoding-algorithm
            return mime_get_form_urlencoded_string(self{io}.serializeAllPartData(h));
        } else if (binding{io}.content) {

            hash v = self{io}.serializeData(binding{io}.content.part, h);
            if (v."content-type") {
                if (!binding{io}.content.acceptAllContentTypes) {
                    WSDLLib::checkContentType(v."content-type", binding{io}.content.acceptedContentTypeSubtypes + binding{io}.content.acceptedContentTypes);
                }
                ct = v."content-type";
            } else {
                if (binding{io}.content.acceptAllContentTypes || binding{io}.content.acceptedContentTypes || binding{io}.content.acceptedContentTypeSubtypes.size() != 1) {
                    throw SOAP_SERIALIZATION_ERROR, sprintf("ambiguous content type in message %y related to %s operation %y", self{io}.name, io, name);
                }
                ct = binding{io}.content.acceptedContentTypeSubtypes[0];
            }
            if (v.value.typeCode() == NT_BINARY) {
                delete enc;
                return v.value;
            } else {
                return convert_encoding(v.value, enc);
            }
        } else if (binding{io}.mimeXml) {
            ct = MimeTypeXml;
            # in case of mimeXml is body content, i.e. XML tag based on element/type name, not part
            string ons;
            hash hh;
            hh{binding{io}.mimeXml.part} = self{io}.serializeRpcValue(binding{io}.mimeXml.part, False, \h, \ons);
            return make_xml(hh);
        }
    }

    #! serializes path part of URL when urlEncoded WSDL is defined
    *string serializePath(any h, hash binding) {
        string path;
        if (binding.location) {
            path = binding.location;
            if (binding.input.urlReplacement) {
                path = "";
                foreach string k in (keys binding.input.urlReplacement) {
                    if (k =~ /^string/) {
                        path += binding.input.urlReplacement{k};
                    } else if (k =~ /^part/) {
                        if (!input) {
                            throw SOAP_SERIALIZATION_ERROR, sprintf("url replacement requested for operation %s with no message (%y)", name, h);
                        }
                        hash v = input.serializeData(binding.input.urlReplacement{k}, h);
                        path += encode_url(string(v.value), True);
                    }
                }
            } else if (binding.input.urlEncoded) {
                string s = mime_get_form_urlencoded_string(input.serializeAllPartData(h));
                if (s) {
                    path += binding.location =~ /\?/ ? "&" : "?";
                    path += s;
                }
            }
        }
        return path;
    }

    #! serializes a request to an XML string or HTTP payload for the operation.
    /** @param h the request to serialize
        @param header optional soap header info to serialize if required (ex: authorization info). In the first step headers are matched to binding/input/header WSDL definition, remaining headers are passed as-is
        @param enc the optional encoding to use; if this argument is not present, then the default encoding will be used
        @param nsh an optional namespace hash for the output message
        @param xml_opts optional XML generation options
        @param req_soapaction if present will override any SOAPAction value for the request, ignored for HTTP binding
        @param bname SOAP binding name or empty to get the first assigned binding

        @return a hash with keys:
        - \c body: XML string in the SOAP request format or body part of HTTP message (string or binary). Target content type is evaluated from WSDL or in case of ambiguity
        using "^attributes^"."^content-type^". Provided content type must match allowed types in WSDL. Also "application/x-www-form-urlencoded" or any general type are supported.
        - \c hdr: hash of HTTP headers
        - \c path: the path part of URL. Used when urlEncoded is defined
        - \c method: the HTTP request method
        */
    hash serializeRequest(any h, *hash header, *string enc, *hash nsh, *int xml_opts, *string req_soapaction, *string bname) {
        hash binding = getBinding(bname);

        if (!exists req_soapaction)
            req_soapaction = bindings{name}.soapAction;

        string ct;
        enc = enc ?? get_default_encoding();

        hash rv = (
            "path": serializePath(h, binding),
            "method": binding.httpMethod ?? "POST",
        );

        if (binding.httpMethod) {
            rv.body = serializeHttpMessage(h, binding, True, \ct, \enc);
            if (binding.output.content) {
                if (binding.output.content.acceptAllContentTypes) {
                    rv.accept = "*/*";
                } else {
                    *list l;
                    l = binding.output.content.acceptedContentTypeSubtypes;
                    foreach string t in (binding.output.content.acceptedContentTypes)
                        push l, t+"*";
                    rv.accept = l.join(",");
                }
            } else if (binding.output.mimeXml) {
                rv.accept = MimeTypeXml;
            }
            if (exists rv.body && exists ct) {
                rv."content-type" = ct;
                if (exists enc) {
                    ct += sprintf(";charset=%s", enc);
                }
                rv.hdr."Content-Type" = ct;
            }
        } else {
            MultiPartRelatedMessage mpm;
            rv.body = make_xml(serializeSoapMessage(h, binding, header, nsh, True, nsc.hasSoap12(), \mpm), xml_opts, enc);
            if (mpm) {
                mpm.splicePart(rv.body, sprintf("<%s>", (binding.input.body.parts ? binding.input.body.parts : keys input.args).join(" ")), ct);

                hash rv = mpm.getMsgAndHeaders();
            }
            rv.accept = WSDLLib::SoapMimeTypes.join(",");

            string ct = WSDLLib::getSoapMimeType12(nsc.hasSoap12());
            rv."content-type" = ct;

            if (req_soapaction) {
                rv.hdr += ("SOAPAction": req_soapaction);
                if (nsc.hasSoap12()) {
                    ct += sprintf(";action: %s", req_soapaction);
                }
            }
            if (exists enc) {
                ct += sprintf(";charset=%s", enc);
            }
            rv.hdr."Content-Type" = ct;
        }

        if (rv.accept) {
            rv.hdr."Accept" = rv.accept;
        }

        return rv;
    }

    #! serializes a SOAP response to an XML string for the operation
    /** @param h the response to serialize
        @param header SOAP header hash. In the first step headers are matched to binding/input/header WSDL definition, remaining headers are passed as-is
        @param enc the optional encoding to use; if this argument is not present, then the default encoding will be used
        @param nsh namespace hash
        @param soap12 set to True if the response should use SOAP 1.2 encoding
        @param xml_opts optional XML generation options
        @param bname SOAP binding name, leave empty to get the first assigned binding

        @return a hash with keys:
        - \c body: XML string in the SOAP request format or body part of HTTP message (string or binary). Target content type is evaluated from WSDL or in case of ambiguity
        using "^attributes^"."^content-type^". Provided content type must match allowed types in WSDL.
        - \c hdr: hash of HTTP headers
    */
    hash serializeResponse(any h, *hash header, *string enc, *hash nsh, *bool soap12, *int xml_opts, *string bname) {
        hash binding = getBinding(bname);
        if (exists soap12) {
            if (soap12) {
                if (!nsc.hasSoap12())
                    throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize response for operation %y with SOAP 1.2 encoding; this operation does not support SOAP 1.2", name);
            }
            else {
                if (!nsc.hasSoap11())
                    throw SOAP_SERIALIZATION_ERROR, sprintf("cannot serialize response for operation %y with SOAP 1.1 encoding; this operation does not support SOAP 1.1", name);
            }
        }
        else
            soap12 = nsc.hasSoap12();

        enc = enc ?? get_default_encoding();
        hash rv;
        string ct;

        if (binding.httpMethod) {
            rv.body = serializeHttpMessage(h, binding, False, \ct, \enc);
        } else {
            MultiPartRelatedMessage mpm;
            # do we have mime/multipart output format?
            if (exists binding.output.multipart)
                mpm = new MultiPartRelatedMessage();

            rv.body = make_xml(serializeSoapMessage(h, binding, header, nsh, False, soap12, \mpm), xml_opts, enc);

            ct = WSDLLib::getSoapMimeType12(soap12);
            if (exists mpm) {
                mpm.splicePart(rv.body, sprintf("<%s>", (binding.output.body.parts ? binding.output.body.parts : keys output.args).join(" ")), ct);
                return mpm.getMsgAndHeaders();
            }
        }

        if (exists enc) {
            ct += sprintf(";charset=%s", enc);
        }

        if (exists rv.body) {
            rv.hdr = ("Content-Type": ct);
        }

        return rv;
    }

    private list processMultiRef(hash body) {
        # setup message info hash and multiRef lookup hash key, if any are present
        hash mrh = (
            # save original msg body hash
            "body": body,
            );
        # remove namespacr prefixes from body element keys
        WSDL::XsdBase::removeNS2(\mrh.body);

        if (body.multiRef) {
            foreach any mr in (body.multiRef)
                mrh.mrh.(mr."^attributes^".id) = mr;

            # resolve interior references to multiRefs
            foreach string id in (mrh.mrh.keyIterator()) {
                foreach string key in (mrh.mrh{id}.keyIterator()) {
                    if (key == "^attributes^")
                        continue;

                    #printf("multiRef id: %y key: %y val: %y\n", id, key, mrh.mrh{id}{key});

                    if (mrh.mrh{id}{key}.typeCode() == NT_LIST) {
                        foreach any e in (\mrh.mrh{id}{key}) {
                            any href = substr(e."^attributes^".href, 1);
                            if (exists href) {
                                if (!exists mrh.mrh{href})
                                    throw "INVALID-MULTIREF", sprintf("multiRef id: %y does not exist", href);
                                e = mrh.mrh{href};
                            }
                        }
                    }
                    else if (mrh.mrh{id}{key}.typeCode() == NT_HASH) {
                        any href = substr(mrh.mrh{id}{key}."^attributes^".href, 1);
                        if (exists href) {
                            if (!exists mrh.mrh{href})
                                throw "INVALID-MULTIREF", sprintf("multiRef id: %y does not exist", href);
                            mrh.mrh{id}{key} = mrh.mrh{href};
                        }
                    }
                }
            }

            delete body.multiRef;
        }
        #printf("mrh: %y\n", mrh.mrh);
        #printf("operation: %y\n", self);

        # remove namespace tags from element names
        WSDL::XsdBase::removeNS2(\body);
        remove body.".ns";

        return (mrh, body);
    }

    private:internal any deserializeSoapMessage(hash o, hash binding, bool request) {
        #printf("DEBUG: deserializeSoapMessage(%N, %y)\n", o, request);
        string io = request ? "input" : "output";
        WSDL::XsdBase::removeNS2(\o);
        WSDL::XsdBase::removeNS2(\o.Envelope);
        hash hrv;
        if (binding{io}.header) {
            *hash header = o.Envelope.Header;
            WSDL::XsdBase::removeNS2(\header);

            #printf("DEBUG: Deserialize SOAP headers: %N\n", header);
            foreach hash hdr in (binding{io}.header) {
                if (header.hasKey(hdr.part)) {
                    # seems it may appear part name conflict between messages when namespace is stripped
                    hash v;
                    if (binding.docstyle) {
                        hrv{hdr.msg.name} += hdr.msg.deserializeDocument(NOTHING, header, hdr.part);
                    } else {
                        hrv{hdr.msg.name} += hdr.msg.deserializeRpc(NOTHING, header, hdr.part);
                    }
                }
            }
            #printf("DEBUG: Deserialized SOAP headers: %N\n", hrv);
        }

        *hash body = o.Envelope.Body;

        if (!self{io}) {
            if (exists body)
                throw SOAP_DESERIALIZATION_ERROR, sprintf("%s value given for operation %y with no %s message: %y", request ? "request" : "response", name, io, body);
        }
        else if (!exists body)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("no %s body value given for operation %y", request ? "request" : "response", name);

        any rv;
        if (exists body) {
            (*hash mrh, hash msg) = processMultiRef(body);

            if (!request) {
                # check for Soap Fault, if so raise an exception immediately with the fault info
                WSDL::XsdBase::removeNS2(\body);

                if (body.Fault) {
                    WSDL::XsdBase::removeNS(\body.Fault);
                    delete body.Fault.".ns";
                    if (nsc.hasSoap12()) {
                        WSDL::XsdBase::removeNS(\body.Fault.Code);
                        WSDL::XsdBase::removeNS(\body.Fault.Reason);
                        string desc = sprintf("The following fault response was received from the server: code: %y", body.Fault.Code.Value);
                        any sc = body.Fault.Code.Subcode;
                        while (exists sc) {
                            WSDL::XsdBase::removeNS(\sc);
                            desc += sprintf(", subcode: %y", sc.Value);
                            sc = sc.Subcode;
                        }
                        foreach any rn in (body.Fault.Reason.Text) {
                            desc += sprintf(", text: %y", rn);
                        }

                        throw "SOAP-SERVER-FAULT-RESPONSE", desc, body.Fault;
                    }
                    else {
                        string desc = sprintf("The following fault response was received from the server: code: %y", body.Fault.faultcode);
                        if (exists body.Fault.faultstring)
                            desc += sprintf(", faultstring: %y", body.Fault.faultstring);
                        if (exists body.Fault.desc)
                            desc += sprintf(", desc: %y", body.Fault.desc);

                        throw "SOAP-SERVER-FAULT-RESPONSE", desc, body.Fault;
                    }
                }
            }

            #any ns = msg.".ns";
            msg -= ("ns", ".ns");
            if (binding.docstyle) {
                rv = self{io}.deserializeDocument(mrh, msg);
            } else {

                string mname = input_name ? input_name : name + (request ? "" : "Response");
                if (!msg{mname})
                    throw SOAP_DESERIALIZATION_ERROR, sprintf("missing %s message name %y as top-level element; got elements: %y", io, mname, keys msg);
                msg = remove msg{mname};
                XsdBase::removeNS2(\msg);
                msg -= (".ns", "ns");

                rv = self{io}.deserializeRpc(mrh, msg);
            }
        }

        if (exists hrv) {
            # for backwards compatibility with a flat hash when there was only argument
            # but we must be care of when the argument is a type (not element)
            if (rv.size() == 1 && rv.typeCode() == NT_HASH && !exists hrv{rv.firstKey()} ) {
                rv = rv.firstValue();
            } else {
                foreach my string k in (keys hrv) {
                    if (exists rv{k}) {
                        # name conflict
                        rv{self{io}.name} = rv;
                        break;
                    }
                }
            }
            rv += hrv;
        } else if (exists rv ) {
            # for backwards compatibility with a flat hash when there was only argument
            # but we must be care of when the argument is a type (not element)
            if (rv.size() == 1 && rv.typeCode() == NT_HASH) {
                rv = rv.firstValue();
            }
        }

        return rv;
    }

    private:internal *hash deserializeHttpMessage(hash v, hash binding, bool request) {
        string io = request ? "input" : "output";
        *string ct = v."content-type";
        if (!exists ct && !binding{io}.mimeXml) {
            throw SOAP_DESERIALIZATION_ERROR, sprintf("missing content-type in input hash: %y", v);
        }
        if (binding{io}.urlEncoded || binding{io}.urlReplacement) {
            # is should be processed via deserializeUrl()
            throw SOAP_DESERIALIZATION_ERROR, sprintf("urlencoded message deserialization is not supported in binding: %y", binding.name);
        }
        if (binding{io}.content.formUrlEncoded) {
            WSDLLib::checkContentType(ct, list(MimeTypeFormUrlEncoded));
            if (v.body.typeCode() == NT_BINARY) {
                v.body = binary_to_string(v.body);
            }
            hash h = mime_parse_form_urlencoded_string(v.body); # TODO: data have no encoding
            return self{io}.deserializeAllPartData(h);
        } else if (binding{io}.content) {

            if (!binding{io}.content.acceptAllContentTypes) {
                WSDLLib::checkContentType(ct, binding{io}.content.acceptedContentTypeSubtypes + binding{io}.content.acceptedContentTypes);
            }
            hash v2;
            v2{binding{io}.content.part} = v.body;
            hash h = self{io}.deserializeData(binding{io}.content.part, v2);
            string k = h.firstKey();
            h{k}."^value^" = remove h{k};
            h{k}."^attributes^"."^content-type^" = ct;
            return h;
        } else if (binding{io}.mimeXml) {
            *hash h = self{io}.deserializeData(binding{io}.mimeXml.part, v);
            return h;
        }
    }

    #! parses a hash representing a parsed XML request (parsed with parseXMLAsData()) for the operation and returns the corresponding Qore data structure
    /** @param o the parsed SOAP or HTTP request with @ref WSDLLib::parseSOAPMessage() for the operation
        @param bname SOAP binding name, leave empty to use the first assigned binding
        @return the Qore data structure corresponding to the request data. When SOAP header is deserialized according binding/input WSDL then all data are passed under sub hash values prefixed by message name
        In case of HTTP binding the content type is matched against WSDL binding when wildcards are supported and current content type value is applied to "^attributes^"."^content-type^".
    */
    any deserializeRequest(hash o, *string bname) {
        hash binding = getBinding(bname);
        if (binding.httpMethod) {
            return deserializeHttpMessage(o, binding, True);
        } else {
            return deserializeSoapMessage(o, binding, True);
        }
    }

    #! parses a hash representing a parsed XML response (parsed with parse_xml()) for the operation and returns the corresponding Qore data structure
    /** @param o the parsed SOAP or HTTP request with @ref WSDLLib::parseSOAPMessage() for the operation
        @param bname SOAP binding name, leave empty to use the first assigned binding
        @return the Qore data structure corresponding to the response data. When SOAP header is deserialized according binding/output WSDL then all data are passed under sub hash values prefixed by message name
        In case of HTTP binding the content type is matched against WSDL binding when wildcards are supported and current content type value is applied to "^attributes^"."^content-type^".
    */
    any deserializeResponse(hash o, *string bname) {
        hash binding = getBinding(bname);
        if (binding.httpMethod) {
            return deserializeHttpMessage(o, binding, False);
        } else {
            return deserializeSoapMessage(o, binding, False);
        }
    }

    /** Operation is resolved from method and path so let's look if data are passed in URL.
    When URL replacement is defined for operation then exception is raised.
    @return NOTHING if data are not encoded in URL for operation
    */
    any deserializePath(string path, *string bname) {
        hash binding = getBinding(bname);
        if (binding.input.urlReplacement) {
            # all parameters are somehow encoded in path
            throw SOAP_DESERIALIZATION_ERROR, sprintf("url replacement message deserialization is not supported in binding: %y", binding.name);
        }
        if (binding.input.urlEncoded) {
            hash h;
            if (index(path, "?") >= 0) {
                # any params ?
                int i = index(path, binding.location);
                if (i >= 0) {
                    # strip potential prefix in URL params
                    path = substr(path, i+binding.location.size());
                }
                # all parameters are in URL
                i = index(path, "?");
                if (i >= 0) {
                    path = substr(path, i+1);
                }
                i = 0;
                while (path[i] == "&") {
                    i++;
                }
                if (i) {
                    path = substr(path, i);
                }
                if (path != "") {
                    h = mime_parse_form_urlencoded_string(path);
                    return self.input.deserializeAllPartData(h);
                }
            }
            return hash();
        }
        throw SOAP_DESERIALIZATION_ERROR, sprintf("BUG: cannot deserialize url: %y", binding.input);
    }

    private hash processNSValue(hash h) {
        foreach string k in (keys h) {
            (*string ns, *string name) = h{k} =~ x/(\w+):(\w+)/;
            if (!name)
                h{k}.val = h{k};
            else {
                h{k}.ns = ns;
                h{k}.val = name;
            }
        }
        return h;
    }

    #! returns True if the operation is a SOAP 1.2 operation
    /** @return True if the operation is a SOAP 1.2 operation
    */
    bool isSoap12() {
        return nsc.hasSoap12();
    }

    #! returns the target namespace for the operation
    /** @return the target namespace for the operation
    */
    string getTargetNS() {
        return nsc.getTargetNamespaceUri();
    }
}

#! web service message class
/**
Message definition consists of part definition. Part name is important for simple types to name it at both SOAP and Qore side (hash key).
For elements is not used at the SOAP side, it implies condition the element name must be unique in message. In the other words
it's forbidden definition of two parts with the same element. It's unclear if is legal in Wsdl and how to handle it. Class raises
exception if detects it. The part name is also used for references from binding (header, content).
*/
public class WSDL::WSMessage inherits WSDL::XsdNamedData {
    public {
        #! args keys are part names for types reps. element names for element. Definition must provide unique values.
        hash args;
        #! part map; maps element names to part names
        #! maps part names to args key, all parts are in hash
        hash pmap;

        # keep a reference to Namespaces
        Namespaces nsc;

        # keep a reference to the type map
        TypeMap tmap;

    }

    constructor(hash m, ElementMap emap, TypeMap n_tmap, Namespaces n_nsc) : XsdNamedData(\m) {
        nsc = n_nsc;
        tmap = n_tmap;

        #printf("DEBUG: WSMessage::constructor() m: %y emap: %y\n", m, emap);

        name = m."^attributes^".name;
        foreach any p in (m.part) {
            any arg = p."^attributes^";
            if (pmap{arg.name})
                throw WSDL_ERROR, sprintf("duplicate part name %y in message %y", arg.name, name);
            if (arg.element) {
                (*string ns, *string ename) = arg.element =~ x/(\w+):(\w+)/;
                if (!ename)
                    ename = arg.element;
                if (args{ename})
                    throw WSDL_ERROR, sprintf("ambiguous element name %y in message %y", ename, name);

                if (arg.name) {
                    # is unique name required or not ?
                    args{ename}.part = arg.name;
                    pmap{arg.name} = ename;
                }

                args{ename}.element = emap.get(nsc.getNamespaceUri(ns), ename);
            }
            else {
                if (args{arg.name})
                    throw WSDL_ERROR, sprintf("part name colission with element %y in message %y, ", arg.name, name);
                args{arg.name} = arg;
                args{arg.name}.type = nsc.doType(arg.type);
                if (arg.name) {
                    pmap{arg.name} = arg.name;
                }
            }
        }
    }

    /**
        Just serialize value and return namespace
        @param ons is reference to string
    */
    any serializeRpcValue(string key, bool encoded, reference h, reference ons) {
        any v = getValueFromHash(key, \h, True);
        if (!exists v) {
            if (key || args.size() == 1) {
                v = getValueFromHash(args{key}.element, \h, True);
            }
            if (v.typeCode() == NT_NULL) {
                v = NOTHING;
            } else {
                if (!exists v) return;
            }
        }

        any hv;
        #printf("DEBUG: arg %y with %y\n", key, args{key});
        #printf("DEBUG: arg %y with %y\n", key, v."^val^" ?? v);
        if (args{key}.element) {
            hv = args{key}.element.serialize(v, !encoded, key, name);
            ons = nsc.getOutputNamespacePrefix(args{key}.element.ns);
        }
        else {
            hv = args{key}.type.serialize(v, !encoded);
            ons = args{key}.type.getOutputNamespacePrefix();
        }
        #printf("DEBUG: arg %s got %y from %y (%y)\n", k, hv, v, exists args{key}.element ? args{key}.element : args{key}.type);
        return hv;
    }

    #! serializes data into hash with SOAP soup as namespaces etc.
    /**
     * @param if present then serializes only particular element or part, if NOTHING then serializes all message elements
     * @param n_name name of output key
     * @param h data to be serialized, keys are wsdl element names (optionally part name is also possible) and part names for simple types
     */
    *hash serializeRpc(*softlist key, any msginfo, any mpm, string n_name, bool encoded, reference h) {
        hash rh;
        #printf("DEBUG: message %s: keys: %y, h: %y\n", name , keys, h);
        foreach string k in (key ? key : keys args) {
            string ons;
            any hv = serializeRpcValue(k, encoded, \h, \ons);
            if (!exists hv) continue;
            #printf("DEBUG: WSMessage::serialize() k: %y args: %y, parts: %y\n", k, keys args, msginfo.parts);
            if (msginfo.parts{k}) {
                any ct = msginfo.parts{k};
                if (ct.typeCode() == NT_LIST)
                    ct = shift ct;
                mpm.addPart(hv, sprintf("<%s>", k), ct);
                hv."^attributes^".href = "cid:" + k;
            }

            string en = args{k}.element ? (ons + ":" +  k) : k;
            rh{en} = hv;
        }

        if (rh) {
            if (encoded)
                rh."^attributes^" += (
                    "soapenv:encodingStyle": SOAP_ENCODING,
                    "xmlns:soapenc": SOAP_ENCODING,
                );

            hash rvh.("ns1:" + n_name) = rh;

            return rvh;
        }
    }

    *hash serializeDocument(*softlist key, any msginfo, any mpm, bool encoded, reference h) {
        hash rh;

        if (!key && args.size() == 1) {
            # deprecated, just for backward compatability
            string k = args.firstKey();
            if (h.typeCode() != NT_HASH || !h.hasKey(k)) {
                hash nh;
                nh{k} = h;
                h = nh;
            }
        }
        foreach string k in (key ? key : keys args) {
            any val = getValueFromHash(k, \h, True);
            if (!exists val) {
                if (key || args.size() == 1) {
                    val = getValueFromHash(args{k}.element, \h, True);
                }
                if (val.typeCode() == NT_NULL) {
                    val = NOTHING;
                } else {
                    if (!exists val) continue;
                }
            }
            if (val.typeCode() == NT_HASH)
                XsdBase::removeNS2(\val);
            string ons;
            any th;
            if (args{k}.element) {
                th = args{k}.element.serialize(val, !encoded, k, name);
                ons = nsc.getOutputNamespacePrefix(args{k}.element.ns);
                rh.(ons + ":" + args{k}.element.name) = th;
            } else {
                th = args{k}.type.serialize(val, !encoded);
                #ons = args{k}.type.getOutputNamespacePrefix();
                rh.("ns1:" + args{k}.name) = th;
            }
        }

        if (encoded && rh)
            rh."^attributes^" += (
                "soapenv:encodingStyle": SOAP_ENCODING,
                "xmlns:soapenc": SOAP_ENCODING,
            );

        #printf("DEBUG: message %s: force_ns: %y args: %y h: %y\n", name, force_ns, keys args, h);

        return rh;
    }

    #! deserialize RPC message
    /**
    @param val, keys are element names or part names for simple types
    @param key if exists then deserialize only particular element/type
    @return serialized data, keys are wsdl element names (optionally part name is also possible) and part names for simple types
    */
    *hash deserializeRpc(*hash mrh, hash val, *string key) {
        #printf("DBG WSMessage::deserializeRpc() args: %y pmap: %y key: %y val: %y\n", args.keys(), pmap, key, val);
        hash ro;

        foreach string k in (exists key ? key : args.keyIterator()) {

            bool present = val.hasKey(k);
            any v = remove val{k};
            if (v.typeCode() == NT_HASH)
                XsdBase::removeNS2(\v);

            ro{args{k}.part ?? k} = args{k}.element
                ? args{k}.element.deserialize(tmap, mrh, getValue(mrh, v), present)
                : args{k}.type.deserialize(name, tmap, mrh, getValue(mrh, v));
        }

        if (val && !exists key)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("additional keys %y included in %y message hash", val.keys(), name);

        # if there is only one argument, return it directly
        return ro;
    }

    *hash deserializeDocument(*hash mrh, any val, *string key) {
        hash rh;

        *hash attr = remove val."^attributes^";

        #printf("DBG WSMessage::deserializeDocument() args: %y val: %y\n", args.keys(), val);

        if (args.size() == 1) {
            string k = args.firstKey();
            if (val.typeCode() != NT_HASH || !val.hasKey(k)) {
                any v = val;
                val = hash();
                val{k} = v;
            }
        }

        foreach string k in (exists key ? key : args.keyIterator()) {
            bool present = val.hasKey(k);
            any v = remove val{k};
            XsdBase::removeNS2(\v);

            rh{args{k}.part ?? k} = args{k}.element ?
                args{k}.element.deserialize(tmap, mrh, v, present) :
                args{k}.type.deserialize(name, tmap, mrh, getValue(mrh, v));
        }

        if (val && !exists key)
            throw SOAP_DESERIALIZATION_ERROR, sprintf("additional keys %y included in %y message hash", val.keys(), name);

        #printf("DBG WSMessage::deserializeDocument() args: %y val: %y\nRH: %y\n", args.keys(), val, rh);
        return rh;
    }

    #! serialize all values as string or binary
    /**
        @return hash of all parts in key-value pair
    */
    hash serializeAllPartData(*hash val) {
        hash rv;
        foreach string k in (args.keyIterator()) {
            hash v = serializeData(k, val);
            rv{k} = v.value;
        }
        return rv;
    }

    #! serialized value of particular type value as string or binary
    /**
        @param val value to be resolved
        @param key member name, it is requires reference to a simple type, not compaund element

        @return as hash with 'value' and optional 'content-type' key passed from v.content-type if exists
     */
    hash serializeData(string key, *hash val) {
        if (args{key}.element) {
            throw SOAP_SERIALIZATION_ERROR, sprintf("cannot get element value %y in message %y. Type part is needed", key, name);
        }
        any v = getValueFromHash(key, \val, False);
        hash rv.value = args{key}.type.serialize(v, False){"^value^"};
        if (v.typeCode() == NT_HASH) {
            rv."content-type" = v."^attributes^"."^content-type^";
        }
        return rv;
    }

    #! deserialize value in string or binary form
    /**
        @return hash in key-value pair
    */
    hash deserializeData(string key, hash val) {
        hash rv;
        rv{args{key}.part ?? key} = args{key}.element
            ? args{key}.element.deserialize(tmap, NOTHING, val{key}, val.hasKey(key))
            : args{key}.type.deserialize(name, tmap, NOTHING, val{key});
        return rv;
    }

    #! deserialize all values in string or binary form
    /**
        @return hash of all parts in key-value pair
    */
    hash deserializeAllPartData(hash val) {
        *hash rv;
        foreach string k in (args.keyIterator()) {
            rv += deserializeData(k, val);
        }
        return rv;
    }

    #! find part in value, remove that value from
    /**
        @param ename element/type name
        @param reference to hash, supposed structure is [msgname.](partname|elemname) = value to support more message data in one hash
        @param removeFound if True found values are remove from hash

        @return resolved value, if not found then returns NOTHING
    */
    /* private in module*/any getValueFromHash(string ename, reference v, bool removeFound) {
        any rv;
        string k;
        # there is not unique part name space as it may contain more messages in one hash so let's do a little heuristic
        if (exists v{name}) {
            if (args{ename}.part && exists v{name}{args{ename}.part}) {
                k = args{ename}.part;
            } else if (exists v{name}{ename}) {
                k = ename;
            }
            if (k) {
                rv = v{name}{k};
                if (removeFound) {
                    remove v{name}{k};
                    if (!v{name}) {
                        remove v{name};
                    }
                }
            }
        }
        if (!k) {
            if (args{ename}.part && exists v{args{ename}.part}) {
                k = args{ename}.part;
            } else if (exists v{ename}) {
                k = ename;
            }
            if (k) {
                rv = v{k};
                if (removeFound) {
                    remove v{k};
                    if (!v{name}) {
                        remove v{name};
                    }
                }
            }
        }
        return rv;
    }

    #! when only one arg then try get values based on element keys
    /* private in module*/any getValueFromHash(*WSDL::XsdElement element, reference v, bool removeFound) {
        if (!element) return;
        if (element.type instanceof WSDL::XsdComplexType) {
            hash rv;
            if (!cast<WSDL::XsdComplexType>(element.type).elementmap) {
                # special case, empty complex type
                return NULL;
            } else {
                foreach my string ename in (keys cast<WSDL::XsdComplexType>(element.type).elementmap) {
                    any val = getValueFromHash(ename, \v, removeFound);
                    if (exists val) {
                        rv{ename} = val;
                    }
                }
            }
            return rv;
        }
    }

    #! check if pname is defined as message part
    /** @return translated part name to element/type name */
    /*private in module*/string checkPart(string pname) {
        if (!pmap{pname}) {
            throw sprintf("%y is unknown part in message %y, defined parts: %y", pname, name, keys pmap);
        }
        return pmap{pname};
    }

}

# private helper class for lazy name resolution
class WSDL::XsdLateResolverHelper {
    private { list l = (); }

    constructor() {
    }

    add(any v) {
        l += v;
    }

    list getList() {
        return l;
    }

    clearResolved() {
        l = map $1, l, !isResolved($1);
    }

    bool isResolved(XsdSimpleType t) {
        return t.type instanceof XsdData;
    }

    bool isResolved(XsdTypedData t) {
        return t.type instanceof XsdData;
    }

    bool isResolved(XsdComplexType t) {
        return t.simpleType instanceof XsdData;
    }

    bool isResolved(any t) {
        return False;
    }
}

#! class for WSDL bindings
public class WSDL::Binding inherits WSDL::XsdNamedData {
    private {
        string port;
        bool docstyle = False;
        *string httpMethod;
        *string soapTransport;
    }

    constructor(hash data, Namespaces nsc, reference portTypes, reference idocmap, *hash messages) : XsdNamedData(\data) {
        # get binding attributes
        {
            *hash ba = data."^attributes^";

            (*string ns, *string prt) = ba.type =~ x/(?:(\w+):)?(\w+)/;
            if (!prt)
                throw WSDL_ERROR, sprintf("missing port type for binding %y", name);
            port = prt;
        }

        if (data.binding) {
            *hash bba = data.binding."^attributes^";
            if (bba.verb) {
                # HTTP binding
                httpMethod = bba.verb;
            }

            if (bba.transport) {
                # SOAP binding
                if (!SOAP_TRANSPORT.(bba.transport))
                    throw WSDL_ERROR, sprintf("unsupported transport %y in binding %y (known transports: %y)", bba.transport, name, SOAP_TRANSPORT.keys());
                soapTransport = bba.transport;
            }
            if (!soapTransport && !httpMethod)
                throw WSDL_ERROR, sprintf("missing SOAP verb or transport in binding %y (known SOAP transports: %y)", name, SOAP_TRANSPORT.keys());

            if (bba.style == "document") {
                docstyle = True;
            }
        }

        foreach hash ophash in (data.operation) {
            string opname = ophash."^attributes^".name;
            if (!exists portTypes{port}.operations{opname})
                throw WSDL_ERROR, sprintf("binding %y references unknown porttype %y operation %y", name, port, opname);

            hash op;
            op.name = opname;
            WSDL::XsdBase::removeNS(\ophash);

            *string sa = ophash.operation."^attributes^".soapAction;
            if (exists sa) {
                #printf("GOT: %s sa: %y\n", opname, sa);
                op.soapAction = sa;
            } else {
                *string op_ns = portTypes{port}.operations{opname}.nsc.getTargetNamespaceUri();
                if (op_ns && op_ns !~ /\/$/)
                    op_ns += "/";
                op.soapAction = op_ns ? op_ns + opname : opname;
            }

            if (docstyle || ophash.operation."^attributes^".style == "document") {
                op.docstyle = True;
                portTypes{port}.operations{opname}.setDocStyle(\idocmap);  # TODO
            }

            if (httpMethod) {
                *string loc = ophash.operation."^attributes^".location;
                if (loc) {
                    op.location = loc;
                } else {
                    throw WSDL_ERROR, sprintf("location is missing binding %y, operation %y", name, opname);
                }
            }

            foreach string io in (("input", "output")) {
                if (ophash{io}) {
                    WSDL::XsdBase::removeNS(\ophash{io});
                    if (!exists portTypes{port}.operations{opname}{io}) {
                        hash hk;
                        map hk{$1}=True, keys ophash{io};
                        remove hk.("header", "ns");
                        if (hk)
                            throw WSDL_ERROR, sprintf("binding %y for operation %y does not reference %s message in porttype %y",  name, opname, io, port);
                    }
                    if (exists ophash{io}.body) {
                        *hash pa = ophash{io}.body."^attributes^";
                        op{io}.body.encoded = pa.use == "encoded";
                        op{io}.body.namespace = pa.namespace;
                        op{io}.encodingStyle = pa.encodingStyle;
                        op{io}.body.parts = pa.parts;

                        delete ophash{io}.body;
                    }

                    if (exists ophash{io}.multipartRelated) {
                        if (exists op{io}.body)
                            throw WSDL_ERROR, sprintf("%s binding %y for operation %y specifies both body and multipart elements", io, name, opname);

                        op{io}.multipart = Mime::MPT_RELATED;
                        op{io}.parts = {};
                        WSDL::XsdBase::removeNS(\ophash{io}.multipartRelated);

                        if (!exists ophash{io}.multipartRelated.part)  # TODO: do I need explicite check or is handled by validator ?
                            throw WSDL_ERROR, sprintf("binding %y is missing part definition(s) in %s message definition for operation %y: %y", name, io, opname, ophash);

                        foreach any part in (ophash{io}.multipartRelated.part) {
                            WSDL::XsdBase::removeNS(\part);
                            #any a = part."^attributes^";
                            part -= "^attributes^";
                            if (exists part.body) {
                                if (exists op{io}.body)
                                    throw WSDL_ERROR, sprintf("%s binding %y for operation %y specifies multiple body parts in multipart elements", io, name, opname);
                                any pa = part.body."^attributes^";
                                if (pa.use != "literal")
                                    throw WSDL_ERROR, sprintf("unsupported body part without use=\"literal\": %y", part.body);

                                op{io}.body.parts = pa.parts;

                            } else if (exists part.content) {
                                *string pcname;
                                foreach any c in (part.content) {
                                    WSDL::XsdBase::removeNS(\c);
                                    any pa = c."^attributes^";
                                    any name = pa.part;
                                    if (!exists name)
                                        throw WSDL_ERROR, sprintf("unsupported content part without part attribute: %y", c);
                                    if (pcname) {
                                        if (pcname != name)
                                            throw WSDL_ERROR, sprintf("multiple content part names inside part section: %y!=%y", name, pcname);
                                    } else {
                                        pcname = name;
                                        name = portTypes{port}.operations{opname}{io}.checkPart(name);
                                    }
                                    any type = pa.type;
                                    if (!exists type)
                                        throw WSDL_ERROR, sprintf("unsupported content part without type attribute: %y", c);

                                    if (!exists op{io}.parts{name})
                                        op{io}.parts{name} = type;
                                    else {
                                        if (op{io}.parts{name}.typeCode() != NT_LIST)
                                            op{io}.parts{name} = list(op{io}.parts{name});
                                        op{io}.parts{name} += type;
                                    }
                                }
                            } else
                                throw WSDL_ERROR, sprintf("cannot parse part: %y", part);

                                #printf("DEBUG: part: %y\nmsg: %y\n", part, op{io});;
                        }
                        delete ophash{io}.multipartRelated;
                    }


                    if (op{io}.body.parts) {
                        op{io}.body.parts = op{io}.body.parts.split(" ");  # NMTOKENS
                        foreach string p in (\op{io}.body.parts) {
                            p = portTypes{port}.operations{opname}{io}.checkPart(p);
                        }
                    }

                    if (exists ophash{io}.header) {
                        foreach hash hdr in (ophash{io}.header) {
                            *hash ma = hdr."^attributes^";

                            if (!ma.message)
                                throw WSDL_ERROR, sprintf("%s binding %y for operation %y specifies a soap header element without a 'message' attribute (attr: %y)", io, name, opname, ma);

                            hash h = nsc.doType(ma.message);
                            *WSMessage msg = messages.(h.val);
                            if (!exists msg)
                                throw WSDL_ERROR, sprintf("%s binding %y for operation %y references unknown message %y in the soap header element", io, name, opname, h.val);

                            ma.part = checkMessagePart(msg, ma.part, sprintf("header %s operation %y", io, opname));
                            ma.encoded = ma.use == "encoded";
                            ma.msg = msg;

                            #printf("DEBUG: match part to message: %y, part: %y\n", msg.name, ma.part);
                            if (op{io}.header) {
                                if (op{io}.header.typeCode() != NT_LIST) {
                                    op{io}.header = () + op{io}.header;
                                }
                                op{io}.header += ma;
                            } else {
                                op{io}.header = ma;
                            }
                        }
                        delete ophash{io}.header;
                    }

                    if (ophash{io}.hasKey("urlReplacement")) {
                        string loc = op.location;
                        int i = 0;
                        hash l;
                        while (i < loc.size()) {
                            int j = index(loc, "(", i);
                            if (j < 0) {
                                j = loc.size();
                            }
                            if (j > i) {
                                l{sprintf("string^%d", l.size()+1)} = substr(loc, i, j-i);
                            }
                            if (j < loc.size()) {
                                i = j+1;
                                j = index(loc, ")", i);
                                if (j == i) {
                                    throw WSDL_ERROR, sprintf("empty replace token in %y near %y", loc, substr(loc, i-1, loc.size()));
                                } else if (j < 0) {
                                    throw WSDL_ERROR, sprintf("missing close parentheses in %y near %y", loc, substr(loc, i-1, loc.size()));
                                }
                                string p = substr(loc, i, j-i);
                                # if (messages)   TODO test messages / part here probably not ?
                                l{sprintf("part^%d", l.size()+1)} = p;
                                j++;
                            }
                            i = j;
                        }
                        op{io}.urlReplacement = l;
                        delete ophash{io}.urlReplacement;
                    }

                    if (ophash{io}.hasKey("urlEncoded")) {
                        op{io}.urlEncoded = True;
                        delete ophash{io}.urlEncoded;
                    }

                    if (exists ophash{io}.content) {
                        op{io}.content.acceptedContentTypes = ();  # type / *
                        op{io}.content.acceptedContentTypeSubtypes = ();  # type / subtype
                        *string p;
                        foreach any cnt in (ophash{io}.content) {
                            WSDL::XsdBase::removeNS(\cnt);
                            cnt = remove cnt."^attributes^";
                            bool isFormUrlEncoded = cnt.type == MimeTypeFormUrlEncoded;
                            if ((isFormUrlEncoded && op{io}.content.type) ||
                                (!isFormUrlEncoded && op{io}.content.formUrlEncoded)) {
                                throw WSDL_ERROR, sprintf("%y content type must be single in message %y", MimeTypeFormUrlEncoded, ophash{io}.content);
                            }
                            if (isFormUrlEncoded) {
                                op{io}.content.formUrlEncoded = True;
                                continue;
                            }
                            if (!cnt.type || cnt.type == "*/*") {
                                op{io}.content.acceptAllContentTypes = True;
                            } else {
                                hash act;
                                list st = cnt.type.split("/");
                                if (st.size() != 2) {
                                    throw WSDL_ERROR, sprintf("Content type %y does not match 'type/subtype' pattern", cnt.type);
                                }
                                if (bindex(st[0], "*") != -1) {
                                    throw WSDL_ERROR, sprintf("Content type %y contains unexpected asterisk in type part", cnt.type);
                                }
                                act.type = st[0];
                                if (st[1] == "*") {
                                    push op{io}.content.acceptedContentTypes, st[0]+"/";
                                } else {
                                    if (bindex(st[1], "*") != -1) {
                                        throw WSDL_ERROR, sprintf("Content type %y contains unexpected asterisk in subtype part", cnt.type);
                                    }
                                    push op{io}.content.acceptedContentTypeSubtypes, st[0]+"/"+st[1];
                                }
                            }

                            cnt.part = checkMessagePart(portTypes{port}.operations{opname}{io}, cnt.part, sprintf("content %s operation %y", io, opname));
                            if (exists p) {
                                if (p != cnt.part) {
                                    throw WSDL_ERROR, sprintf("ambiguous part %y in message %y in binding %y for %s operation %y", cnt.part, portTypes{port}.operations{opname}{io}.name, name, io, opname);
                                }
                            } else {
                                op{io}.content.part = cnt.part;
                                p = cnt.part;
                            }
                        }

                        delete ophash{io}.content;
                    }

                    if (ophash{io}.hasKey("mimeXml")) {
                        op{io}.mimeXml.part = checkMessagePart(portTypes{port}.operations{opname}{io}, ophash{io}.mimeXml."^attributes^".part, sprintf("%s operation %y", io, opname));
                        delete ophash{io}.mimeXml;
                    }

                    delete ophash{io}.("^attributes^", "ns");

                    if (ophash{io}) {
                        throw WSDL_ERROR, sprintf("unknown element(s) in binding %y for %s operation %y: %y", name, io, opname, keys ophash{io});
                    }
                }
            }

            if (op.output.content.formUrlEncoded) {
                throw WSDL_ERROR, sprintf("%y type is not supported as output type in binding %y for output operation %y", MimeTypeFormUrlEncoded, name, opname);
            }

            portTypes{port}.operations{opname}.addBinding(name,
                (
                "httpMethod": httpMethod,
                "soapTransport": soapTransport,
                ) + op
            );
        }

        #binding = data;
    }

    #! check if part exists in massage, if part is empty and message contains single part then return it otherwise raise exceptio
    private:internal string checkMessagePart(WSMessage msg, *string partname, string errs) {
        if (exists partname) {
            return msg.checkPart(partname);
        }
        if (msg.pmap.size() == 1) {  # some args may be defined without part name so use pmap to test
            return msg.args.firstKey();
        } else {
            throw WSDL_ERROR, sprintf("to resolve default part neme in message %y requires just one defined part, binding %y, %s", msg.name, name, errs);
        }
    }

    string getPort() {
        return port;
    }
/*
    bool isSoapBinding() {
        return exists soapTransport;
    }

    bool isHttpBinding() {
        return exists httpMethod;
    }
    */
}

# private namespace prefix redefinition class
class WSDL::NamespacePrefixHelper {
    public {
    }

    private {
        Namespaces nsc;

        # overriden prefixes
        hash h;

        # overridden target namespace
        bool targ_ns;

        # overridden default namespace
        bool def_ns;
    }

    constructor(Namespaces n_nsc, *hash nsattr) {
        nsc = n_nsc;

        if (nsattr) {
            nsc.addNamespaces(nsattr, self);
            if (nsattr.targetNamespace) {
                nsc.pushTargetNamespace(nsattr.targetNamespace);
                targ_ns = True;
            }
            if (nsattr.xmlns) {
                nsc.pushDefaultNamespace(nsattr.xmlns);
                def_ns = True;
            }
        }
    }

    destructor() {
        if (def_ns)
            nsc.popDefaultNamespace();
        if (targ_ns)
            nsc.popTargetNamespace();
        if (h)
            nsc.restorePrefixes(h);
    }

    save(string k, string v) {
        h{k} = v;
    }
}

#! namespace container class
public class WSDL::Namespaces {
    public {
    }

    private {
        #! maps output namespace prefixes to namespace URIs
        hash ns = (
            "xsd": XSD_NS,
            );

        #! maps namespace URIs to output namespace prefixes
        hash nsr = (
            XSD_NS: "xsd",
            );

        #! hash for valid XSD namespaces, maps input namespace prefixes -> True if it refers to an XSD schema
        hash xsd_schema = (
            "xsd": True,
            );

        #! hash mapping input namespace prefixes to namespaces URIs
        hash imap = (
            "xsd": XSD_NS,
            );

        #! hash mapping input namespace URIs to input namespace prefixes
        hash imapr = (
            XSD_NS: "xsd",
            );

        #! integer providing a sequence for output namespace prefixes
        int nsn;

        #! if True then has SOAP 1.1
        bool hassoap11 = False;

        #! if True then has SOAP 1.2
        bool hassoap12 = False;

        #! current target namespace
        *string target_ns;

        #! target namespace stack;
        list nss = ();

        #! default namespace for unprefixed definitions
        *string default_ns;

        #! default namespace stack;
        list dss = ();
    }

    #! creates the object with the WSDL definitions attribute hash
    constructor(hash nsh, *Namespaces nsc) {
        nsn = nsc ? nsc.nsn : 1;

        if (nsh.targetNamespace)
            target_ns = nsh.targetNamespace;

        # set default namespace for unprefixed definitions
        if (nsh.xmlns)
            default_ns = nsh.xmlns;

        #printf("*** DEBUG: Namespaces::constructor() nsh: %y imap: %y\n", nsh, imap);
        addNamespaces(nsh);
        #printf("*** DEBUG: Namespaces::constructor() imap: %y\n", imap);
    }

    *string getDefaultNs() {
        return default_ns;
    }

    addNamespaces(hash nsh, *NamespacePrefixHelper nph) {
        foreach string k in (nsh.keyIterator()) {
            *string ns = (k =~ x/xmlns:(\w+)/)[0];

            if (!ns)
                continue;

            if (imap{ns}) {
                # ignore if the definition is the same
                if (imap{ns} == nsh{k})
                    continue;

                if (nph) {
                    string ov = imap{ns};
                    if (imapr{ov} == target_ns)
                        remove imapr{ov};
                    if (nsh{ns} == XSD_NS)
                        remove xsd_schema{ns};
                    nph.save(ns, ov);
                }
                else
                    throw "WSDL-NAMESPACE-ERROR", sprintf("namespace prefix %y defined twice", ns);
            }
            addNamespaceIntern(ns, nsh{k});
        }
    }

    restorePrefixes(hash h) {
        map addNamespaceIntern($1.key, $1.value, True), h.pairIterator();
    }

    private addNamespaceIntern(string ns, string val, *bool override) {
        imap{ns} = val;

        if (override || !imapr{val})
            imapr{val} = ns;

        if (val == XSD_NS)
            xsd_schema{ns} = True;

        if (!hassoap11 && val == SOAP_11_NS)
            hassoap11 = True;

        if (!hassoap12 && val == SOAP_12_NS)
            hassoap12 = True;
    }

    #! merges namespaces when parsing imported schemas
    merge(Namespaces nsc) {
        nsn = nsc.nsn;
        foreach string k in (nsc.ns.keyIterator()) {
            string v = nsc.ns{k};

            if (ns{k}) {
                if (ns{k} == v)
                    continue;
                throw "WSDL-NAMESPACE-ERROR", sprintf("imported schema uses prefix %y to refer to %y, however this prefix was previously defined with %y", k, v, ns{k});
            }
            if (!nsr{v}) {
                ns{k} = v;
                nsr{v} = k;
            }
        }
        # merge input namespace mappings
        foreach string k in (nsc.imap.keyIterator()) {
            string v = nsc.imap{k};
            if (imap{k}) {
                if (imap{k} == v)
                    continue;
                throw "WSDL-NAMESPACE-ERROR", sprintf("imported schema uses prefix %y to refer to %y, however this prefix was previously defined with %y", k, v, imap{k});
            }
            imap{k} = v;
        }
    }

    #! returns the namespace URI for the given output namespace prefix
    string getOutputNamespaceUri(string nsp) {
        *string n_ns = ns{nsp};
        if (!n_ns)
            throw "WSDL-NAMESPACE-ERROR", sprintf("output namespace prefix %y is unknown (known output namespace prefixes: %y)", nsp, ns.keys());
        return n_ns;
    }

    #! returns a hash of namespace attributes for outgoing SOAP messages
    *hash getOutputNamespaceHash(*hash nsh) {
        hash h;
        map h.("xmlns:" + $1.key) = $1.value, ns.pairIterator();

        foreach string k in (nsh.keyIterator()) {
            string xs = "xmlns:" + k;
            if (h{xs}) {
                if (h{xs} != nsh{k})
                    throw "WSDL-NAMESPACE-ERROR", sprintf("namespace %y has already been added automatically as %y and therefore cannot be overridden as %y", k, h{xs}, nsh{k});
            }
            else
                h{xs} = nsh{k};
        }

        return h;
    }

    #! returns the primary target namespace Uri
    *string getTargetNamespaceUri() {
        return target_ns;
    }

    #! returns the namespace URI for the given prefix or the target namespace Uri
    *string getNamespaceUri(*string nsp) {
        if (exists nsp)
            return getInputNamespaceUri(nsp);
        return getTargetNamespaceUri();
    }

    #! pushes the current target namespace URI on the stack when parsing schemas and sets the current target namespace URI to the current value
    pushTargetNamespace(string ns) {
        nss += target_ns;
        target_ns = ns;
    }

    #! restores any previous target namespace URI from the stack to the current target namespace URI
    popTargetNamespace() {
        target_ns = pop nss;
    }

    #! pushes the current default namespace URI on the stack when parsing schemas and sets the current default namespace URI to the current value
    pushDefaultNamespace(string ns) {
        dss += default_ns;
        default_ns = ns;
    }

    #! restores any previous default namespace URI from the stack to the current default namespace URI
    popDefaultNamespace() {
        default_ns = pop dss;
    }

    #! looks up and registers a namespace if necessary, returns the namespace's prefix
    string getOutputNamespacePrefix(string ns) {
        *string nsa = nsr{ns};
        if (nsa)
            return nsa;
        return registerNamespaceIntern(ns);
    }

    #! looks up and registers a namespace if necessary, returns the namespace's prefix
    string getTargetNamespaceInputPrefix() {
        if (!target_ns)
            throw "NAMESPACE-ERROR", sprintf("no target namespace");
        return imapr{target_ns};
    }

    #! registers a namespace internally
    private string registerNamespaceIntern(string n_ns) {
        # create namespace prefix
        string nsa = sprintf("ns%d", nsn++);
        # register namespace in forward and reverse maps
        ns{nsa} = n_ns;
        nsr{n_ns} = nsa;

        return nsa;
    }

    #! returns a hash of namespace prefixes to namespaces URIs actually used
    *hash getReferencedNamespaceMap() {
        return ns;
    }

    #! returns True if using SOAP 1.1, False if not
    bool hasSoap11() {
        return hassoap11;
    }

    #! returns True if using SOAP 1.2, False if not
    bool hasSoap12() {
        return hassoap12;
    }

    #! returns True if if the input namespace prefix refers to the XSD namespace URI
    *bool isSchema(string ns) {
        return xsd_schema{ns};
    }

    #! returns the input namespace URI from the input namespace prefix
    string getInputNamespaceUri(string nsa) {
        *string rv = imap{nsa};
        if (!rv)
            throw "WSDL-NAMESPACE-ERROR", sprintf("input namespace %y is unknown (known input namespaces: %y)", nsa, imap.keys());
        return rv;
    }

    any doType(string t) {
        #printf("DEBUG: XsdBase::doType(%y)\n", t);
        (*string ns, *string type) = t =~ x/(\w+):(\w+)/;
        if (!type) {
            #printf("DEBUG: XsdBase::doType(%y) xsd: %y\n", t, default_ns);
            if (default_ns == XSD_NS)
                return new XsdBaseType(t, self);

            return ("val": t);
        }

        # if this is in the XML Schema namespace, then it's a base type
        if (xsd_schema{ns})
            return new XsdBaseType(type, self);

        return ("ns": getOutputNamespacePrefix(getInputNamespaceUri(ns)), "val": type);
    }

    #! returns the output namespace prefix for the given input namespace prefix
    string translateOutputNamespacePrefix(*string nsa) {
        return getOutputNamespacePrefix(getInputNamespaceUri(nsa));
    }
}

# private class
class WSDL::MapBase {
    public {}

    private {
        hash dh;
    }

    list keys() {
        return dh.keys();
    }

    AbstractIterator iterator() {
        return dh.iterator();
    }
}

# private class
class WSDL::TypeMap inherits WSDL::MapBase {
    add(XsdAbstractType t) {
        if (dh{t.name})
            throw WSDL_ERROR, sprintf("type %y declared twice", t.name);
        dh{t.name} = t;
    }

    XsdAbstractType get(string name) {
        if (!dh{name})
            throw WSDL_ERROR, sprintf("no such type %y; known types: %y", name, dh.keys());
        return dh{name};
    }

    *XsdAbstractType tryGet(string name) {
        return dh{name};
    }
}

# private class
class WSDL::ElementMap inherits WSDL::MapBase {
    add(XsdElement e) {
        string ns = e.ns;
        if (dh{ns}{e.name})
            throw WSDL_ERROR, sprintf("element %y declared twice in namespace %y", e.name, ns);
        dh{ns}{e.name} = e;
    }

    XsdElement get(string ns, string name) {
        if (!dh{ns})
            throw WSDL_ERROR, sprintf("no such namespace %y; known namespaces: %y", ns, dh.keys());
        if (!dh{ns}{name})
            throw WSDL_ERROR, sprintf("no such element %y in namespace %y; known elements: %y", name, ns, dh{ns}.keys());
        return dh{ns}{name};
    }

    *XsdElement tryGet(string ns, string name) {
        return dh{ns}{name};
    }
}

#! main class representing a parsed WSDL file
/** This is the main class for handling SOAP communication and is based on a WSDL file
*/
public class WSDL::WebService inherits WSDL::XsdBase {
    public {
        #! the WSDL string
        string wsdl;

        #! namespace container
        Namespaces nsc;

        hash base_type;
        list wsdl_services = ();
        hash idocmap;
        hash opmap;
        ElementMap emap();
        hash messages;
        TypeMap tmap();
        bool usedocns = False;
        hash portType;
        *code try_import;
        #! default path for retrieving XSD references
        *string def_path;
    }

    private {
        # service definitions; name -> service hash
        hash services;

        # service bindings; name -> hash
        hash binding;
    }

    #! creates the WebService object
    /** @param str the XML string representing the WSDL
        @param opts an optional hash of options with the following possible keys:
        - \c "def_path": the default path to use when retrieving referenced XSDs
        - \c "try_import": a call reference or closure to be passed a string name for XSD imports without any scheme to retrieve the data, must take a string argument (the resource name) and return a string (the resource data)
        - \c "http_client": a HTTPClient object for retrieving data from import commands
        - \c "http_headers": a hash of optional HTTP header info to use when retrieving data from import commands
    */
    constructor(string str, *hash opts) {
        hash h = parse_xml(str);

        # save WSDL text
        wsdl = str;

        try_import = opts.try_import;
        def_path = opts.def_path;

        # remove namespace (normally "wsdl:") prefix from keys if present
        WSDL::XsdBase::removeNS(\h);
        WSDL::XsdBase::removeNS(\h.definitions);
        nsc = new Namespaces(h.definitions."^attributes^");
        #getNSPrefixes(h.definitions."^attributes^");
        #printf("%y\n", h.definitions.types);

        if (exists h.definitions.types)
            parseTypes(h.definitions.types, opts.http_client instanceof HTTPClient ? opts.http_client : NOTHING, opts.http_headers);

        if (exists h.definitions.message)
            parseMessages(h.definitions.message);

        if (exists h.definitions.portType)
            parsePortType(h.definitions.portType);

        if (exists h.definitions.binding)
            parseBinding(h.definitions.binding);

        if (exists h.definitions.service)
            parseService(h.definitions.service);

    }

    #! returns the given operation or throws an exception if it cannot be found; operations are searched in portTypes in the order they are declared
    WSOperation getOperation(string opname) {
        foreach hash pt in (portType.iterator()) {
            if (pt.operations{opname})
                return pt.operations{opname};
        }
        list l = ();
        map l += $1.operations.keys(), portType.iterator();
        throw "WSDL-OPERATION-ERROR", sprintf("cannot retrieve operation %y; known operations: %y", opname, l);
    }

    #! returns the given operation for particular porttype or throws an exception if it cannot be found
    WSOperation getPortTypeOperation(string ptname, string opname) {
        *WSOperation op = portType{ptname}.operations{opname};
        if (op)
            return op;
        if (!portType{ptname})
            throw "WSDL-OPERATION-ERROR", sprintf("port %y is not a defined port; known ports: %y", ptname, portType.keys());
        throw "WSDL-OPERATION-ERROR", sprintf("operation %y is not known in port %y; known operations: %y", opname, ptname, portType{ptname}.operations.keys());
    }

    #! returns the given operation for particular binding or throws an exception if it cannot be found
    WSOperation getBindingOperation(*string bname, string opname) {
        if (!exists bname) {
            return getOperation(opname);
        } else {
            WSDL::Binding b = getBinding(bname);
            return getPortTypeOperation(b.getPort(), opname);
        }
    }

    #! returns a list of hashes giving supported operation names for each port in the WSDL
    /** @return a list of hashes giving supported operation names for each port in the WSDL; each hash has the following keys:
        - \c "port": the name of the port defining the operation
        - \c "operation": the @ref WSDL::WSOperation object for the operation
     */
    list listOperations() {
        list l = ();
        foreach hash ph in (portType.pairIterator()) {
            foreach WSOperation op in (ph.value.operations.iterator()) {
                l += (
                    "port": ph.name,
                    "operation": op,
                    );
            }
        }
        return l;
    }

    #! return a @ref WSDL::Binding object describing the requested binding
    /** @param name the name of the binding

        @return a @ref WSDL::Binding object

        @throw WSDL-BINDING-ERROR unknown binding
     */
    WSDL::Binding getBinding(string name) {
        *Binding b = binding{name};
        if (!b)
            throw "WSDL-BINDING-ERROR", sprintf("binding %y is not a known binding; known bindings: %y", name, binding.keys());
        return b;
    }

    #! returns a list of services defined in the WSDL
    /** @return a list of hashes of services defined in the WSDL; each hash has the following keys:
        - \c "name": the name of the service
        - \c "port": a hash of port information; the keys are port names and the values have the following keys:
        - \c "address": the location of the port
        - \c "binding": the binding of the port
     */
    list listServices() {
        return services.values();
    }

    #! returns a hash describing the requested service
    /** @param name the name of the service
        @return a hash describing the service with the following keys:
        - \c "name": the name of the service
        - \c "port": a hash of port information; where each hash is keyed by port name and the values have the following keys:
          - \c "address": the location of the port
          - \c "binding": the binding of the port

        @throw WSDL-SERVICE-ERROR the service is not known
     */
    hash getService(string name) {
        *hash h = services{name};
        if (!h)
            throw "WSDL-SERVICE-ERROR", sprintf("service %y is not a known service; known services: %y", name, services.keys());
        return h;
    }

    hash getType(string name, any v) {
        #printf("DBG getType() %y: %y\n", name, tmap);
        return ("^type^": tmap.get(name), "^val^": v);
    }

    private XsdBaseType getBaseType(string t) {
        if (exists base_type{t})
            return base_type{t};

        return base_type{t} = new XsdBaseType(t, nsc);
    }

    private resolveType(XsdSimpleType t) {
        throw "WSDL-TYPE-ERROR", sprintf("cannot resolve simpleType: %y type %y", t.name, t.type);
    }

    private resolveType(XsdElement xe) {
        if (xe.ref) {
            # find element
            (*string ns, string name) = (xe.ref =~ x/^(?:(\w+):)(\w+)$/);
            XsdElement e = emap.get(nsc.getNamespaceUri(ns), name);
            if (e.type.typeCode() == NT_HASH)
                resolveType(e);
            #printf("resolveType(XsdElement), resolved to e: %y type: %y\n", e.name, e.type.name);
            xe.assimilate(e);
            #throw "OOPS", sprintf("e: %y", xe);
        }
        else if (xe.type.typeCode() == NT_HASH) {
            xe.type = resolveType(xe.type);
            #printf("resolveType(XsdElement), %y\n", xe.type.name);
        }
    }

    private resolveType(XsdTypedData xd) {
        xd.type = resolveType(xd.type);
        #printf("resolveType(XsdTypedData), %y\n", xd.type.name);
    }

    private resolveType(XsdComplexType ct) {
        ct.simpleType = resolveType(ct.simpleType);
        #printf("resolveType(XsdComplexType), %y\n", ct.simpleType.name);
    }

    private XsdAbstractType resolveType(hash v) {
        XsdAbstractType rv;
        if (exists v.ns && nsc.isSchema(v.ns)) {
            rv = getBaseType(v.val);
        } else {
            # find type
            rv = tmap.get(v.val);
        }
        #printf("resolveType(hash), ns: %y, val: %y -> %y\n", v.ns, v.val, rv.name);
        return rv;
    }

    # parse XSD schema types
    private parseTypes(*hash data, any http_client, any http_headers) {
        #printf("DEBUG: parseTypes data: %y, http_client: %y, http_headers: %y\n", data, http_client, http_headers);
        WSDL::XsdBase::removeNS(\data);

        XsdLateResolverHelper unresolved();

        foreach *hash schema in (data.schema) {
            *hash sa = schema."^attributes^";
            #if (!sa)
            #    throw "OOPS";
            NamespacePrefixHelper nph(nsc, sa);

            bool usedocns = sa.elementFormDefault == "qualified";

            #printf("DEBUG: schema tn: %y\n", schema."^attributes^"."targetNamespace");
            WSDL::XsdBase::removeNS(\schema);
            #printf("DEBUG: WebService::parseTypes() schema: %y\n", schema);

            # process XSD import if present
            foreach hash import in (schema.import) {
                *hash a = import."^attributes^";
                # import file
                if (a.schemaLocation) {
                    hash h = parse_url(a.schemaLocation);
                    string xsd;
                    if (!h.protocol && try_import)
                        xsd = call_function(try_import, a.schemaLocation);
                    else
                        xsd = WSDLLib::getFileFromURL(a.schemaLocation, "file", http_client, http_headers, NOTHING, def_path);

                    # parse XML to Qore data structure ignoring XML element order
                    hash xh = parse_xml(xsd);

                    # parse namespace definitions in schema attributes
                    if (xh.size() != 1)
                        throw WSDL_ERROR, sprintf("expecing a single element indicating an XSD schema in the imported file; got instead: %y", xh.keys());

                    # get schema member name
                    any sk = xh.firstKey();

                    #printf("*** DEBUG %y: sk: %y a: %y\n", a.schemaLocation, sk, xh{sk}."^attributes^");

                    # use temporary Namespaces object for import
                    Namespaces n_nsc = nsc;
                    nsc = new Namespaces(xh{sk}."^attributes^", nsc);
                    on_exit
                        nsc = n_nsc;
                    on_success
                        n_nsc.merge(nsc);

                    # verify that the top-level key indicates an XSD schema definition
                    (*string ns, *string mem) = (sk =~ x/^(\w+):(\w+)$/);
                    if (ns && !nsc.isSchema(ns))
                        throw WSDL_ERROR, sprintf("expecing imported schema definition to be in XSD namespace %y, got %y: %y instead", XSD_NS, ns, nsc.getInputNamespaceUri(ns));

                    parseTypes(xh);
                }
            }

            foreach hash st in (schema.simpleType) {
                XsdSimpleType t(st, nsc, unresolved, usedocns);
                tmap.add(t);
                #printf("DEBUG: st: %y\n", t.name);
            }
            foreach hash ct in (schema.complexType) {
                XsdComplexType t(ct, nsc, unresolved, usedocns);
                tmap.add(t);
                #printf("DEBUG: ct: %y\n", t.name);
            }
            # make element map
            foreach any el in (schema.element) {
                any attr = el."^attributes^";
                XsdElement element;
                if (exists attr.type) {
                    any t = nsc.doType(attr.type);
                    if (!(t instanceof XsdData)) {
                        t = t.val;
                        hash eattr.name = attr.name;
                        *XsdAbstractType et = tmap.tryGet(t);
                        if (!et)
                            eattr.type = t;

                        #printf("DEBUG: adding element %y type %y\n", attr.name, t);
                        element = new WSDL::XsdElement(("^attributes^": eattr), nsc, et, unresolved, usedocns);
                    }
                    else {
                        #printf("DEBUG: adding element %y type %y\n", attr.name, t);
                        element = new WSDL::XsdElement(("^attributes^":("name":attr.name)), nsc, t, unresolved, usedocns);
                    }
                }
                else {
                    #printf("DEBUG: adding element %y\n", attr.name);
                    element = new WSDL::XsdElement(el, nsc, NOTHING, unresolved, usedocns);
                }

                emap.add(element);
            }
        }
        # resolve types
        map resolveType($1), unresolved.getList();
        unresolved.clearResolved();

        # finalize complex types
        foreach XsdAbstractType t in (tmap.iterator()) {
            if (!(t instanceof XsdComplexType))
                continue;

            cast<XsdComplexType>(t).finalize(tmap, nsc);
        }
        # finalize complex types in elements
        foreach hash eh in (emap.iterator()) {
            foreach XsdElement el in (eh.iterator()) {
                if (!(el.type instanceof XsdComplexType))
                    continue;

                XsdComplexType ct = el.type;
                ct.finalize(tmap, nsc);
            }
        }
 
        map resolveType($1), unresolved.getList();
    }

    private parseMessages(*softlist message) {
        # parse messages
        foreach hash m in (message) {
            WSMessage msg(m, emap, tmap, nsc);
            foreach string arg in (msg.args.keyIterator()) {
                #printf("DEBUG: WebService::parseMessages(): %y: %y\n", arg, msg);
                #printf("DEBUG: WebService::parseMessages(): %y: %y\n", arg, msg.args{arg}.type);
                if (exists msg.args{arg}.type && !(msg.args{arg}.type instanceof XsdData))
                    msg.args{arg}.type = resolveType(msg.args{arg}.type);
            }
            messages.(msg.name) = msg;
        }
    }

    private parseService(*softlist svcs) {
        foreach hash svc in (svcs) {
            WSDL::XsdBase::removeNS(\svc);
            string svcname = svc."^attributes^".name;
            foreach hash port in (svc.port) {
                WSDL::XsdBase::removeNS(\port);
                hash pa = port."^attributes^";
                string name = pa.name;
                services{svcname}.name = svcname;
                services{svcname}.port{name} = pa;
                services{svcname}.port{name}.address = port.address."^attributes^".location;

                if (!pa.binding)
                    throw WSDL_ERROR, sprintf("service %y port %y has no binding", svcname, name);

                (*string ns, *string bind) = pa.binding =~ x/(?:(\w+):)?(\w+)/;
                if (!bind)
                    throw WSDL_ERROR, sprintf("cannot parse service %y port %y binding: %y", svcname, name, pa.binding);

                if (!binding{bind})
                    throw WSDL_ERROR, sprintf("service %y port %y refers to non-existant binding %y; known bindings: %y", svcname, name, bind, binding.keys());

                services{svcname}.port{name}.binding = binding{bind};
            }
        }
    }

    private parsePortType(*softlist data) {
        # setup list of services defined in this WSDL
        foreach hash port in (data) {
            WSDL::XsdBase::removeNS(\port);
            #printf("DEBUG: portType: %y\n", port);
            string name = port."^attributes^".name;
            wsdl_services += name;
            foreach any p in (port.operation) {
                WSOperation op(p, tmap, nsc, messages);
                portType{name}.operations.(op.name) = op;
                #printf("DEBUG: %y registered operation %y\n", name, op.name);
                opmap.(op.name) = op;
            }
        }
    }

    private parseBinding(*softlist bindings) {
        foreach hash data in (bindings) {
            WSDL::Binding b(data, nsc, \portType, \idocmap, messages);
            binding.(b.getName()) = b;
        }
    }

    #! returns True if the WSDL describes a SOAP 1.2 service
    /** @return True if the WSDL describes a SOAP 1.2 service
    */
    bool isSoap12() {
        return nsc.hasSoap12();
    }

    #! returns the XML string for the WSDL
    /** @return the XML string for the WSDL
    */
    string getWSDL() {
        return wsdl;
    }

    #! returns the XML string for the WSDL, adjusting the URLs for binding locations depending on the caller
    /** @param base_url the url to be prepended before the service name;
                        it must include all the handler prefixes (like \c /SOAP)
                        to produce valid URL
        @return the XML string for the WSDL
     */
    string getWSDL(string base_url) {
        string wstr = wsdl;

        foreach hash sh in (services.iterator()) {
            foreach hash ph in (sh.port.iterator()) {
                wstr = replace(wstr, ph.address, base_url + "/" + sh.name);
            }
        }

        return wstr;
    }

    private string getOperationParams(WSMessage msg) {
        return sprintf("%s(%s)", msg.name, (foldl $1 + "," + $2, (keys msg.args)));
    }

    #! prepare a WebService report enumerating the services and operations of the WSDL, outputs to the output stream given as the first argument
    /** @param stream the output stream for the report data
        @param wsdl_name name of the WSDL, typically a file name

        @return human readable text report
    */
    getReport(StringOutputStream stream, *string wsdl_name) {
        StreamWriter w(stream);
        w.printf("wsdl: %s\n", wsdl_name);
        foreach hash svc in (listServices()) {
            w.printf("  service: %s\n", svc.name);
            foreach string port in (keys svc.port) {
                w.printf("    port: %s\n", port);
                w.printf("      binding: %s\n", svc.port{port}.binding.name);
                w.printf("      address: %s\n", svc.port{port}.address);
                hash pt = portType{svc.port{port}.binding.getPort()};
                w.printf("      operations:\n");
                foreach string name in (keys pt.operations) {
                    WSOperation op = pt.operations{name};
                    w.printf("        %s\n", name);
                    if (op.input) {
                        w.printf("          input: %s\n", getOperationParams(op.input));
                    }
                    if (op.output) {
                        w.printf("          output: %s\n", getOperationParams(op.output));
                    }
                }
            }
        }
    }

    #! prepare a WebService report enumerating the services and operations of the WSDL
    /** @param wsdl_name name of the WSDL, typically a file name

        @return human readable text report
    */
    string getReport(*string wsdl_name) {
        StringOutputStream stream();
        getReport(stream, wsdl_name);
        return stream.getData();
    }
}

#! helper class implementing sample message generation
/** This is the class for generating sample SOAP messages based on a WSDL file
*/
public class WSDL::WSMessageHelper {
    private {
        WebService ws;
        hash opts;
    }

    #! creates the WebService object
    /** @param _ws the object representing the WSDL
        @param _opts an optional hash of options with the following possible keys:
        - \c "comments": (bool) generate comments as values with ^comment^ key, default: False
        - \c "choices": (bool) generate choices as sub hashes ^choices^ key, default: False
        - \c "max_items" (int): max.number of array elements to output, default: 3
    **/
    const DefaultOpts = (
        "comments": False,
        "choices": False,
        "max_items": 3,
    );
    constructor(WebService _ws, *hash _opts) {
        ws = _ws;
        *hash h = _opts;
        map remove h{$1}, keys DefaultOpts;
        if (h) {
           throw "WSDL-HELPER-ERROR", sprintf("unknown options %y (known values: %y)", keys h, keys DefaultOpts);
        }
        opts = DefaultOpts + _opts;
        if (opts.max_items < 1) {
           throw "WSDL-HELPER-ERROR", sprintf("wrong 'max_items' value %y (condition: >=1)", opts.max_items);
        }
    }

    private hash getTypeInfo(XsdBaseType t) {
        hash res = (
            'xtype': t.name,
        );
        switch (t.name) {
            case "string":
            case "normalizedString":
            case "token":
                res.type = "string";
                res.value = "abc";
                break;
            case "anyUri":
                res.type = "string";
                res.value = "http://www.qore.com";
                break;
            case "byte":
            case "int":
            case "integer":
            case "long":
            case "negativeInteger":
            case "nonNegativeInteger":
            case "positiveInteger":
            case "nonPositiveInteger":
            case "short":
            case "unsignedLong":
            case "unsignedInt":
            case "unsignedShort":
            case "unsignedByte":
                res.type = "int";
                res.value = 123;
                break;
            case "boolean":
                res.type = "bool";
                res.value = True;
                break;
            case "base64Binary":
            case "hexBinary":
                res.type = "binary";
                res.value = "<0feba023ffdca6291>";   # TODO: how assign binary const ?
                break;
            case "decimal":
                res.type = "number";
                res.value = 123.456;
                break;
            case "date":
                res.type = "date";
                res.value = 2015-01-31;
                break;
            case "dateTime":
                res.type = "date";
                res.value = 2015-01-31T10:20:30+01:00;
                break;
            case "time":
                res.type = "date";
                res.value = 10:20:30Z;
                break;
            case "duration":
                res.type = "date";
                res.value = P5Y2M10DT15H;   # TODO
                break;
        }
        return res;
    }

    private hash getTypeInfo(XsdSimpleType t) {
        hash res;
        if (t.type) {
            res = getTypeInfo(t.type);
            res.xtype = t.name;
            if (t.enum) {
                switch (res.type) {
                case "string":
                    res.value = (keys t.enum)[0];
                    break;
                case "int":
                    res.value = sprintf("%s", (keys t.enum)[0]);
                    break;
                default:
                    res.value = sprintf("%s", (keys t.enum)[0]);
                }
                res.comment = sprintf("Enum: %s",  (keys t.enum).join(','));
            }
        } else {
            res.xtype = t.name;
        }
        return res;
    }

    private hash getTypeInfo(XsdComplexType t) {
        hash res;
        if (t.elementmap) {
            res.type = "hash";
        } else if (t.simpleType) {
            res = getTypeInfo(t.simpleType);
        }
        res.attrs = exists t.attrs;
        return res;
    }

    hash getMessage(XsdElement elem, *softlist comments) {
        hash vi = getTypeInfo(elem.type);
        any val;

        if (opts.comments) {
            if (elem.minOccurs == 0) {
                comments += "optional";
            }
            if (elem.minOccurs > 1) {
                comments += sprintf("minOccurs:%d", elem.minOccurs);
            }
            if (elem.maxOccurs > 1 || elem.maxOccurs < 0) {
                comments += sprintf("maxOccurs:%d", elem.maxOccurs);
            }
        }
        if (vi.type) {
            if (vi.type == 'hash') {
                val = hash();
                foreach string name2 in (keys elem.type.elementmap) {
                    val += getMessage(elem.type.elementmap{name2});
                }
                foreach hash choice in (elem.type.choices) {
                    if (opts.choices) {
                        hash ch;
                        int j = 1;
                        foreach string name2 in (keys choice.elementmap) {
                            ch += getMessage(choice.elementmap{name2}, opts.comments ? sprintf("choice[%d]", j) : NOTHING);
                            j++;
                        }
                        val{sprintf("^choices%d^", $#+1)} = ch;
                    } else {
                        val += getMessage(choice.elementmap.firstValue(), opts.comments ? sprintf("choice[1/%d]", elem.type.choices.size()) : NOTHING);
                    }
                }
            } else {
                if (opts.comments && vi.comment) {
                    comments += vi.comment;
                }
                val = vi.value;
            }
        }

        any v;
        if (comments || vi.attrs) {
            v = hash();
            if (comments) {
                v{'^comment^'} = comments.join(';');
            }
            if (vi.attrs) {
                v{'^attributes^'} = ();
                foreach string name2 in (keys elem.type.attrs) {
                    hash vi2 = getTypeInfo(elem.type.attrs{name2}.type);
                    if (vi2.type) {
                        v{'^attributes^'}{name2} = vi2.value;
                    }
                }
            }
            if (exists val) {
                if (vi.type == 'hash') {
                    v += val;
                } else {
                    v{'^value^'} = val;
                }
            }
        } else {
            v = val;
        }
        *softint n = elem.maxOccurs;
        if (n == -1 || n > opts.max_items) {
            n = opts.max_items;
        }
        if (n > 1) {
            list l;
            int i = 1;
            while (i <= n) {
                if (comments) {
                    v{'^comment^'} = ( list(sprintf("#%d", i))+comments).join(';');
                }
                push l, v;
                i++;
            }
            return (elem.name: l);
        } else {
            return (elem.name: v);
        }
    }

    #! prepare sample message
    /** @param name message name

        @return a hash representing message
    */
    hash getMessage(string name) {
        return getMessage(ws.idocmap{name});
    }

    #! prepare sample message
    /** @param msg WSMessage object

        @return a hash representing message
    */
    hash getMessage(WSMessage msg) {
        return getMessage(msg.args.firstValue().element);
    }
}
