/* -*- mode: c++; indent-tabs-mode: nil -*- */
/** @file ql_xml.qpp defines XML functions */
/*
  ql_xml.qpp

  Qore XML functions

  Qore Programming Language

  Copyright 2003 - 2017 Qore Technologies, s.r.o.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include "qore-xml-module.h"

#include "QC_XmlDoc.h"
#include "QoreXmlReader.h"
#include "QoreXmlRpcReader.h"
#include "ql_xml.h"
#include "MakeXmlOpts.h"

#include <libxml/xmlwriter.h>

#include <string.h>
#include <memory>

// list of libxml2 element type names
static const char* xml_element_type_names[] = {
   "XML_ELEMENT_NODE",
   "XML_ATTRIBUTE_NODE",
   "XML_TEXT_NODE",
   "XML_CDATA_SECTION_NODE",
   "XML_ENTITY_REF_NODE",
   "XML_ENTITY_NODE",
   "XML_PI_NODE",
   "XML_COMMENT_NODE",
   "XML_DOCUMENT_NODE",
   "XML_DOCUMENT_TYPE_NODE",
   "XML_DOCUMENT_FRAG_NODE",
   "XML_NOTATION_NODE",
   "XML_HTML_DOCUMENT_NODE",
   "XML_DTD_NODE",
   "XML_ELEMENT_DECL",
   "XML_ATTRIBUTE_DECL",
   "XML_ENTITY_DECL",
   "XML_NAMESPACE_DECL",
   "XML_XINCLUDE_START",
   "XML_XINCLUDE_END",
   "XML_DOCB_DOCUMENT_NODE"
};

#define XETN_SIZE (sizeof(xml_element_type_names) / sizeof(char*))

static const char* xml_node_type_names[] = {
    "XML_NODE_TYPE_NONE",
    "XML_NODE_TYPE_ELEMENT",
    "XML_NODE_TYPE_ATTRIBUTE",
    "XML_NODE_TYPE_TEXT",
    "XML_NODE_TYPE_CDATA",
    "XML_NODE_TYPE_ENTITY_REFERENCE",
    "XML_NODE_TYPE_ENTITY",
    "XML_NODE_TYPE_PROCESSING_INSTRUCTION",
    "XML_NODE_TYPE_COMMENT",
    "XML_NODE_TYPE_DOCUMENT",
    "XML_NODE_TYPE_DOCUMENT_TYPE",
    "XML_NODE_TYPE_DOCUMENT_FRAGMENT",
    "XML_NODE_TYPE_NOTATION",
    "XML_NODE_TYPE_WHITESPACE",
    "XML_NODE_TYPE_SIGNIFICANT_WHITESPACE",
    "XML_NODE_TYPE_END_ELEMENT",
    "XML_NODE_TYPE_END_ENTITY",
    "XML_NODE_TYPE_XML_DECLARATION",};

#define XNTN_SIZE (sizeof(xml_node_type_names) / sizeof(char*))

const char* get_xml_element_type_name(int t) {
   return (t > 0 && t <= (int)XETN_SIZE) ? xml_element_type_names[t - 1] : 0;
}

const char* get_xml_node_type_name(int t) {
   return (t > 0 && t <= (int)XNTN_SIZE) ? xml_node_type_names[t - 1] : 0;
}

#if 0
// does not work well, produces ugly, uninformative output
static void qore_xml_structured_error_func(ExceptionSink* xsink, xmlErrorPtr error) {
   QoreStringNode* desc = new QoreStringNode;

   if (error->line)
      desc->sprintf("line %d: ", error->line);

   if (error->int2)
      desc->sprintf("column %d: ", error->int2);

   desc->concat(error->message);
   desc->chomp();

   if (error->str1)
      desc->sprintf(", %s", error->str1);

   if (error->str2)
      desc->sprintf(", %s", error->str1);

   if (error->str3)
      desc->sprintf(", %s", error->str1);

   xsink->raiseException("PARSE-XML-EXCEPTION", desc);
}
#endif

#ifdef HAVE_XMLTEXTREADERRELAXNGSETSCHEMA
static void qore_xml_relaxng_error_func(ExceptionSink* xsink, const char* msg, ...) {
   if (*xsink)
      return;

   va_list args;
   QoreStringNode* desc = new QoreStringNode;

   while (true) {
      va_start(args, msg);
      int rc = desc->vsprintf(msg, args);
      va_end(args);
      if (!rc)
         break;
   }
   desc->chomp();

   xsink->raiseException("RELAXNG-SYNTAX-ERROR", desc);
}
#endif

#ifdef HAVE_XMLTEXTREADERSETSCHEMA
static void qore_xml_schema_error_func(ExceptionSink* xsink, const char* msg, ...) {
   if (*xsink)
      return;

   va_list args;
   QoreStringNode* desc = new QoreStringNode;

   while (true) {
      va_start(args, msg);
      int rc = desc->vsprintf(msg, args);
      va_end(args);
      if (!rc)
         break;
   }
   desc->chomp();

   xsink->raiseException("XSD-SYNTAX-ERROR", desc);
}
#endif

#if defined(HAVE_XMLTEXTREADERRELAXNGSETSCHEMA) || defined(HAVE_XMLTEXTREADERSETSCHEMA)
static void qore_xml_schema_warning_func(ExceptionSink* xsink, const char* msg, ...) {
#ifdef DEBUG
   va_list args;
   QoreString buf;

   while (true) {
      va_start(args, msg);
      int rc = buf.vsprintf(msg, args);
      va_end(args);
      if (!rc)
         break;
   }

   printf("%s", buf.getBuffer());
#endif
}
#endif

#ifdef HAVE_XMLTEXTREADERSETSCHEMA
QoreXmlSchemaContext::QoreXmlSchemaContext(const char* xsd, int size, ExceptionSink* xsink) : schema(0) {
   xmlSchemaParserCtxtPtr scp = xmlSchemaNewMemParserCtxt(xsd, size);
   if (!scp)
      return;

   //xmlSchemaSetParserStructuredErrors(scp, (xmlStructuredErrorFunc)qore_xml_structured_error_func, xsink);

   xmlSchemaSetParserErrors(scp, (xmlSchemaValidityErrorFunc)qore_xml_schema_error_func,
                            (xmlSchemaValidityErrorFunc)qore_xml_schema_warning_func , xsink);
   schema = xmlSchemaParse(scp);
   xmlSchemaFreeParserCtxt(scp);
}
#endif

#ifdef HAVE_XMLTEXTREADERRELAXNGSETSCHEMA
QoreXmlRelaxNGContext::QoreXmlRelaxNGContext(const char* rng, int size, ExceptionSink* xsink) : schema(0) {
   xmlRelaxNGParserCtxtPtr rcp = xmlRelaxNGNewMemParserCtxt(rng, size);
   if (!rcp)
      return;

   xmlRelaxNGSetParserErrors(rcp, (xmlRelaxNGValidityErrorFunc)qore_xml_relaxng_error_func,
                             (xmlRelaxNGValidityErrorFunc)qore_xml_schema_warning_func, xsink);

   schema = xmlRelaxNGParse(rcp);
   xmlRelaxNGFreeParserCtxt(rcp);
}
#endif

static int concat_simple_value(ExceptionSink* xsink, QoreString &str, const AbstractQoreNode* n, const MakeXmlOpts &opts) {
   //printd(5, "concat_simple_value() n: %p (%s) %s\n", n, n->getTypeName(), n->getType() == NT_STRING ? ((QoreStringNode*)n)->getBuffer() : "unknown");
   if (!n)
      return 0;

   qore_type_t t = n->getType();
   switch (t) {
      case NT_INT: {
         const QoreBigIntNode* b = reinterpret_cast<const QoreBigIntNode*>(n);
         str.sprintf("%lld", b->val);
         return 0;
      }

      case NT_FLOAT: {
         str.sprintf("%.9g", reinterpret_cast<const QoreFloatNode*>(n)->f);
         return 0;
      }

      case NT_NUMBER: {
         reinterpret_cast<const QoreNumberNode*>(n)->getStringRepresentation(str);
         return 0;
      }

      case NT_BOOLEAN: {
         str.sprintf("%d", reinterpret_cast<const QoreBoolNode*>(n)->getValue());
         return 0;
      }

      case NT_DATE: {
         const DateTimeNode* date = reinterpret_cast<const DateTimeNode*>(n);
         date->format(str, opts.m_dateFormat.c_str());
         return 0;
      }
   }

   if (opts.m_useNumericRefs && t == NT_STRING) {
      if (str.concatEncode(xsink, *reinterpret_cast<const QoreStringNode*>(n),
                           CE_XML | (opts.m_useNumericRefs ? CE_NONASCII : 0)))
         return -1;
      return 0;
   }

   QoreStringValueHelper temp(n);
   if (str.concatEncode(xsink, **temp, CE_XML | (opts.m_useNumericRefs ? CE_NONASCII : 0)))
      return -1;

   return 0;
}

static int concat_simple_cdata_value(QoreString &str, const AbstractQoreNode* n, ExceptionSink* xsink) {
   //printd(5, "concat_simple_cdata_value() n: %p (%s) %s\n", n, n->getTypeName(), n->getType() == NT_STRING ? ((QoreStringNode*)n)->getBuffer() : "unknown");
   if (n && n->getType() == NT_STRING) {
      const QoreStringNode* qsn = reinterpret_cast<const QoreStringNode*>(n);
      if (strstr(qsn->getBuffer(), "]]>")) {
         xsink->raiseException("MAKE-XML-ERROR", "CDATA text contains illegal ']]>' sequence");
         return -1;
      }
      str.concat(qsn, xsink);
      return *xsink ? -1 : 0;
   }

   return concat_simple_value(xsink, str, n, MakeXmlOpts());
}

static int concat_simple_comment(QoreString &str, const AbstractQoreNode* n, ExceptionSink* xsink) {
   //printd(5, "concat_simple_comment() n: %p (%s) %s\n", n, n->getTypeName(), n->getType() == NT_STRING ? ((QoreStringNode*)n)->getBuffer() : "unknown");
   if (n && n->getType() == NT_STRING) {
      const QoreStringNode* qsn = reinterpret_cast<const QoreStringNode*>(n);
      if (strstr(qsn->getBuffer(), "-->")) {
         xsink->raiseException("MAKE-XML-ERROR", "Comment text contains illegal '-->' sequence");
         return -1;
      }
      str.concat(qsn, xsink);
      return *xsink ? -1 : 0;
   }

   return concat_simple_value(xsink, str, n, MakeXmlOpts());
}

static int make_xml(ExceptionSink* xsink, QoreString &str, const QoreHashNode &h, int indent, const MakeXmlOpts &opts);
static QoreStringNode* make_xml_intern(ExceptionSink* xsink, const QoreStringNode* pstr, const QoreHashNode* pobj, const MakeXmlOpts &opts);

QoreStringNode* make_xml(ExceptionSink* xsink, const QoreHashNode &h, const MakeXmlOpts &opts) {
   return make_xml_intern(xsink, nullptr, &h, opts);
}

static void add_xml_element(ExceptionSink* xsink, const char* key, QoreString &str, const AbstractQoreNode* n, int indent, const MakeXmlOpts &opts) {
   //QORE_TRACE("add_xml_element()");

   if (is_nothing(n)) {
      str.concat('<');
      str.concat(key);
      str.concat("/>");
      return;
   }

   qore_type_t ntype = n->getType();

   if (ntype == NT_LIST) {
      const QoreListNode* l = reinterpret_cast<const QoreListNode*>(n);
      // iterate through the list
      int ls = l->size();
      if (ls) {
         for (int j = 0; j < ls; j++) {
            const AbstractQoreNode* v = l->retrieve_entry(j);
            // indent all but first entry if necessary
            if (j && opts.m_formatWithWhitespaces) {
               str.concat('\n');
               str.addch(' ', indent);
            }

            add_xml_element(xsink, key, str, v, indent, opts);
         }
      }
      else {    // close node
         str.concat('<');
         str.concat(key);
         str.concat("/>");
      }
      return;
   }

   // open node
   str.concat('<');
   str.concat(key);

   if (ntype == NT_HASH) {
      const QoreHashNode* h = reinterpret_cast<const QoreHashNode*>(n);
      // inc = ignore node counter, see if special keys exists and increment counter even if they have no value
      qore_size_t inc = 0;
      int vn = 0;
      bool exists;
      const AbstractQoreNode* value;
      const AbstractQoreNode* v = h->getKeyValueExistence("^value^", exists);
      if (!exists)
         value = 0;
      else {
         vn++;
         if (is_nothing(v)) {
            inc++;
            value = 0;
         } else
            value = v;
         // find all ^value*^ nodes
         QoreString val;
         while (true) {
            val.sprintf("^value%d^", vn);
            v = h->getKeyValueExistence(val.getBuffer(), exists);
            if (!exists) {
               break;
            }
            else if (is_nothing(v)) // if the node exists but there is no value, then skip
               inc++;
            else
               value = v;
            vn++;
         }
      }

      int cn = 0;
      v = h->getKeyValueExistence("^comment^", exists);
      if (exists) {
         cn++;
         if (is_nothing(v))
            inc++;
         // find all ^comment*^ nodes
         QoreString val;
         while (true) {
            val.sprintf("^comment%d^", cn);
            v = h->getKeyValueExistence(val.getBuffer(), exists);
            if (!exists) {
               break;
            }
            else if (is_nothing(v)) // if the node exists but there is no value, then skip
               inc++;
            cn++;
         }
      }
      const AbstractQoreNode* attrib = h->getKeyValueExistence("^attributes^", exists);
      if (!exists)
         attrib = 0;
      else
         inc++;

      // add attributes for objects
      if (attrib && attrib->getType() == NT_HASH) {
         const QoreHashNode* ah = reinterpret_cast<const QoreHashNode*>(attrib);
         // add attributes to node
         ConstHashIterator hi(ah);
         while (hi.next()) {
            const char* tkey = hi.getKey();
            str.sprintf(" %s=\"", tkey);
            const AbstractQoreNode* v = hi.getValue();
            if (v) {
               if (v->getType() == NT_STRING) {
                  if (str.concatEncode(xsink, *reinterpret_cast<const QoreStringNode*>(v),
                                       CE_XML | (opts.m_useNumericRefs ? CE_NONASCII : 0)))
                     return;
               }
               else { // convert to string and add
                  QoreStringValueHelper temp(v);
                  str.concat(*temp, xsink);
               }
            }
            str.concat('\"');
         }
      }

      //printd(5, "inc: %d vn: %d\n", inc, vn);

      // if there are no more elements, close node immediately
      if (h->size() == inc) {
         str.concat("/>");
         return;
      }

      // close node
      str.concat('>');

      // print value without CRLF
      if (!is_nothing(value) && h->size() == (inc + 1)) {
         if (concat_simple_value(xsink, str, value, opts))
            return;
      }
      else { // add additional elements and formatting only if the additional elements exist
         if (opts.m_formatWithWhitespaces && !vn) {
            str.concat('\n');
         }
         auto innerOpts = opts;
         if (vn)
             innerOpts.m_formatWithWhitespaces = false;
         make_xml(xsink, str, *h, indent + 2, innerOpts);
         // indent closing entry
         if (opts.m_formatWithWhitespaces && !vn) {
            str.concat('\n');
            str.addch(' ', indent);
         }
      }
   }
   else {
      // close node
      str.concat('>');

      if (ntype == NT_OBJECT) {
         const QoreObject *o = reinterpret_cast<const QoreObject *>(n);
         // get snapshot of data
         QoreHashNodeHolder h(o->copyData(xsink), xsink);
         if (!*xsink) {
            if (opts.m_formatWithWhitespaces)
               str.concat('\n');
            make_xml(xsink, str, *(*h), indent + 2, opts);
            // indent closing entry
            if (opts.m_formatWithWhitespaces)
               str.addch(' ', indent);
         }
      }
      else
         concat_simple_value(xsink, str, n, opts);
   }

   // close node
   str.concat("</");
   str.concat(key);
   str.concat('>');
}

static int make_xml(ExceptionSink* xsink, QoreString &str, const QoreHashNode &h, int indent, const MakeXmlOpts &opts) {
   QORE_TRACE("make_xml()");

   ConstHashIterator hi(h);
   bool done = false;
   while (hi.next()) {
      std::unique_ptr<QoreString> keyStr(hi.getKeyString());
      // convert string if needed
      if (keyStr->getEncoding() != str.getEncoding()) {
         QoreString* ns = keyStr->convertEncoding(str.getEncoding(), xsink);
         if (xsink->isEvent())
            return -1;
         keyStr.reset(ns);
      }

      const char* key = keyStr->getBuffer();
      if (!strcmp(key, "^attributes^"))
         continue;

      if (!strncmp(key, "^value", 6)) {
         if (concat_simple_value(xsink, str, hi.getValue(), opts))
            return -1;
         continue;
      }

      if (!strncmp(key, "^cdata", 6)) {
         str.concat("<![CDATA[");
         if (concat_simple_cdata_value(str, hi.getValue(), xsink))
            return -1;
         str.concat("]]>");
         continue;
      }

      if (!strncmp(key, "^comment", 8)) {
         if (opts.m_formatWithWhitespaces) {
            if (done) {
              str.concat('\n');
            }
            str.addch(' ', indent);
         }
         str.concat("<!--");
         if (concat_simple_comment(str, hi.getValue(), xsink))
            return -1;
         str.concat("-->");
         done = true;
         continue;
      }

      // make sure it's a valid XML tag element name
      if (!key || (!isalpha(key[0]) && key[0] != '_')) {
         xsink->raiseException("MAKE-XML-ERROR", "tag: \"%s\" is not a valid XML tag element name", key ? key : "");
         return -1;
      }

      // process key name - remove ^# from end of key name if present
      qore_size_t l = keyStr->strlen() - 1;
      while (isdigit(key[l]))
        l--;

      if (l != (keyStr->strlen() - 1) && key[l] == '^')
           keyStr->terminate(l);

      // indent entry
      if (opts.m_formatWithWhitespaces) {
         if (done)
            str.concat('\n');
         str.addch(' ', indent);
      }
      //printd(5, "make_xml() level %d adding member %s\n", indent / 2, node->getBuffer());
      add_xml_element(xsink, key, str, hi.getValue(), indent, opts);
      done = true;
   }

   return 0;
}

// returns top-level key name
static bool hash_ok(const QoreHashNode* h) {
   int count = 0;

   ConstHashIterator hi(h);

   while (hi.next()) {
      const char* k = hi.getKey();
      if (!k[0] || k[0] == '^')
         continue;
      if (++count > 1)
         break;
      const AbstractQoreNode *n = hi.getValue();
      if (n->getType() == NT_LIST) {
         // top level hash value of list type does not generate valid xml as one root element is mandatory
         const QoreListNode *l = reinterpret_cast<const QoreListNode*>(n);
         if (l->size() > 1) {
            return false;
         }

      }
   }
   return count == 1;
}

static QoreStringNode* make_xml_intern(ExceptionSink* xsink, const QoreStringNode* pstr, const QoreHashNode* pobj, const MakeXmlOpts &opts) {
   SimpleRefHolder<QoreStringNode> str(new QoreStringNode(opts.m_encoding));
   str->sprintf("<?xml version=\"%s\" encoding=\"%s\"?>", opts.m_docVersion.c_str(),
        opts.m_encoding->getCode());
   str->concat('\n'); // always separate the header with new line
   if (pstr) {
      TempEncodingHelper key(pstr, QCS_UTF8, xsink);
      if (!key)
         return 0;
      add_xml_element(xsink, key->getBuffer(), *(*str), pobj, 0, opts);
   }
   else
      make_xml(xsink, *(*str), *pobj, 0, opts);

   str->concat('\n'); // add new line after last line of xml

   //printd(5, "make_xml_intern() returning %s\n", str->getBuffer());

   return str.release();
}

static QoreStringNode* make_xml_intern(ExceptionSink* xsink, const QoreStringNode* pstr, const QoreHashNode* pobj, const QoreEncoding* ccs, int flags = XGF_NONE) {
    auto opts = MakeXmlOpts::createFromFlags(flags, ccs);
    return make_xml_intern(xsink, pstr, pobj, opts);
}

static int add_xmlrpc_value(QoreString* str, const QoreValue n, int indent, const QoreEncoding* ccs, int flags, ExceptionSink* xsink);

#define EMPTY_KEY_STRING "!!empty-hash-key!!"

static int add_xmlrpc_value_intern_hash(QoreString* str, const QoreHashNode* h, int indent, const QoreEncoding* ccs, int flags, ExceptionSink* xsink) {
   bool fmt = flags & XGF_ADD_FORMATTING;

   str->concat("<struct>");
   if (fmt)
      str->concat('\n');
   ConstHashIterator hi(h);
   while (hi.next()) {
      std::unique_ptr<QoreString> member(hi.getKeyString());
      // here we allow hashes with empty key names to be serialized
      if (!member->strlen())
         member.reset(new QoreString(EMPTY_KEY_STRING, ccs));

      // convert string if needed
      if (member->getEncoding() != ccs) {
         QoreString* ns = member->convertEncoding(ccs, xsink);
         if (*xsink) {
            assert(!ns);
            return -1;
         }
         //printd(5, "add_xmlrpc_value_intern_hash() converted %s->%s, \"%s\"->\"%s\"\n", member->getEncoding()->getCode(), ccs->getCode(), member->getBuffer(), ns->getBuffer());
         member.reset(ns);
      }
      //else printd(5, "add_xmlrpc_value_intern_hash() not converting %sx \"%s\"\n", member->getEncoding()->getCode(), member->getBuffer());
      // indent
      if (fmt)
         str->addch(' ', indent + 2);
      str->concat("<member>");
      if (fmt) {
         str->concat('\n');
         // indent
         str->addch(' ', indent + 4);
      }
      str->concat("<name>");
      if (str->concatEncode(xsink, *member.get(), CE_XML | (flags & XGF_ENCODE_MASK)))
         return -1;

      member.reset();

      str->concat("</name>");
      if (fmt)
         str->concat('\n');
      const AbstractQoreNode* val = hi.getValue();
      if (add_xmlrpc_value(str, val, indent + 4, ccs, flags, xsink))
         return -1;
      // indent
      if (fmt)
         str->addch(' ', indent + 2);
      str->concat("</member>");
      if (fmt)
         str->concat('\n');
   }
   // indent
   if (fmt)
      str->addch(' ', indent);
   str->concat("</struct>");

   return 0;
}

static int add_xmlrpc_value_intern(QoreString* str, const QoreValue n, int indent, const QoreEncoding* ccs, int flags, ExceptionSink* xsink) {
   assert(!n.isNullOrNothing());
   qore_type_t ntype = n.getType();

   bool fmt = flags & XGF_ADD_FORMATTING;

   if (ntype == NT_BOOLEAN)
      str->sprintf("<boolean>%d</boolean>", (int)n.getAsBool());

   else if (ntype == NT_INT) {
      int64 val = n.getAsBigInt();
      if (val >= -2147483647 && val <= 2147483647)
         str->sprintf("<i4>%lld</i4>", val);
      else
         str->sprintf("<string>%lld</string>", val);
   }

   else if (ntype == NT_STRING) {
      str->concat("<string>");
      if (str->concatEncode(xsink, *n.get<const QoreStringNode>(), CE_XML | (flags & XGF_ENCODE_MASK)))
         return -1;
      str->concat("</string>");
   }

   else if (ntype == NT_FLOAT)
      str->sprintf("<double>%.20g</double>", n.getAsFloat());

   else if (ntype == NT_NUMBER) {
      str->concat("<double>");
      n.get<const QoreNumberNode>()->getStringRepresentation(*str);
      str->concat("</double>");
   }

   else if (ntype == NT_DATE) {
      str->concat("<dateTime.iso8601>");
      str->concatISO8601DateTime(n.get<const DateTimeNode>());
      str->concat("</dateTime.iso8601>");
   }

   else if (ntype == NT_BINARY) {
      str->concat("<base64>");
      if (fmt) {
         str->concat('\n');
         // indent
         str->addch(' ', indent + 4);
      }
      str->concatBase64(n.get<const BinaryNode>());
      if (fmt) {
         str->concat('\n');
         // indent
         str->addch(' ', indent);
      }
      str->concat("</base64>");
   }

   else if (ntype == NT_HASH) {
      if (add_xmlrpc_value_intern_hash(str, n.get<const QoreHashNode>(), indent + 2, ccs, flags, xsink))
         return -1;
   }

   else if (ntype == NT_LIST) {
      const QoreListNode* l = n.get<const QoreListNode>();
      str->concat("<array>");
      if (fmt) {
         str->concat('\n');
         // indent
         str->addch(' ', indent + 4);
      }
      if (l->size()) {
         str->concat("<data>");
         if (fmt)
            str->concat('\n');
         for (unsigned i = 0; i < l->size(); i++) {
            if (add_xmlrpc_value(str, l->retrieve_entry(i), indent + 6, ccs, flags, xsink))
               return -1;
         }
         if (fmt)
            str->addch(' ', indent + 4);
         str->concat("</data>");
      }
      else
         str->concat("<data/>");
      if (fmt) {
         str->concat('\n');
         // indent
         str->addch(' ', indent + 2);
      }
      str->concat("</array>");
      //if (flags & XGF_ADD_FORMATTING) str->concat('\n');
   }
   else {
      xsink->raiseException("XMLRPC-SERIALIZATION-ERROR", "don't know how to serialize type '%s' to XML-RPC", n.getTypeName());
      return -1;
   }

   if (fmt) {
      str->concat('\n');
      // indent
      str->addch(' ' , indent);
   }

   return 0;
}

static int add_xmlrpc_value(QoreString* str, const QoreValue n, int indent, const QoreEncoding* ccs, int flags, ExceptionSink* xsink) {
   QORE_TRACE("add_xmlrpc_value()");

   bool fmt = flags & XGF_ADD_FORMATTING;

   // add value node
   // indent
   if (fmt)
      str->addch(' ', indent);

   if (!n.isNullOrNothing()) {
      str->concat("<value>");
      if (fmt) {
         str->concat('\n');
         // indent
         str->addch(' ', indent + 2);
      }

      if (add_xmlrpc_value_intern(str, n, indent, ccs, flags, xsink))
         return -1;

      // close value node
      str->concat("</value>");
   }
   else
      str->concat("<value/>");
   if (fmt)
      str->concat('\n');

   return 0;
}

QoreStringNode* make_xmlrpc_call(ExceptionSink* xsink, const QoreEncoding* ccs, int offset, const QoreValueList* params, int flags) {
   const QoreStringNode* p0 = HARD_QORE_VALUE_STRING(params, offset);

   bool fmt = XGF_ADD_FORMATTING & flags;

   QoreStringNodeHolder str(new QoreStringNode(ccs));
   str->sprintf("<?xml version=\"1.0\" encoding=\"%s\"?>%s<methodCall>%s<methodName>", ccs->getCode(), fmt ? "\n" : "", fmt ? "\n  " : "");
   if (str->concatEncode(xsink, *p0, CE_XML | (XGF_ENCODE_MASK & flags)))
      return 0;

   str->sprintf("</methodName>%s", fmt ? "\n" : "");

   // now process all arguments
   int ls = num_args(params);
   if (ls > offset) {
      str->sprintf("%s<params>%s", fmt ? "  " : "", fmt ? "\n" : "");

      for (int i = offset + 1; i < ls; i++) {
         const QoreValue p = get_param_value(params, i);
         str->sprintf("%s<param>%s", fmt ? "    " : "", fmt ? "\n" : "");
         if (add_xmlrpc_value(*str, p, fmt ? 6 : 0, ccs, flags, xsink))
            return 0;
         str->sprintf("%s</param>%s", fmt ? "    " : "", fmt ? "\n" : "");
      }
      str->sprintf("%s</params>%s", fmt ? "  " : "", fmt ? "\n" : "");
   }
   else
      str->sprintf("%s<params/>%s", fmt ? "  " : "", fmt ? "\n" : "");
   str->concat("</methodCall>");

   return str.release();
}

QoreStringNode* make_xmlrpc_call_args(ExceptionSink* xsink, const QoreEncoding* ccs, int offset, const QoreValueList* params, int flags) {
   const QoreStringNode* p0 = HARD_QORE_VALUE_STRING(params, offset);

   bool fmt = XGF_ADD_FORMATTING & flags;

   QoreStringNodeHolder str(new QoreStringNode(ccs));
   str->sprintf("<?xml version=\"1.0\" encoding=\"%s\"?>%s<methodCall>%s<methodName>", ccs->getCode(), fmt ? "\n" : "", fmt ? "\n  " : "");
   if (str->concatEncode(xsink, *p0, CE_XML | (XGF_ENCODE_MASK & flags)))
      return 0;

   str->sprintf("</methodName>%s", fmt ? "\n" : "");

   const QoreValue p1 = get_param_value(params, offset + 1);
   if (p1.getType() == NT_LIST) {
      const QoreListNode* l = p1.get<const QoreListNode>();
      if (l->size()) {
         str->sprintf("%s<params>%s", fmt ? "  " : "", fmt ? "\n" : "");

         for (unsigned int i = 0 ; i < l->size(); ++i) {
            const AbstractQoreNode* p = l->retrieve_entry(i);
            str->sprintf("%s<param>%s", fmt ? "    " : "", fmt ? "\n" : "");
            if (add_xmlrpc_value(*str, p, fmt ? 6 : 0, ccs, flags, xsink))
               return 0;
            str->sprintf("%s</param>%s", fmt ? "    " : "", fmt ? "\n" : "");
         }
         str->sprintf("%s</params>%s", fmt ? "  " : "", fmt ? "\n" : "");
      }
   }
   else if (!p1.isNullOrNothing()) {
      str->sprintf("<params>%s", fmt ? "\n" : "");
      str->sprintf("%s<param>%s", fmt ? "    " : "", fmt ? "\n" : "");
      if (add_xmlrpc_value(*str, p1, fmt ? 6 : 0, ccs, 0, xsink))
         return 0;
      str->sprintf("%s</param>%s", fmt ? "    " : "", fmt ? "\n" : "");
      str->sprintf("%s</params>%s", fmt ? "  " : "", fmt ? "\n" : "");
   }
   else
      str->sprintf("%s<params/>%s", fmt ? "  " : "", fmt ? "\n" : "");
   str->concat("</methodCall>");

   return str.release();
}

// NOTE: the libxml2 library requires all input to be in UTF-8 encoding
static AbstractQoreNode* parse_xml_intern(int pflags, const QoreValueList* args, ExceptionSink* xsink) {
   const QoreStringNode* p0 = HARD_QORE_VALUE_STRING(args, 0);

   const QoreEncoding* ccsid = get_value_encoding_param(args, 1);

   //printd(5, "parse_xml_intern(%d, %s)\n", as_data, p0->getBuffer());

   // convert to UTF-8
   TempEncodingHelper str(p0, QCS_UTF8, xsink);
   if (!str)
      return 0;

   QoreXmlReader reader(*str, QORE_XML_PARSER_OPTIONS, xsink);
   if (!reader)
      return 0;

   return reader.parseXmlData(ccsid, pflags, xsink);
}

static AbstractQoreNode* make_xmlrpc_fault(ExceptionSink* xsink, const QoreEncoding* ccs, int code, const QoreStringNode* p1, int flags = 0) {
   QORE_TRACE("make_xmlrpc_fault()");

   if (!ccs) ccs = p1->getEncoding();
   //printd(5, "ccsid: %016x (%s) (%s) code: %d\n", ccsid, ccsid->getCode(), ((QoreStringNode*)p1)->getBuffer(), code);

   bool fmt = XGF_ADD_FORMATTING & flags;

   // for speed, the XML is created directly here
   QoreStringNodeHolder str(new QoreStringNode(ccs));
   if (fmt)
      str->sprintf("<?xml version=\"1.0\" encoding=\"%s\"?>\n<methodResponse>\n  <fault>\n    <value>\n      <struct>\n        <member>\n          <name>faultCode</name>\n          <value><int>%d</int></value>\n        </member>\n        <member>\n          <name>faultString</name>\n          <value><string>",
                ccs->getCode(), code);
   else
      str->sprintf("<?xml version=\"1.0\" encoding=\"%s\"?><methodResponse><fault><value><struct><member><name>faultCode</name><value><int>%d</int></value></member><member><name>faultString</name><value><string>",
                   ccs->getCode(), code);

   str->concatEncode(xsink, *p1, CE_XML | (XGF_ENCODE_MASK & flags));
   if (*xsink)
       return 0;

   if (fmt)
      str->concat("</string></value>\n        </member>\n      </struct>\n    </value>\n  </fault>\n</methodResponse>");
   else
      str->concat("</string></value></member></struct></value></fault></methodResponse>");

   return str.release();
}

static AbstractQoreNode* make_xmlrpc_response(ExceptionSink* xsink, const QoreEncoding* ccs, int offset, const QoreValueList* args, int flags = 0) {
   QORE_TRACE("make_xmlrpc_response()");

   unsigned na = num_args(args);
   if (na == (unsigned)offset)
      return 0;

   bool fmt = XGF_ADD_FORMATTING & flags;

   QoreStringNodeHolder str(new QoreStringNode(ccs));
   str->sprintf("<?xml version=\"1.0\" encoding=\"%s\"?>", ccs->getCode());
   if (fmt)
      str->concat("\n<methodResponse>\n  <params>\n");
   else
      str->concat("<methodResponse><params>");

   // now loop through the params
   for (int i = offset, end = na - offset; i < end; ++i) {
      const QoreValue p = get_param_value(args, i);
      if (fmt)
         str->concat("    <param>\n");
      else
         str->concat("<param>");
      if (add_xmlrpc_value(*str, p, fmt ? 6 : 0, ccs, flags, xsink))
         return 0;

      if (fmt)
         str->concat("    </param>\n");
      else
         str->concat("</param>");
   }

   if (fmt)
      str->concat("  </params>\n</methodResponse>");
   else
      str->concat("</params></methodResponse>");

   return str.release();
}

static AbstractQoreNode* make_xmlrpc_response_args(ExceptionSink* xsink, const QoreEncoding* ccs, const QoreValue arg, int flags = 0) {
   QORE_TRACE("make_xmlrpc_response_args()");

   bool fmt = XGF_ADD_FORMATTING & flags;

   QoreStringNodeHolder str(new QoreStringNode(ccs));
   str->sprintf("<?xml version=\"1.0\" encoding=\"%s\"?>", ccs->getCode());
   if (fmt)
      str->concat("\n<methodResponse>\n  <params>\n");
   else
      str->concat("<methodResponse><params>");

   if (!arg.isNullOrNothing()) {
      if (arg.getType() == NT_LIST) {
         const QoreListNode* l = arg.get<QoreListNode>();
         // now loop through the params
         for (unsigned int i = 0; i < l->size(); ++i) {
            const AbstractQoreNode* p = l->retrieve_entry(i);
            if (fmt)
               str->concat("    <param>\n");
            else
               str->concat("<param>");
            if (add_xmlrpc_value(*str, p, fmt ? 6 : 0, ccs, flags, xsink))
               return 0;
            if (fmt)
               str->concat("    </param>\n");
            else
               str->concat("</param>");
         }
      }
      else {
         if (fmt)
            str->concat("    <param>\n");
         else
            str->concat("<param>");
         if (add_xmlrpc_value(*str, arg, fmt ? 6 : 0, ccs, flags, xsink))
            return 0;

         if (fmt)
            str->concat("    </param>\n");
         else
            str->concat("</param>");
      }
   }

   if (fmt)
      str->concat("  </params>\n</methodResponse>");
   else
      str->concat("</params></methodResponse>");

   return str.release();
}

QoreStringNode* make_xmlrpc_value(ExceptionSink* xsink, QoreValue value, const QoreStringNode* encoding, int flags = 0) {
   if (value.isNullOrNothing())
       return 0;

   const QoreEncoding* qe = encoding ? QEM.findCreate(encoding) : QCS_DEFAULT;

   QoreStringNodeHolder rv(new QoreStringNode(qe));
   if (add_xmlrpc_value_intern(*rv, value, 0, qe, flags, xsink))
      return 0;

   return rv.release();
}

static AbstractQoreNode* qore_xml_exception(const char* ex, const char* info, ExceptionSink* xsink) {
   if (!*xsink)
      xsink->raiseException(ex, "error parsing XML string: %s", info);
   return 0;
}

static AbstractQoreNode* qore_xml_exception(const char* ex, ExceptionSink* xsink) {
   if (!*xsink)
      xsink->raiseException(ex, "error parsing XML string");
   return 0;
}

static QoreHashNode* qore_xml_hash_exception(const char* ex, const char* info, ExceptionSink* xsink, const QoreString* xml = 0) {
   if (!*xsink)
      xsink->raiseExceptionArg(ex, xml ? new QoreStringNode(*xml) : 0, "error parsing XML string: %s", info);
   return 0;
}

/*
static QoreHashNode* qore_xml_hash_exception(const char* ex, ExceptionSink* xsink, const QoreString* xml = 0) {
   if (!*xsink)
      xsink->raiseExceptionArg(ex, xml ? new QoreStringNode(*xml) : 0, "error parsing XML string");
   return 0;
}
*/

// parseXMLRPCResponse
QoreHashNode* parse_xmlrpc_response(ExceptionSink* xsink, const QoreString* msg, const QoreEncoding* ccsid, int flags) {
   //printd(5, "parse_xmlrpc_response() %s\n", msg->getBuffer());

   TempEncodingHelper str(msg, QCS_UTF8, xsink);
   if (!str)
      return 0;

   QoreXmlRpcReader reader(*str, QORE_XML_PARSER_OPTIONS, xsink);
   if (!reader)
      return 0;

   if (reader.read(xsink) != 1)
      return 0;

   int nt;
   // get "methodResponse" element
   if ((nt = reader.nodeTypeSkipWhitespace()) != XML_READER_TYPE_ELEMENT)
       return qore_xml_hash_exception("PARSE-XMLRPC-RESPONSE-ERROR", "expecting 'methodResponse' element", xsink, *str);

   if (reader.checkXmlRpcMemberName("methodResponse", xsink))
      return 0;

   // check for params or fault element
   if (reader.readXmlRpc("expecting 'params' or 'fault' element", xsink))
      return 0;

   if ((nt = reader.nodeTypeSkipWhitespace()) != XML_READER_TYPE_ELEMENT)
       return qore_xml_hash_exception("PARSE-XMLRPC-RESPONSE-ERROR", "expecting 'params' or 'fault' element", xsink, *str);

   const char* name = reader.constName();
   if (!name) {
      xsink->raiseExceptionArg("PARSE-XMLRPC-RESPONSE-ERROR", new QoreStringNode(*str), "missing 'params' or 'fault' element tag");
      return 0;
   }

   Qore::Xml::intern::XmlRpcValue v;
   bool fault = false;
   if (!strcmp(name, "params")) {
      int depth = reader.depth();

      // get "params" element
      if (reader.readXmlRpc("expecting 'params' element", xsink))
         return 0;

      int params_depth = reader.depth();

      // if params was not an empty element
      if (depth < params_depth) {
         if ((nt = reader.readXmlRpcNode(xsink)) == -1)
            return 0;

         if (nt != XML_READER_TYPE_END_ELEMENT) {
            if (nt != XML_READER_TYPE_ELEMENT)
               return qore_xml_hash_exception("PARSE-XMLRPC-RESPONSE-ERROR", "expecting 'param' element", xsink, *str);

            if (reader.checkXmlRpcMemberName("param", xsink))
               return 0;

            // get "value" element
            if (reader.readXmlRpc("expecting 'value' element", xsink))
               return 0;

            // if param was not an empty element
            depth = reader.depth();
            if (params_depth < depth) {
               if ((nt = reader.readXmlRpcNode(xsink)) == -1)
                  return 0;

               if (nt != XML_READER_TYPE_END_ELEMENT) {
                  if (nt != XML_READER_TYPE_ELEMENT)
                     return qore_xml_hash_exception("PARSE-XMLRPC-RESPONSE-ERROR", "expecting 'value' element", xsink, *str);

                  if (reader.checkXmlRpcMemberName("value", xsink))
                     return 0;

                  // position at next element
                  if (reader.readXmlRpc("expecting XML-RPC value element", xsink))
                     return 0;

                  // if value was not an empty element
                  if (depth < reader.depth()) {
                     if (reader.getValueData(&v, ccsid, true, xsink))
                        return 0;

                     //printd(5, "parseXMLRPCResponse() name: %s reader.nodeType: %d\n", reader.constName(), reader.nodeType());

                     if ((nt = reader.nodeTypeSkipWhitespace()) != XML_READER_TYPE_END_ELEMENT) {
                        //printd(5, "nt: %d name: %s\n", nt, reader.constName());
                        return qore_xml_hash_exception("PARSE-XMLRPC-RESPONSE-ERROR", "2: expecting 'value' end element", xsink, *str);
                     }

                     if (reader.checkXmlRpcMemberName("value", xsink))
                        return 0;

                     if (reader.readSkipWhitespace("expecting 'param' end element", xsink) == -1)
                        return 0;
                  }

                  //printd(5, "parseXMLRPCResponse() (expecing param) name: %s reader.nodeType: %d (nt: %d)\n", reader.constName(), reader.nodeType(), nt);

                  if ((nt = reader.nodeType()) != XML_READER_TYPE_END_ELEMENT)
                     return qore_xml_hash_exception("PARSE-XMLRPC-RESPONSE-ERROR", "expecting 'param' end element", xsink, *str);

                  if (reader.checkXmlRpcMemberName("param", xsink))
                     return 0;
               }

               // get "params" end element
               if (reader.readXmlRpc("expecting 'params' end element", xsink))
                  return 0;
            }
            if ((nt = reader.nodeTypeSkipWhitespace()) != XML_READER_TYPE_END_ELEMENT)
               return qore_xml_hash_exception("PARSE-XMLRPC-RESPONSE-ERROR", "expecting 'params' end element", xsink, *str);
         }
         // get "methodResponse" end element
         if (reader.readXmlRpc("expecting 'methodResponse' end element", xsink))
            return 0;
      }
   }
   else if (!strcmp(name, "fault")) {
      fault = true;

      // get "value" element
      if (reader.readXmlRpc("expecting 'value' element", xsink))
         return 0;

      if ((nt = reader.nodeTypeSkipWhitespace()) != XML_READER_TYPE_ELEMENT)
         return qore_xml_hash_exception("PARSE-XMLRPC-RESPONSE-ERROR", "expecting fault 'value' element", xsink, *str);

      if (reader.checkXmlRpcMemberName("value", xsink))
         return 0;

      // position at next element
      if (reader.readXmlRpc("expecting XML-RPC value element", xsink))
         return 0;

      // get fault structure
      if (reader.getValueData(&v, ccsid, true, xsink))
         return 0;

      if ((nt = reader.nodeTypeSkipWhitespace()) != XML_READER_TYPE_END_ELEMENT)
         return qore_xml_hash_exception("PARSE-XMLRPC-RESPONSE-ERROR", "expecting 'value' end element", xsink, *str);

      if (reader.readSkipWhitespace("expecting 'fault' end element", xsink) == -1)
         return 0;

      if ((nt = reader.nodeType()) != XML_READER_TYPE_END_ELEMENT)
         return qore_xml_hash_exception("PARSE-XMLRPC-RESPONSE-ERROR", "expecting 'fault' end element", xsink, *str);

      // get "methodResponse" end element
      if (reader.readXmlRpc("expecting 'methodResponse' end element", xsink))
         return 0;
   }
   else {
      xsink->raiseException("PARSE-XMLRPC-RESPONSE-ERROR", "unexpected element '%s', expecting 'params' or 'fault'", name, *str);
      return 0;
   }

   if ((nt = reader.nodeTypeSkipWhitespace()) != XML_READER_TYPE_END_ELEMENT)
      return qore_xml_hash_exception("PARSE-XMLRPC-RESPONSE-ERROR", "expecting 'methodResponse' end element", xsink, *str);

   QoreHashNode* h = new QoreHashNode;
   if (fault)
      h->setKeyValue("fault", v.getValueNode(), 0);
   else
      h->setKeyValue("params", v.getValueNode(), 0);
   return h;
}

// NOTE: the libxml2 library requires all input to be in UTF-8 encoding
// syntax: parse_xml_with_schema_intern(xml_string, xsd_string [, output encoding])
static AbstractQoreNode* parse_xml_with_schema_intern(ExceptionSink* xsink, bool with_flags, const QoreValueList* args, int flags = 0) {
// NOTE: the libxml2 library requires all input to be in UTF-8
#ifdef HAVE_XMLTEXTREADERSETSCHEMA
   const QoreStringNode* p0 = HARD_QORE_VALUE_STRING(args, 0);
   const QoreStringNode* p1 = HARD_QORE_VALUE_STRING(args, 1);

   const QoreEncoding* ccsid;
   if (with_flags) {
      flags |= get_param_value(args, 2).getAsBigInt();
      ccsid = get_value_encoding_param(args, 3);
   }
   else
      ccsid = get_value_encoding_param(args, 2);

   printd(5, "parse_xml_with_schema_intern() xml: %s\n xsd: %s\n", p0->getBuffer(), p1->getBuffer());

   // convert to UTF-8
   TempEncodingHelper str(p0, QCS_UTF8, xsink);
   if (!str)
      return 0;

   TempEncodingHelper xsd(p1, QCS_UTF8, xsink);
   if (!xsd)
      return 0;

   QoreXmlSchemaContext schema(xsd->getBuffer(), xsd->strlen(), xsink);
   if (!schema) {
      if (!*xsink)
         xsink->raiseException("XSD-SYNTAX-ERROR", "XML schema passed as second argument to parseXMLWithSchema() could not be parsed");
      return 0;
   }

   QoreXmlReader reader(*str, QORE_XML_PARSER_OPTIONS, xsink);
   if (!reader)
      return 0;

   int rc = reader.setSchema(schema.getSchema());
   if (rc < 0) {
      if (!*xsink)
         xsink->raiseException("XSD-VALIDATION-ERROR", "XML schema passed as second argument to parseXMLWithSchema() could not be validated");
      return 0;
   }

   return reader.parseXmlData(ccsid, flags, xsink);
#else
   xsink->raiseException("MISSING-FEATURE-ERROR", "the libxml2 version used to compile the xml module did not support the xmlTextReaderSetSchema() function, therefore parseXMLWithSchema() and parseXMLAsDataWithSchema() are not available; for maximum portability, use the constant Option::HAVE_PARSEXMLWITHSCHEMA to check if this function is implemented before calling");
   return 0;
#endif
}

// NOTE: the libxml2 library requires all input to be in UTF-8 encoding
// syntax: parse_xml_with_relaxng_intern(xml_string, xsd_string [, output encoding])
static AbstractQoreNode* parse_xml_with_relaxng_intern(ExceptionSink* xsink, bool with_flags, const QoreValueList* args, int flags = 0) {
#ifdef HAVE_XMLTEXTREADERRELAXNGSETSCHEMA
   const QoreStringNode* p0 = HARD_QORE_VALUE_STRING(args, 0);
   const QoreStringNode* p1 = HARD_QORE_VALUE_STRING(args, 1);

   const QoreEncoding* ccsid;
   if (with_flags) {
      flags |= get_param_value(args, 2).getAsBigInt();
      ccsid = get_value_encoding_param(args, 3);
   }
   else
      ccsid = get_value_encoding_param(args, 2);

   printd(5, "parse_xml_with_relaxng_intern() xml: %s\n xsd: %s\n", p0->getBuffer(), p1->getBuffer());

   // convert to UTF-8
   TempEncodingHelper str(p0, QCS_UTF8, xsink);
   if (!str)
      return 0;

   TempEncodingHelper rng(p1, QCS_UTF8, xsink);
   if (!rng)
      return 0;

   QoreXmlRelaxNGContext schema(rng->getBuffer(), rng->strlen(), xsink);
   if (!schema) {
      if (!*xsink)
         xsink->raiseException("RELAXNG-SYNTAX-ERROR", "RelaxNG schema passed as second argument to parseXMLWithRelaxNG() could not be parsed");
      return 0;
   }

   QoreXmlReader reader(*str, QORE_XML_PARSER_OPTIONS, xsink);
   if (!reader)
      return 0;

   int rc = reader.setRelaxNG(schema.getSchema());
   if (rc < 0) {
      if (!*xsink)
         xsink->raiseException("RELAXNG-VALIDATION-ERROR", "RelaxNG schema passed as second argument to parseXMLWithRelaxNG() could not be validated");
      return 0;
   }

   return reader.parseXmlData(ccsid, flags, xsink);
#else
   xsink->raiseException("MISSING-FEATURE-ERROR", "the libxml2 version used to compile the xml module did not support the xmlTextReaderSetRelaxNG() function, therefore parseXMLWithRelaxNG() and parseXMLAsDataWithRelaxNG() are not available; for maximum portability, use the constant Option::HAVE_PARSEXMLWITHRELAXNG to check if this function is implemented before calling");
   return 0;
#endif
}

static QoreHashNode* parse_xmlrpc_call(const QoreStringNode* xml, const QoreStringNode* encoding, ExceptionSink* xsink) {
   const QoreEncoding* qe = encoding ? QEM.findCreate(encoding) : QCS_DEFAULT;

   //printd(5, "parse_xmlrpc_call() c: %d str: %s\n", p0->getBuffer()[0], p0->getBuffer());

   TempEncodingHelper str(xml, QCS_UTF8, xsink);
   if (!str)
      return 0;

   QoreXmlRpcReader reader(*str, QORE_XML_PARSER_OPTIONS, xsink);
   if (!reader)
      return 0;

   if (reader.read(xsink) != 1)
      return 0;

   int nt;
   // get "methodCall" element
   if ((nt = reader.nodeTypeSkipWhitespace()) != XML_READER_TYPE_ELEMENT)
      return (QoreHashNode*)qore_xml_exception("PARSE-XMLRPC-CALL-ERROR", "expecting 'methodCall' element", xsink);

   if (reader.checkXmlRpcMemberName("methodCall", xsink))
      return 0;

   // get "methodName" element
   if (reader.readXmlRpc("expecting methodName element", xsink))
      return 0;

   if ((nt = reader.nodeTypeSkipWhitespace()) != XML_READER_TYPE_ELEMENT)
      return (QoreHashNode*)qore_xml_exception("PARSE-XMLRPC-CALL-ERROR", "expecting 'methodName' element", xsink);

   if (reader.checkXmlRpcMemberName("methodName", xsink))
      return 0;

   // get method name string
   if (reader.readXmlRpc("expecting method name", xsink))
      return 0;

   if ((nt = reader.nodeTypeSkipWhitespace()) != XML_READER_TYPE_TEXT)
      return (QoreHashNode*)qore_xml_exception("PARSE-XMLRPC-CALL-ERROR", "expecting method name", xsink);

   const char* method_name = reader.constValue();
   if (!method_name)
      return (QoreHashNode*)qore_xml_exception("PARSE-XMLRPC-CALL-ERROR", "expecting method name", xsink);

   ReferenceHolder<QoreHashNode> h(new QoreHashNode, xsink);
   h->setKeyValue("methodName", new QoreStringNode(method_name), 0);

   // get methodName close tag
   if (reader.readXmlRpc("expecting methodName close element", xsink))
      return 0;

   if ((nt = reader.nodeTypeSkipWhitespace()) != XML_READER_TYPE_END_ELEMENT)
      return (QoreHashNode*)qore_xml_exception("PARSE-XMLRPC-CALL-ERROR", "expecting 'methodName' close element", xsink);

   // get "params" element
   if (reader.readXmlRpc("expecting params element", xsink))
      return 0;

   if ((nt = reader.readXmlRpcNode(xsink)) == -1)
      return (QoreHashNode*)qore_xml_exception("PARSE-XMLRPC-CALL-ERROR", xsink);

   // if the methodCall end element was not found
   if (nt != XML_READER_TYPE_END_ELEMENT) {
      if ((nt = reader.nodeTypeSkipWhitespace()) != XML_READER_TYPE_ELEMENT)
         return (QoreHashNode*)qore_xml_exception("PARSE-XMLRPC-CALL-ERROR", "expecting 'params' element", xsink);

      if (reader.checkXmlRpcMemberName("params", xsink))
         return 0;

      // get 'param' element or close params
      if (reader.readXmlRpc("expecting param element", xsink))
         return 0;

      if ((nt = reader.readXmlRpcNode(xsink)) == -1)
         return (QoreHashNode*)qore_xml_exception("PARSE-XMLRPC-CALL-ERROR", xsink);

      Qore::Xml::intern::XmlRpcValue v;
      if (reader.depth()) {
         if (nt != XML_READER_TYPE_END_ELEMENT) {
            if (nt != XML_READER_TYPE_ELEMENT)
               return (QoreHashNode*)qore_xml_exception("PARSE-XMLRPC-CALL-ERROR", "expecting 'params' element", xsink);

            if (reader.getParams(&v, qe, xsink))
               return 0;
         }

         // get methodCall close tag
         if (reader.readXmlRpc("expecting methodCall close tag", xsink))
            return 0;
      }

      if ((nt = reader.nodeTypeSkipWhitespace()) != XML_READER_TYPE_END_ELEMENT) {
         return (QoreHashNode*)qore_xml_exception("PARSE-XMLRPC-CALL-ERROR", "expecting 'methodCall' close element", xsink);
      }

      if (reader.checkXmlRpcMemberName("methodCall", xsink, true))
         return 0;

      h->setKeyValue("params", v.getValueNode(), xsink);
   }

   return h.release();
}

static QoreValue parse_xmlrpc_value(const QoreStringNode* xml, const QoreStringNode* encoding, ExceptionSink* xsink) {
   const QoreEncoding* qe = encoding ? QEM.findCreate(encoding) : QCS_DEFAULT;

   TempEncodingHelper str(xml, QCS_UTF8, xsink);
   if (!str)
      return 0;

   QoreXmlRpcReader reader(*str, QORE_XML_PARSER_OPTIONS, xsink);
   if (!reader)
      return 0;

   if (reader.read(xsink) != 1)
      return 0;

   Qore::Xml::intern::XmlRpcValue v;
   if (reader.getValueData(&v, qe, false, xsink))
      return 0;

   return v.getValue();
}

/** @defgroup xml_generation_constants XML Generation Constants
    The constants in this group can be combined with @ref bitwise_or_operator "binary or" to affect the output of generated XML
 */
//@{
namespace Qore::Xml;

//! no flags; standard XML generation without whitespace formatting and characters without unicode character references
const XGF_NONE = XGF_NONE;

//! use numeric character references instead of native characters for non-ascii character when generating XML
/** note that character references are not applied to CDATA when serializing XML
    (keys that begin with \c "^cdata" are serialized as cdata.
 */
const XGF_USE_NUMERIC_REFS = XGF_USE_NUMERIC_REFS;

//! use whitespace formatting including line breaks to make generated XML more readable
const XGF_ADD_FORMATTING = XGF_ADD_FORMATTING;
//@}

/** @defgroup xml_parsing_constants XML Parsing Constants
    The constants in this group can be combined with @ref bitwise_or_operator "binary or" to affect the output of parsed XML
 */
//@{
namespace Qore::Xml;

//! no flags; standard XML parsing without character reference conversion
const XPF_NONE = XPF_NONE;

//! decode XML as data; do not try to preserve element order by re-writing hash keys
/** If this option is given and duplicate, out-of-order XML elements are found in the input string, they are deserialized to %Qore hash elements with the same name as the XML element but including a caret \c '^' and a numeric prefix to maintain the same key order in the %Qore hash as in the input XML string.

    In this case, if the data structure is reserialized with make_xml(), an XML string corresponding to the original input should be generated.

    This option should only be used when it is important to maintain the XML element order in the resulting %Qore data structure (for example, when the data must be re-serialized to an XML string and the element order within a subelement must be maintained), for example, when parsing and reserializing an OSX property list in XML format.
 */
const XPF_PRESERVE_ORDER = XPF_PRESERVE_ORDER;

//! decode XML comments
/** If this option is given, then parse_xml() creates hash elements with \c'^comment^' keys corresponding to comments found in the XML
 */
const XPF_ADD_COMMENTS = XPF_ADD_COMMENTS;
//@}

/** @defgroup xml_functions XML Functions
 */
//@{
namespace Qore::Xml;

//! serializes a hash into an XML string with an XML header
/** @par Example:
    @code string xml = make_xml("key", hash); @endcode

    @param key top-level key
    @param h the rest of the data to serialize under the top-level key
    @param flags optional formatting flags; see @ref xml_generation_constants for more information
    @param encoding an optional string giving the encoding for the output XML string; if this parameter is missing, the output string will have the default encoding

    @return an XML string corresponding to the input data, with an XML header

    @throw MAKE-XML-ERROR An error occurred serializing the %Qore data to an XML string

    @see @ref serialization

    @since xml 1.3 as a replacement for deprecated camel-case makeXMLString() and makeFormattedXMLString()
 */
string make_xml(string key, hash h, *int flags, *string encoding) [flags=RET_VALUE_ONLY] {
   const QoreEncoding* qe = encoding ? QEM.findCreate(encoding) : QCS_DEFAULT;
   return make_xml_intern(xsink, key, h, qe, flags);
}

//! serializes a hash into an XML string with an XML header
/** @par Example:
    @code string xml = make_xml(hash); @endcode

    @param h a hash of data to serialize: the hash must have one top-level key and no more or an exception will be raised
    @param flags optional formatting flags; see @ref xml_generation_constants for more information
    @param encoding an optional string giving the encoding for the output XML string; if this parameter is missing, the output string will have the default encoding

    @return an XML string corresponding to the input data, with an XML header

    @throw MAKE-XML-STRING-PARAMETER-EXCEPTION the hash passed not not have a single top-level key (either has no keys or more than one)
    @throw MAKE-XML-ERROR An error occurred serializing the %Qore data to an XML string

    @see @ref serialization

    @since xml 1.3 as a replacement for deprecated camel-case makeXMLString() and makeFormattedXMLString()
 */
string make_xml(hash h, *int flags, *string encoding) [flags=RET_VALUE_ONLY] {
   if (!hash_ok(h)) {
      xsink->raiseException("MAKE-XML-STRING-PARAMETER-EXCEPTION",
                            "this variant of make_xml() expects a hash with a single key for the top-level XML element name without multi-list value");
      return 0;
   }

   const QoreEncoding* qe = encoding ? QEM.findCreate(encoding) : QCS_DEFAULT;
   return make_xml_intern(xsink, 0, h, qe, flags);
}

//! serializes a hash into an XML string with various options of formatting
/** @par Example:
    @code string xml = make_xml(hash, opts); @endcode

    @param h a hash of data to serialize: the hash must have one top-level key and no more or an exception will be raised
    @param opts formatting and other serialization settings; see @ref xml_generation_opts for more information

    @return an XML string corresponding to the input data

    @throw MAKE-XML-STRING-PARAMETER-EXCEPTION the hash passed does not have a single top-level key (either has no keys or more than one)
    @throw MAKE-XML-OPTS-INVALID the opts hash passed is not valid; see @ref xml_generation_opts for more information
    @throw MAKE-XML-ERROR An error occurred serializing the %Qore data to an XML string

    @see @ref serialization

    @since xml 1.4
 */
string make_xml(hash h, hash opts) [flags=RET_VALUE_ONLY] {
   if (!hash_ok(h)) {
      xsink->raiseException("MAKE-XML-STRING-PARAMETER-EXCEPTION",
                            "this variant of make_xml() expects a hash with a single key for the top-level XML element name without multi-list value");
      return 0;
   }
   try {
       return make_xml_intern(xsink, nullptr, h, MakeXmlOpts::createFromHash(opts));
   } catch (const MakeXmlOpts::InvalidHash &exc) {
      xsink->raiseException("MAKE-XML-OPTS-INVALID",
                            "the opts hash passed is not valid; invalid argument: '%s'",
                            exc.what());
      return 0;
   }
}

//! serializes a hash into an XML string without whitespace formatting but with an XML header
/** @param key top-level key
    @param h the rest of the data to serialize under the top-level key
    @param encoding an optional string giving the encoding for the output XML string; if this parameter is missing, the output string will have the default encoding

    @return an XML string corresponding to the input data, without whitespace formatting but with an XML header

    @throw MAKE-XML-ERROR An error occurred serializing the %Qore data to an XML string

    @see @ref serialization

    @deprecated use get_xml_string(); camel-case function names were deprecated in xml 1.3
 */
string makeXMLString(string key, hash h, *string encoding) [flags=RET_VALUE_ONLY,DEPRECATED] {
   const QoreEncoding* qe = encoding ? QEM.findCreate(encoding) : QCS_DEFAULT;
   return make_xml_intern(xsink, key, h, qe);
}

//! serializes a hash into an XML string without whitespace formatting but with an XML header
/** @param h a hash of data to serialize: the hash must have one top-level key and no more or an exception will be raised
    @param encoding an optional string giving the encoding for the output XML string; if this parameter is missing, the output string will have the default encoding

    @return an XML string corresponding to the input data, without whitespace formatting but with an XML header

    @throw MAKE-XML-STRING-PARAMETER-EXCEPTION the hash passed not not have a single top-level key (either has no keys or more than one)
    @throw MAKE-XML-ERROR An error occurred serializing the %Qore data to an XML string

    @see @ref serialization

    @deprecated use make_xml(); camel-case function names were deprecated in xml 1.3
 */
string makeXMLString(hash h, *string encoding) [flags=RET_VALUE_ONLY,DEPRECATED] {
   if (!hash_ok(h)) {
      xsink->raiseException("MAKE-XML-STRING-PARAMETER-EXCEPTION",
                            "this variant of makeXMLString() expects a hash with a single key for the top-level XML element name without multi-list value");
      return 0;
   }

   const QoreEncoding* qe = encoding ? QEM.findCreate(encoding) : QCS_DEFAULT;
   return make_xml_intern(xsink, 0, h, qe);
}

//! serializes a hash into an XML string with whitespace formatting and with an XML header
/** @param key top-level key
    @param h the rest of the data to serialize under the top-level key
    @param encoding an optional string giving the encoding for the output XML string; if this parameter is missing, the output string will have the default encoding

    @return an XML string corresponding to the input data, with whitespace formatting and with an XML header

    @throw MAKE-XML-ERROR An error occurred serializing the %Qore data to an XML string

    @see @ref serialization

    @deprecated use make_xml(); camel-case function names were deprecated in xml 1.3
*/
string makeFormattedXMLString(string key, hash h, *string encoding) [flags=RET_VALUE_ONLY,DEPRECATED] {
   const QoreEncoding* qe = encoding ? QEM.findCreate(encoding) : QCS_DEFAULT;

   return make_xml_intern(xsink, key, h, qe);
}

//! serializes a hash into an XML string with whitespace formatting and with an XML header
/** @param h a hash of data to serialize: the hash must have one top-level key and no more or an exception will be raised
    @param encoding an optional string giving the encoding for the output XML string; if this parameter is missing, the output string will have the default encoding

    @return an XML string corresponding to the input data, with whitespace formatting and with an XML header

    @throw MAKE-FORMATTED-XML-STRING-PARAMETER-EXCEPTION the hash passed not not have a single top-level key (either has no keys or more than one)
    @throw MAKE-XML-ERROR An error occurred serializing the %Qore data to an XML string

    @see @ref serialization

    @deprecated use make_xml(); camel-case function names were deprecated in xml 1.3
 */
string makeFormattedXMLString(hash h, *string encoding) [flags=RET_VALUE_ONLY,DEPRECATED] {
   if (!hash_ok(h)) {
      xsink->raiseException("MAKE-FORMATTED-XML-STRING-PARAMETER-EXCEPTION",
                            "this variant of makeFormattedXMLString() expects a hash with a single key for the top-level XML element name without multi-list value");
      return 0;
   }

   const QoreEncoding* qe = encoding ? QEM.findCreate(encoding) : QCS_DEFAULT;
   return make_xml_intern(xsink, 0, h, qe, XGF_ADD_FORMATTING);
}

//! serializes a hash into an XML string without whitespace formatting and without an XML header
/** @par Example:
    @code string xml = make_xml_fragment(hash); @endcode

    @param h a hash of data to serialize: the hash can have any number of keys
    @param flags optional formatting flags; see @ref xml_generation_constants for more information
    @param encoding an optional string giving the encoding for the output XML string; if this parameter is missing, the output string will have the default encoding

    @return an XML string corresponding to the input data, without whitespace formatting and without an XML header

    @throw MAKE-XML-ERROR An error occurred serializing the %Qore data to an XML string

    @see @ref serialization

    @since xml 1.3 as a replacement for deprecated camel-case makeXMLFragment()
 */
string make_xml_fragment(hash h, *int flags, *string encoding) [flags=RET_VALUE_ONLY] {
   const QoreEncoding* qe = encoding ? QEM.findCreate(encoding) : QCS_DEFAULT;

   SimpleRefHolder<QoreStringNode> str(new QoreStringNode(qe));
   if (make_xml(xsink, *(*str), *h, 0, MakeXmlOpts::createFromFlags(flags, qe)))
      return 0;

   return str.release();
}

//! serializes a hash into an XML string without whitespace formatting and without an XML header
/** @param h a hash of data to serialize: the hash can have any number of keys
    @param encoding an optional string giving the encoding for the output XML string; if this parameter is missing, the output string will have the default encoding

    @return an XML string corresponding to the input data, without whitespace formatting and without an XML header

    @throw MAKE-XML-ERROR An error occurred serializing the %Qore data to an XML string

    @see @ref serialization

    @deprecated use make_xml_fragment(); camel-case function names were deprecated in xml 1.3
 */
string makeXMLFragment(hash h, *string encoding) [flags=RET_VALUE_ONLY,DEPRECATED] {
   const QoreEncoding* qe = encoding ? QEM.findCreate(encoding) : QCS_DEFAULT;

   SimpleRefHolder<QoreStringNode> str(new QoreStringNode(qe));
   if (make_xml(xsink, *(*str), *h, 0, MakeXmlOpts()))
      return 0;

   return str.release();
}

//! This is a variant that is basically a noop, included for backwards-compatibility for functions that ignored type errors in the calling parameters
/**
 */
nothing makeXMLFragment() [flags=RUNTIME_NOOP,DEPRECATED] {
}

//! serializes a hash into an XML string with whitespace formatting but without an XML header
/** @param h a hash of data to serialize: the hash can have any number of keys
    @param encoding an optional string giving the encoding for the output XML string; if this parameter is missing, the output string will have the default encoding

    @return an XML string corresponding to the input data, with whitespace formatting but without an XML header

    @throw MAKE-XML-ERROR An error occurred serializing the %Qore data to an XML string

    @see @ref serialization

    @deprecated use make_xml_fragment(); camel-case function names were deprecated in xml 1.3
 */
string makeFormattedXMLFragment(hash h, *string encoding) [flags=RET_VALUE_ONLY,DEPRECATED] {
   const QoreEncoding* qe = encoding ? QEM.findCreate(encoding) : QCS_DEFAULT;

   SimpleRefHolder<QoreStringNode> str(new QoreStringNode(qe));
   MakeXmlOpts opts;
   opts.m_formatWithWhitespaces = true;
   if (make_xml(xsink, *(*str), *h, 0, opts))
      return 0;

   return str.release();
}

//! This is a variant that is basically a noop, included for backwards-compatibility for functions that ignored type errors in the calling parameters
/**
 */
nothing makeFormattedXMLFragment() [flags=RUNTIME_NOOP,DEPRECATED] {
}

//! Parses an XML string and returns a %Qore hash structure
/** @par Example:
    @code hash h = parse_xml(xmlstr); @endcode

    @param xml the XML string to parse
    @param pflags XML parsing flags; see @ref xml_parsing_constants for more information
    @param encoding an optional string giving the encoding for the output XML string; if this parameter is missing, all strings in the output hash will have the default encoding

    @return a %Qore hash structure corresponding to the XML input string

    @throw PARSE-XML-EXCEPTION Error parsing the XML string

    @note the default is to parse XML as serialized data; to preserve key order in XML strings for higher fidelity to the original string when serializing back to XML, use the @ref XPF_PRESERVE_ORDER flag when parsing

    @note use the @ref XPF_ADD_COMMENTS to process XML comments and put them in hash as elements with '^comment^' key

    @see @ref serialization

    @since xml 1.3 as a replacement for deprecated camel-case parseXML() and parseXMLAsData()
*/
hash parse_xml(string xml, *int pflags, *string encoding) [flags=RET_VALUE_ONLY] {
   //printd(5, "parseXMLintern(%d, %s)\n", as_data, p0->getBuffer());

   // convert to UTF-8
   TempEncodingHelper str(xml, QCS_UTF8, xsink);
   if (!str)
      return 0;

   QoreXmlReader reader(*str, QORE_XML_PARSER_OPTIONS, xsink);
   if (!reader)
      return 0;

   return reader.parseXmlData(encoding ? QEM.findCreate(encoding) : QCS_DEFAULT, pflags, xsink);
}

//! Parses an XML string and returns a %Qore hash structure
/** If duplicate, out-of-order XML elements are found in the input string, they are deserialized to %Qore hash elements with the same name as the XML element but including a caret \c '^' and a numeric prefix to maintain the same key order in the %Qore hash as in the input XML string.

    This function should only be used when it is important to maintain the XML element order in the resulting %Qore data structure (for example, when the data must be re-serialized to an XML string and the element order within a subelement must be maintained), for example, when parsing and reserializing an OSX property list in XML format.   In all other cases, parseXMLAsData() should be used instead.

    @param xml the XML string to parse
    @param encoding an optional string giving the encoding for the output XML string; if this parameter is missing, all strings in the output hash will have the default encoding

    @return a %Qore hash structure corresponding to the XML input string

    @throw PARSE-XML-EXCEPTION Error parsing the XML string

    @see @ref serialization

    @deprecated use parse_xml(); camel-case function names were deprecated in xml 1.3
*/
hash parseXML(string[doc] xml, *string[doc] encoding) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return parse_xml_intern(XPF_PRESERVE_ORDER, args, xsink);
}

//! This is a variant that is basically a noop, included for backwards-compatibility for functions that ignored type errors in the calling parameters
/**
 */
nothing parseXML() [flags=RUNTIME_NOOP,DEPRECATED] {
}

//! Parses an XML string as data (does not necessarily preserve key order) and returns a %Qore hash structure
/** This function does not preserve hash order with out-of-order duplicate keys; all duplicate keys are collapsed to the same list.

    Note that data deserialized with this function may not be reserialized to an identical XML string to the input due to the fact that duplicate, out-of-order XML elements are collapsed into lists in the resulting %Qore hash, thereby losing the order in the original XML string.

    For a similar function preserving the order of keys in the XML in the resulting %Qore hash by generating %Qore hash element names with numeric suffixes, see parseXML().

    @param xml the XML string to parse
    @param encoding an optional string giving the encoding for the output XML string; if this parameter is missing, all strings in the output hash will have the default encoding

    @return a %Qore hash structure corresponding to the XML input string

    @throw PARSE-XML-EXCEPTION Error parsing the XML string

    @see
    - parseXML()
    - @ref serialization

    @deprecated use parse_xml(); camel-case function names were deprecated in xml 1.3
*/
hash parseXMLAsData(string[doc] xml, *string[doc] encoding) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return parse_xml_intern(XPF_NONE, args, xsink);
}

//! This is a variant that is basically a noop, included for backwards-compatibility for functions that ignored type errors in the calling parameters
/**
 */
nothing parseXMLAsData() [flags=RUNTIME_NOOP,DEPRECATED] {
}

//! Parses an XML string, validates the XML string against an XSD schema string, and returns a %Qore hash structure
/** @par Example:
    @code hash h = parse_xml_with_schema(xml, xsd); @endcode

    If any errors occur parsing the XSD string, parsing the XML string, or validating the XML against the XSD, exceptions are thrown. If no encoding string argument is passed, then all strings in the resulting hash will be in UTF-8 encoding regardless of the input encoding of the XML string.

    The availability of this function depends on the presence of libxml2's \c xmlTextReaderSetSchema() function when the xml module was compiled; for maximum portability check the constant @ref optionconstants "HAVE_PARSEXMLWITHSCHEMA" before running this function.

    @param xml the XML string to parse
    @param xsd the XSD schema string to use to validate the XML string
    @param pflags XML parsing flags; see @ref xml_parsing_constants for more information
    @param encoding an optional string giving the string encoding of any strings output; if this parameter is missing, the any strings output in the output hash will have UTF-8 encoding

    @return a %Qore hash structure corresponding to the input

    @throw PARSE-XML-EXCEPTION error parsing the XML string
    @throw XSD-SYNTAX-ERROR invalid XSD string
    @throw XSD-VALIDATION-ERROR the XML did not pass schema validation
    @throw MISSING-FEATURE-ERROR this exception is thrown when the function is not available; for maximum portability, check the constant @ref optionconstants "HAVE_PARSEXMLWITHSCHEMA" before calling this function

    @see
    - parse_xml_with_dtd()
    - parse_xml_with_relaxng()
    - @ref serialization

    @since xml 1.3 as a replacement for deprecated camel-case parseXMLWithSchema() and parseXMLAsDataWithSchema()
*/
hash parse_xml_with_schema(string[doc] xml, string[doc] xsd, *int[doc] pflags, *string[doc] encoding) [flags=RET_VALUE_ONLY] {
   return parse_xml_with_schema_intern(xsink, true, args);
}

//! Parses an XML string, validates the XML string against an XSD schema string, and returns a %Qore hash structure
/** If any errors occur parsing the XSD string, parsing the XML string, or validating the XML against the XSD, exceptions are thrown. If no encoding string argument is passed, then all strings in the resulting hash will be in UTF-8 encoding regardless of the input encoding of the XML string.

    If duplicate, out-of-order XML elements are found in the input string, they are deserialized to %Qore hash elements with the same name as the XML element but including a caret \c '^' and a numeric prefix to maintain the same key order in the %Qore hash as in the input XML string.

    The availability of this function depends on the presence of libxml2's \c xmlTextReaderSetSchema() function when the xml module was compiled; for maximum portability check the constant @ref optionconstants "HAVE_PARSEXMLWITHSCHEMA" before running this function.

    @param xml the XML string to parse
    @param xsd the XSD schema string to use to validate the XML string
    @param encoding an optional string giving the string encoding of any strings output; if this parameter is missing, the any strings output in the output hash will have UTF-8 encoding

    @return a %Qore hash structure corresponding to the input

    @throw PARSE-XML-EXCEPTION error parsing the XML string
    @throw XSD-SYNTAX-ERROR invalid XSD string
    @throw XSD-VALIDATION-ERROR the XML did not pass schema validation
    @throw MISSING-FEATURE-ERROR this exception is thrown when the function is not available; for maximum portability, check the constant @ref optionconstants "HAVE_PARSEXMLWITHSCHEMA" before calling this function

    @deprecated use parse_xml_with_schema(); camel-case function names were deprecated in xml 1.3
*/
hash parseXMLWithSchema(string[doc] xml, string[doc] xsd, *string[doc] encoding) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return parse_xml_with_schema_intern(xsink, false, args, XPF_PRESERVE_ORDER);
}

//! Parses an XML string as data (does not preserve hash order with out-of-order duplicate keys: collapses all to the same list), validates the XML string against an XSD schema string, and returns a %Qore hash structure
/** If any errors occur parsing the XSD string, parsing the XML string, or validating the XML against the XSD, exceptions are thrown. If no encoding string argument is passed, then all strings in the resulting hash will be in UTF-8 encoding regardless of the input encoding of the XML string.

    Please note that data deserialized with this function may not be reserialized to an identical XML string to the input due to the fact that duplicate, out-of-order XML elements are collapsed into lists in the resulting %Qore hash, thereby losing the order in the original XML string.

    If any errors occur parsing the XSD string, parsing the XML string, or validating the XML against the XSD, exceptions are thrown.  If no encoding string argument is passed, then all strings in the resulting hash will be in UTF-8 encoding regardless of the input encoding of the XML string.

    The availability of this function depends on the presence of libxml2's \c xmlTextReaderSetSchema() function when the xml module was compiled; for maximum portability check the constant @ref optionconstants "HAVE_PARSEXMLWITHSCHEMA" before running this function.

    @param xml the XML string to parse
    @param xsd the XSD schema string to use to validate the XML string
    @param encoding an optional string giving the string encoding of any strings output; if this parameter is missing, the any strings output in the output hash will have UTF-8 encoding

    @return a %Qore hash structure corresponding to the input

    @throw PARSE-XML-EXCEPTION error parsing the XML string
    @throw XSD-SYNTAX-ERROR invalid XSD string
    @throw XSD-VALIDATION-ERROR the XML did not pass schema validation
    @throw MISSING-FEATURE-ERROR this exception is thrown when the function is not available; for maximum portability, check the constant @ref optionconstants "HAVE_PARSEXMLWITHSCHEMA" before calling this function

    @deprecated use parse_xml_with_schema(); camel-case function names were deprecated in xml 1.3
*/
hash parseXMLAsDataWithSchema(string[doc] xml, string[doc] xsd, *string[doc] encoding) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return parse_xml_with_schema_intern(xsink, false, args);
}

//! Parses an XML string, validates the XML string against a RelaxNG schema string, and returns a %Qore hash structure
/** @par Example:
    @code hash h = parse_xml_with_relaxng(xml, relaxng); @endcode

    If any errors occur parsing the RelaxNG string, parsing the XML string, or validating the XML against the RelaxNG schema, exceptions are thrown. If no encoding string argument is passed, then all strings in the resulting hash will be in UTF-8 encoding regardless of the input encoding of the XML string.

    The availability of this function depends on the presence of libxml2's \c xmlTextReaderRelaxNGSetSchema() function when the xml module was compiled; for maximum portability check the constant @ref optionconstants "HAVE_PARSEXMLWITHRELAXNG" before running this function.

    @param xml the XML string to parse
    @param relaxng the RelaxNG schema string to use to validate the XML string
    @param pflags XML parsing flags; see @ref xml_parsing_constants for more information
    @param encoding an optional string giving the string encoding of any strings output; if this parameter is missing, the any strings output in the output hash will have UTF-8 encoding

    @return a %Qore hash structure corresponding to the input

    @throw PARSE-XML-EXCEPTION error parsing the XML string
    @throw RELAXNG-SYNTAX-ERROR invalid RelaxNG string
    @throw RELAXNG-VALIDATION-ERROR the XML did not pass RelaxNG schema validation
    @throw MISSING-FEATURE-ERROR this exception is thrown when the function is not available; for maximum portability, check the constant @ref optionconstants "HAVE_PARSEXMLWITHRELAXNG" before calling this function

    @see
    - parse_xml_with_dtd()
    - parse_xml_with_schema()
    - @ref serialization
*/
hash parse_xml_with_relaxng(string[doc] xml, string[doc] relaxng, *int[doc] pflags, *string[doc] encoding) [flags=RET_VALUE_ONLY] {
   return parse_xml_with_relaxng_intern(xsink, true, args);
}

//! Parses an XML string, validates the XML string against a RelaxNG schema string, and returns a %Qore hash structure
/** If any errors occur parsing the RelaxNG string, parsing the XML string, or validating the XML against the RelaxNG schema, exceptions are thrown. If no encoding string argument is passed, then all strings in the resulting hash will be in UTF-8 encoding regardless of the input encoding of the XML string.

    If duplicate, out-of-order XML elements are found in the input string, they are deserialized to %Qore hash elements with the same name as the XML element but including a caret "^" and a numeric prefix to maintain the same key order in the %Qore hash as in the input XML string.

    The availability of this function depends on the presence of libxml2's \c xmlTextReaderRelaxNGSetSchema() function when the xml module was compiled; for maximum portability check the constant @ref optionconstants "HAVE_PARSEXMLWITHRELAXNG" before running this function.

    @param xml the XML string to parse
    @param relaxng the RelaxNG schema string to use to validate the XML string
    @param encoding an optional string giving the string encoding of any strings output; if this parameter is missing, the any strings output in the output hash will have UTF-8 encoding

    @return a %Qore hash structure corresponding to the input

    @throw PARSE-XML-EXCEPTION error parsing the XML string
    @throw RELAXNG-SYNTAX-ERROR invalid RelaxNG string
    @throw RELAXNG-VALIDATION-ERROR the XML did not pass RelaxNG schema validation
    @throw MISSING-FEATURE-ERROR this exception is thrown when the function is not available; for maximum portability, check the constant @ref optionconstants "HAVE_PARSEXMLWITHRELAXNG" before calling this function

    @deprecated use parse_xml_with_relaxng(); camel-case function names were deprecated in xml 1.3
*/
hash parseXMLWithRelaxNG(string[doc] xml, string[doc] relaxng, *string[doc] encoding) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return parse_xml_with_relaxng_intern(xsink, false, args, XPF_PRESERVE_ORDER);
}

//! Parses an XML string as data (does not preserve hash order with out-of-order duplicate keys: collapses all to the same list), validates the XML string against a RelaxNG schema string, and returns a %Qore hash structure
/** If any errors occur parsing the RelaxNG schema string, parsing the XML string, or validating the XML against the XSD, exceptions are thrown. If no encoding string argument is passed, then all strings in the resulting hash will be in UTF-8 encoding regardless of the input encoding of the XML string.

    Please note that data deserialized with this function may not be reserialized to an identical XML string to the input due to the fact that duplicate, out-of-order XML elements are collapsed into lists in the resulting %Qore hash, thereby losing the order in the original XML string.

    The availability of this function depends on the presence of libxml2's \c xmlTextReaderRelaxNGSetSchema() function when the xml module was compiled; for maximum portability check the constant @ref optionconstants "HAVE_PARSEXMLWITHRELAXNG" before running this function.

    @param xml the XML string to parse
    @param relaxng the RelaxNG schema string to use to validate the XML string
    @param encoding an optional string giving the string encoding of any strings output; if this parameter is missing, the any strings output in the output hash will have UTF-8 encoding

    @return a %Qore hash structure corresponding to the input

    @throw PARSE-XML-EXCEPTION error parsing the XML string
    @throw RELAXNG-SYNTAX-ERROR invalid RelaxNG string
    @throw RELAXNG-VALIDATION-ERROR the XML did not pass RelaxNG schema validation
    @throw MISSING-FEATURE-ERROR this exception is thrown when the function is not available; for maximum portability, check the constant @ref optionconstants "HAVE_PARSEXMLWITHRELAXNG" before calling this function

    @deprecated use parse_xml_with_relaxng(); camel-case function names were deprecated in xml 1.3
 */
hash parseXMLAsDataWithRelaxNG(string[doc] xml, string[doc] relaxng, *string[doc] encoding) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return parse_xml_with_relaxng_intern(xsink, false, args);
}

//! Parses an XML string, validates the XML string against a DTD string, and returns a %Qore hash structure
/** @par Example:
    @code hash h = parse_xml_with_dtd(xml, dtd); @endcode

    If any errors occur parsing the DTD string, parsing the XML string, or validating the XML against the DTD, exceptions are thrown. If no encoding string argument is passed, then all strings in the resulting hash will be in UTF-8 encoding regardless of the input encoding of the XML string.

    @param xml the XML string to parse
    @param dtd the DTD string to use to validate the XML string
    @param pflags XML parsing flags; see @ref xml_parsing_constants for more information
    @param encoding an optional string giving the string encoding of any strings output; if this parameter is missing, the any strings output in the output hash will have UTF-8 encoding

    @return a %Qore hash structure corresponding to the input

    @throw PARSE-XML-EXCEPTION error parsing the XML string
    @throw DTD-SYNTAX-ERROR invalid DTD string
    @throw DTD-VALIDATION-ERROR the DTD did not pass validation

    @see
    - parse_xml_with_schema()
    - parse_xml_with_relaxng()
    - @ref serialization

    @since xml 1.4
*/
hash parse_xml_with_dtd(string xml, string dtd, *int pflags, *string encoding) [flags=RET_VALUE_ONLY] {
    SimpleRefHolder<QoreXmlDocData> xd(new QoreXmlDocData(xml));
    if (!xd->isValid()) {
       xsink->raiseException("PARSE-XML-EXCEPTION", "error parsing XML string in parse_xml_with_dtd()");
       return QoreValue();
    }

    if (xd->validateDtd(dtd, xsink))
        return QoreValue();

    QoreXmlReader reader(xd->getDocPtr(), xsink);
    if (*xsink)
        return QoreValue();
    return reader.parseXmlData(encoding ? QEM.findCreate(encoding) : QCS_UTF8, pflags, xsink);
}
//@}

/** @defgroup xmlrpc_functions XML-RPC Functions
 */
//@{
namespace Qore::Xml;

//! Serializes the argument into an XML string in XML-RPC call format
/** @param method the method name for the XML-RPC call
    @param args a single argument or a list of arguments to the XML-RPC call
    @param flags optional formatting flags; see @ref xml_generation_constants for more information
    @param encoding an optional string giving the encoding for the output XML string; if this parameter is missing, the output string will have the default encoding

    @return an XML string in XML-RPC call format in the default encoding, without whitespace formatting

    @throw XMLRPC-SERIALIZATION-ERROR empty member name in hash or cannot serialize type to XML-RPC (ex: object)

    @par Example:
    @code string xmlcall = make_xmlrpc_call("omq.system.start-workflow", hash); @endcode

    @see @ref XMLRPC

    @since xml 1.3 as a replacement for deprecated camel-case functions:
    - makeFormattedXMLRPCCallString()
    - makeFormattedXMLRPCCallStringArgs()
    - makeFormattedXMLRPCCallStringArgsWithEncoding()
    - makeFormattedXMLRPCCallStringWithEncoding()
    - makeXMLRPCCallString()
    - makeXMLRPCCallStringArgs()
    - makeXMLRPCCallStringArgsWithEncoding()
    - makeXMLRPCCallStringWithEncoding()
*/
string make_xmlrpc_call(string[doc] method, any[doc] args, *int flags, *string encoding) [flags=RET_VALUE_ONLY] {
   return make_xmlrpc_call_args(xsink, encoding ? QEM.findCreate(encoding) : QCS_DEFAULT, 0, args, flags);
}

//! Serializes the argument into an XML string in XML-RPC call format without whitespace formatting
/** @param method the method name for the XML-RPC call
    Additional arguments are serialized according to the default XML-RPC serialization rules

    @return an XML string in XML-RPC call format in the default encoding, without whitespace formatting

    @throw XMLRPC-SERIALIZATION-ERROR empty member name in hash or cannot serialize type to XML-RPC (ex: object)

    @see @ref XMLRPC

    @deprecated use make_xmlrpc_call(); camel-case function names were deprecated in xml 1.3
*/
string makeXMLRPCCallString(string[doc] method, ...) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return make_xmlrpc_call(xsink, QCS_DEFAULT, 0, args);
}

//! Serializes the argument into an XML string in XML-RPC call format without whitespace formatting with an explicit encoding
/** @param encoding a string giving the output encoding for the resulting XML string
    @param method the method name for the XML-RPC call

    Additional arguments are serialized according to the default XML-RPC serialization rules

    @return an XML string in XML-RPC call format in the encoding given by the first argument, without whitespace formatting

    @throw XMLRPC-SERIALIZATION-ERROR empty member name in hash or cannot serialize type to XML-RPC (ex: object)

    @see @ref XMLRPC

    @deprecated use make_xmlrpc_call(); camel-case function names were deprecated in xml 1.3
*/
string makeXMLRPCCallStringWithEncoding(string encoding, string[doc] method, ...) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return make_xmlrpc_call(xsink, QEM.findCreate(encoding), 1, args);
}

//! Serializes the argument into an XML string in XML-RPC call format without whitespace formatting
/** @param method the method name for the XML-RPC call
    @param args a single argument or a list of arguments to the call

    @return an XML string in XML-RPC call format in the default encoding, without whitespace formatting

    @throw XMLRPC-SERIALIZATION-ERROR empty member name in hash or cannot serialize type to XML-RPC (ex: object)

    @see @ref XMLRPC

    @deprecated use make_xmlrpc_call(); camel-case function names were deprecated in xml 1.3
*/
string makeXMLRPCCallStringArgs(string[doc] method, any[doc] args) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return make_xmlrpc_call_args(xsink, QCS_DEFAULT, 0, args);
}

//! Serializes the argument into an XML string in XML-RPC call format without whitespace formatting with an explicit encoding
/** @param encoding a string giving the output encoding for the resulting XML string
    @param method the method name for the XML-RPC call
    @param args a single argument or a list of arguments to the call

    @return a string in XML-RPC call format in the encoding given by the first argument, without whitespace formatting

    @throw XMLRPC-SERIALIZATION-ERROR empty member name in hash or cannot serialize type to XML-RPC (ex: object)

    @see @ref XMLRPC

    @deprecated use make_xmlrpc_call(); camel-case function names were deprecated in xml 1.3
*/
string makeXMLRPCCallStringArgsWithEncoding(string encoding, string[doc] method, any[doc] args) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return make_xmlrpc_call_args(xsink, QEM.findCreate(encoding), 1, args);
}

//! Serializes the argument into an XML string in XML-RPC fault response format without whitespace formatting
/** @param code the fault code for the response; will be converted to an integer (stored under key \c 'faultCode' as an int)
    @param msg the fault message string; the encoding of this argument will define the output encoding of the fault string returned (stored under key \c 'faultString' as a string)
    @param flags optional formatting flags; see @ref xml_generation_constants for more information
    @param encoding an optional string giving the encoding for the output XML string; if this parameter is missing, the output string will have the default encoding

    @return a string in XML-RPC fault format in the same encoding as given by the msg argument, without whitespace formatting

    @par Example:
    @code string response = make_xmlrpc_fault(500, errmsg); @endcode

    @see @ref XMLRPC

    @since xml 1.3 as a replacement for deprecated camel-case functions:
    - makeXMLRPCFaultResponseString()
    - makeXMLRPCFaultResponseStringWithEncoding()
    - makeFormattedXMLRPCFaultResponseString()
    - makeFormattedXMLRPCFaultResponseStringWithEncoding()
*/
string make_xmlrpc_fault(softint code, string msg, *int flags, *string encoding) [flags=CONSTANT] {
   return make_xmlrpc_fault(xsink, encoding ? QEM.findCreate(encoding) : 0, code, msg, flags);
}

//! Serializes the argument into an XML string in XML-RPC fault response format without whitespace formatting
/** @param code the fault code for the response; will be converted to an integer (stored under key \c 'faultCode' as an int)
    @param msg the fault message string; the encoding of this argument will define the output encoding of the fault string returned (stored under key \c 'faultString' as a string)

    @return a string in XML-RPC fault format in the same encoding as given by the msg argument, without whitespace formatting

    @see @ref XMLRPC

    @deprecated use make_xmlrpc_fault(); camel-case function names were deprecated in xml 1.3
*/
string makeXMLRPCFaultResponseString(softint code, string msg) [flags=CONSTANT,DEPRECATED] {
   return make_xmlrpc_fault(xsink, 0, code, msg);
}

//! Serializes the argument into an XML string in XML-RPC fault response format without whitespace formatting with an explicit output encoding
/** @param encoding a string giving the output encoding for the resulting XML string
    @param code the fault code for the response; will be converted to an integer (stored under key \c 'faultCode' as an int)
    @param msg the fault message string (stored under key \c 'faultString' as a string)

    @return a string in XML-RPC fault format in the encoding given by the first argument, without whitespace formatting

    @throw ENCODING-CONVERSION-ERROR error converting message string to specified output encoding

    @see @ref XMLRPC

    @deprecated use make_xmlrpc_fault(); camel-case function names were deprecated in xml 1.3
*/
string makeXMLRPCFaultResponseStringWithEncoding(string encoding, softint code, string msg) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return make_xmlrpc_fault(xsink, QEM.findCreate(encoding), code, msg);
}

//! Serializes the argument into an XML string in XML-RPC fault response format with whitespace formatting
/** @param code the fault code for the response; will be converted to an integer (stored under key \c 'faultCode' as an int)
    @param msg the fault message string; the encoding of this argument will define the output encoding of the fault string returned (stored under key \c 'faultString' as a string)

    @return a string in XML-RPC fault format in the same encoding as given by the msg argument, with whitespace formatting

    @see @ref XMLRPC

    @deprecated use make_xmlrpc_fault(); camel-case function names were deprecated in xml 1.3
*/
string makeFormattedXMLRPCFaultResponseString(softint code, string msg) [flags=CONSTANT,DEPRECATED] {
   return make_xmlrpc_fault(xsink, 0, code, msg, XGF_ADD_FORMATTING);
}

//! Serializes the argument into an XML string in XML-RPC fault response format with whitespace formatting with an explicit output encoding
/** @param encoding a string giving the output encoding for the resulting XML string
    @param code the fault code for the response; will be converted to an integer (stored under key \c 'faultCode' as an int)
    @param msg the fault message string (stored under key \c 'faultString' as a string)

    @return a string in XML-RPC fault format in the encoding given by the first argument, with whitespace formatting

    @throw ENCODING-CONVERSION-ERROR error converting message string to specified output encoding

    @see @ref XMLRPC

    @deprecated use make_xmlrpc_fault(); camel-case function names were deprecated in xml 1.3
*/
string makeFormattedXMLRPCFaultResponseStringWithEncoding(string encoding, softint code, string msg) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return make_xmlrpc_fault(xsink, QEM.findCreate(encoding), code, msg, XGF_ADD_FORMATTING);
}

//! Serializes the arguments into an XML string formatted for an XML-RPC response without whitespace formatting
/** Any top-level arguments to the function will be serialized as the top-level params of the response message

    @param call_args a single argument or a list of arguments that represent the XML-RPC response
    @param flags optional formatting flags; see @ref xml_generation_constants for more information
    @param encoding an optional string giving the encoding for the output XML string; if this parameter is missing, the output string will have the default encoding

    @return a string in XML-RPC response format; the encoding of the resulting string will always be the default encoding

    @throw XMLRPC-SERIALIZATION-ERROR empty member name in hash or cannot serialize type to XML-RPC (ex: object)

    @par Example:
    @code string response = make_xmlrpc_response(answer); @endcode

    @see @ref XMLRPC

    @since xml 1.3 as a replacement for deprecated camel-case functions:
    - makeFormattedXMLRPCResponseString()
    - makeFormattedXMLRPCResponseStringWithEncoding()
    - makeXMLRPCResponseString()
    - makeXMLRPCResponseStringWithEncoding()
*/
string make_xmlrpc_response(any call_args, *int flags, *string encoding) [flags=RET_VALUE_ONLY] {
   return make_xmlrpc_response_args(xsink, encoding ? QEM.findCreate(encoding) : QCS_DEFAULT, call_args, flags);
}

//! Serializes the arguments into an XML string formatted for an XML-RPC response without whitespace formatting
/** Any top-level arguments to the function will be serialized as the top-level params of the response message

    @return a string in XML-RPC response format; the encoding of the resulting string will always be the default encoding

    @throw XMLRPC-SERIALIZATION-ERROR empty member name in hash or cannot serialize type to XML-RPC (ex: object)

    @see @ref XMLRPC

    @deprecated use make_xmlrpc_response(); camel-case function names were deprecated in xml 1.3
*/
string makeXMLRPCResponseString(...) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return make_xmlrpc_response(xsink, QCS_DEFAULT, 0, args);
}
//! Serializes the arguments into an XML string formatted for an XML-RPC response without whitespace formatting and with an explicit output encoding
/** @param encoding a string giving the output encoding for the resulting XML string
    Any top-level arguments after the first argument will be serialized as the top-level params of the response message
    @return a string in XML-RPC response format; the encoding will be that given by the first argument

    @throw XMLRPC-SERIALIZATION-ERROR empty member name in hash or cannot serialize type to XML-RPC (ex: object)

    @see @ref XMLRPC

    @deprecated use make_xmlrpc_response(); camel-case function names were deprecated in xml 1.3
*/
string makeXMLRPCResponseStringWithEncoding(string encoding, ...) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return make_xmlrpc_response(xsink, QEM.findCreate(encoding), 1, args);
}

//! Serializes the arguments into an XML string in XML-RPC value format without whitespace formatting and without an XML header
/** @param value the value to serialize to XML-RPC format
    @param encoding an optional string giving the encoding for the output XML string; if this parameter is missing, the output string will have the default encoding
    @param flags optional formatting flags; see @ref xml_generation_constants for more information
    @param encoding an optional string giving the encoding for the output XML string; if this parameter is missing, the output string will have the default encoding

    @return if the \a value argument is NOTHING, then NOTHING is returned, otherwise an XML string in XML-RPC value format without whitespace formatting and without an XML header is returned

    @throw XMLRPC-SERIALIZATION-ERROR empty member name in hash or cannot serialize type to XML-RPC (ex: object)

    @see @ref XMLRPC

    @since xml 1.3 as a replacement for deprecated camel-case makeXMLRPCValueString() and makeFormattedXMLRPCValueString()
 */
*string make_xmlrpc_value(any value, *int flags, *string encoding) [flags=RET_VALUE_ONLY] {
   return make_xmlrpc_value(xsink, value, encoding, flags);
}

//! Serializes the arguments into an XML string in XML-RPC value format without whitespace formatting and without an XML header
/** @param value the value to serialize to XML-RPC format
    @param encoding an optional string giving the encoding for the output XML string; if this parameter is missing, the output string will have the default encoding

    @return if the \a value argument is NOTHING, then NOTHING is returned, otherwise an XML string in XML-RPC value format without whitespace formatting and without an XML header is returned

    @throw XMLRPC-SERIALIZATION-ERROR empty member name in hash or cannot serialize type to XML-RPC (ex: object)

    @see @ref XMLRPC

    @deprecated use make_xmlrpc_value(); camel-case function names were deprecated in xml 1.3
 */
*string makeXMLRPCValueString(any value, *string encoding) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return make_xmlrpc_value(xsink, value, encoding);
}

//! Serializes the argument into an XML string in XML-RPC call format with whitespace formatting
/** @param method the method name for the XML-RPC call
    @param argv a single argument or a list of arguments to the call

    @return an XML string in XML-RPC call format in the default encoding, with whitespace formatting

    @throw XMLRPC-SERIALIZATION-ERROR empty member name in hash or cannot serialize type to XML-RPC (ex: object)

    @see @ref XMLRPC

    @deprecated use make_xmlrpc_call(); camel-case function names were deprecated in xml 1.3
*/
string makeFormattedXMLRPCCallStringArgs(string[doc] method, any[doc] argv) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return make_xmlrpc_call_args(xsink, QCS_DEFAULT, 0, args, XGF_ADD_FORMATTING);
}

//! Serializes the argument into an XML string in XML-RPC call format with whitespace formatting
/** @param encoding a string giving the output encoding for the resulting XML string
    @param method the method name for the XML-RPC call
    @param argv a single argument or a list of arguments to the call

    @return a string in XML-RPC call format in the encoding given by the first argument, with whitespace formatting

    @throw XMLRPC-SERIALIZATION-ERROR empty member name in hash or cannot serialize type to XML-RPC (ex: object)

    @see @ref XMLRPC

    @deprecated use make_xmlrpc_call(); camel-case function names were deprecated in xml 1.3
*/
string makeFormattedXMLRPCCallStringArgsWithEncoding(string encoding, string[doc] method, any[doc] argv) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return make_xmlrpc_call_args(xsink, QEM.findCreate(encoding), 1, args, XGF_ADD_FORMATTING);
}

//! Serializes the argument into an XML string in XML-RPC call format with whitespace formatting
/** @param method the method name for the XML-RPC call
    @param ... additional arguments are serialized according to the default XML-RPC serialization rules

    @return an XML string in XML-RPC call format in the default encoding, with whitespace formatting

    @throw XMLRPC-SERIALIZATION-ERROR empty member name in hash or cannot serialize type to XML-RPC (ex: object)

    @see @ref XMLRPC

    @deprecated use make_xmlrpc_call(); camel-case function names were deprecated in xml 1.3
*/
string makeFormattedXMLRPCCallString(string[doc] method, ...) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return make_xmlrpc_call(xsink, QCS_DEFAULT, 0, args, XGF_ADD_FORMATTING);
}

//! Serializes the argument into an XML string in XML-RPC call format with whitespace formatting with an explicit encoding
/** @param encoding a string giving the output encoding for the resulting XML string
    @param method the method name for the XML-RPC call

    Additional arguments are serialized according to the default XML-RPC serialization rules

    @return an XML string in XML-RPC call format in the encoding given by the first argument, with whitespace formatting

    @throw XMLRPC-SERIALIZATION-ERROR empty member name in hash or cannot serialize type to XML-RPC (ex: object)

    @see @ref XMLRPC

    @deprecated use make_xmlrpc_call(); camel-case function names were deprecated in xml 1.3
*/
string makeFormattedXMLRPCCallStringWithEncoding(string encoding, string[doc] method, ...) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return make_xmlrpc_call(xsink, QEM.findCreate(encoding), 1, args, XGF_ADD_FORMATTING);
}

//! Serializes the arguments into an XML string formatted for an XML-RPC response with whitespace formatting
/** @param ... any top-level arguments to the function will be serialized as the top-level params of the response message

    @return a string in XML-RPC response format with whitespace formatting; the encoding of the resulting string will always be the default encoding
    @throw XMLRPC-SERIALIZATION-ERROR empty member name in hash or cannot serialize type to XML-RPC (ex: object)

    @see @ref XMLRPC

    @deprecated use make_xmlrpc_response(); camel-case function names were deprecated in xml 1.3
*/
string makeFormattedXMLRPCResponseString(...) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return make_xmlrpc_response(xsink, QCS_DEFAULT, 0, args, XGF_ADD_FORMATTING);
}

//! Serializes the arguments into an XML string formatted for an XML-RPC response with whitespace formatting and with an explicit output encoding
/** @param encoding a string giving the output encoding for the resulting XML string
    @param ... any top-level arguments after the first argument will be serialized as the top-level params of the response message

    @return a string in XML-RPC response format with whitespace formatting; the encoding will be that given by the first argument

    @throw XMLRPC-SERIALIZATION-ERROR empty member name in hash or cannot serialize type to XML-RPC (ex: object)

    @see @ref XMLRPC

    @deprecated use make_xmlrpc_response(); camel-case function names were deprecated in xml 1.3
*/
string makeFormattedXMLRPCResponseStringWithEncoding(string encoding, ...) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return make_xmlrpc_response(xsink, QEM.findCreate(encoding), 0, args, XGF_ADD_FORMATTING);
}

//! Serializes the arguments into an XML string in XML-RPC value format with whitespace formatting but without an XML header
/** @param value the value to serialize to XML-RPC format
    @param encoding an optional string giving the encoding for the output XML string; if this parameter is missing, the output string will have the default encoding

    @return if the \a value argument is NOTHING, then NOTHING is returned, otherwise an XML string in XML-RPC value format with whitespace formatting but without an XML header is returned

    @throw XMLRPC-SERIALIZATION-ERROR empty member name in hash or cannot serialize type to XML-RPC (ex: object)

    @see @ref XMLRPC

    @deprecated use make_xmlrpc_value(); camel-case function names were deprecated in xml 1.3
 */
*string makeFormattedXMLRPCValueString(any value, *string encoding) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return make_xmlrpc_value(xsink, value, encoding, XGF_ADD_FORMATTING);
}

//! Deserializies an XML-RPC value string and returns a %Qore data structure representing the information
/** @param xml the XML string in XML-RPC value format to deserialize
    @param encoding an optional string giving the string encoding of any strings output; if this parameter is missing, the any strings output in the output hash will have the default encoding

    @return the %Qore value corresponding to the XML-RPC value string

    @throw PARSE-XMLRPC-ERROR syntax error parsing XML-RPC string

    @par Example:
    @code any data = parse_xmlrpc_value(xml); @endcode

    @see @ref XMLRPC

    @since xml 1.3 as a replacement for deprecated camel-case parseXMLRPCValue()
 */
any parse_xmlrpc_value(string xml, *string encoding) [flags=RET_VALUE_ONLY] {
   return parse_xmlrpc_value(xml, encoding, xsink);
}

//! Deserializies an XML-RPC value string and returns a %Qore data structure representing the information
/** @param xml the XML string in XML-RPC value format to deserialize
    @param encoding an optional string giving the string encoding of any strings output; if this parameter is missing, the any strings output in the output hash will have the default encoding

    @return the %Qore value corresponding to the XML-RPC value string

    @throw PARSE-XMLRPC-ERROR syntax error parsing XML-RPC string

    @see @ref XMLRPC

    @deprecated use parse_xmlrpc_value(); camel-case function names were deprecated in xml 1.3
 */
any parseXMLRPCValue(string xml, *string encoding) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return parse_xmlrpc_value(xml, encoding, xsink);
}

//! This is a variant that is basically a noop, included for backwards-compatibility for functions that ignored type errors in the calling parameters
/**
 */
nothing parseXMLRPCValue() [flags=RUNTIME_NOOP,DEPRECATED] {
}

//! Deserializies an XML-RPC call string, returning a %Qore data structure representing the call information
/** @param xml the XML string in XML-RPC call format to deserialize
    @param encoding an optional string giving the string encoding of any strings output; if this parameter is missing, the any strings output in the output hash will have the default encoding

    @return a hash representing the XML-RPC call with the following keys:
    - \c methodName: the name of the method being called
    - \c params: the arguments to the method

    @throw PARSE-XMLRPC-CALL-ERROR missing 'methodCall' or 'methodName' element or other syntax error
    @throw PARSE-XMLRPC-ERROR syntax error parsing XML-RPC string

    @par Example:
    @code hash h = parse_xmlrpc_call(xml); @endcode

    @see @ref XMLRPC

    @since xml 1.3 as a replacement for deprecated camel-case parseXMLRPCCall()
 */
hash parse_xmlrpc_call(string xml, *string encoding) [flags=RET_VALUE_ONLY] {
   return parse_xmlrpc_call(xml, encoding, xsink);
}

//! Deserializies an XML-RPC call string, returning a %Qore data structure representing the call information
/** @param xml the XML string in XML-RPC call format to deserialize
    @param encoding an optional string giving the string encoding of any strings output; if this parameter is missing, the any strings output in the output hash will have the default encoding

    @return a hash representing the XML-RPC call with the following keys:
    - \c methodName: the name of the method being called
    - \c params: the arguments to the method

    @throw PARSE-XMLRPC-CALL-ERROR missing 'methodCall' or 'methodName' element or other syntax error
    @throw PARSE-XMLRPC-ERROR syntax error parsing XML-RPC string

    @see @ref XMLRPC

    @deprecated use parse_xmlrpc_call(); camel-case function names were deprecated in xml 1.3
 */
hash parseXMLRPCCall(string xml, *string encoding) [flags=RET_VALUE_ONLY,DEPRECATED] {
   return parse_xmlrpc_call(xml, encoding, xsink);
}

//! This is a variant that is basically a noop, included for backwards-compatibility for functions that ignored type errors in the calling parameters
/**
 */
nothing parseXMLRPCCall() [flags=RUNTIME_NOOP,DEPRECATED] {
}

//! Deserializies an XML-RPC response string, returning a %Qore data structure representing the response information
/** @param xml the XML string in XML-RPC call format to deserialize
    @param encoding an optional string giving the string encoding of any strings output; if this parameter is missing, the any strings output in the output hash will have the default encoding

    @return a hash with one of the following keys:
    - \c fault: a hash describing a fault response
    - \c params: a hash describing a normal, non-fault response

    @throw PARSE-XMLRPC-RESPONSE-ERROR missing required element or other syntax error
    @throw PARSE-XMLRPC-ERROR syntax error parsing XML-RPC string

    @par Example:
    @code hash h = parse_xmlrpc_response(xml); @endcode

    @see @ref XMLRPC

    @since xml 1.3 as a replacement for deprecated camel-case parseXMLRPCResponse()
 */
hash parse_xmlrpc_response(string xml, *string encoding) [flags=RET_VALUE_ONLY] {
   const QoreEncoding* qe = encoding ? QEM.findCreate(encoding) : QCS_DEFAULT;
   return parse_xmlrpc_response(xsink, xml, qe);
}

//! Deserializies an XML-RPC response string, returning a %Qore data structure representing the response information
/** @param xml the XML string in XML-RPC call format to deserialize
    @param encoding an optional string giving the string encoding of any strings output; if this parameter is missing, the any strings output in the output hash will have the default encoding

    @return a hash with one of the following keys:
    - \c fault: a hash describing a fault response
    - \c params: a hash describing a normal, non-fault response

    @throw PARSE-XMLRPC-RESPONSE-ERROR missing required element or other syntax error
    @throw PARSE-XMLRPC-ERROR syntax error parsing XML-RPC string

    @see @ref XMLRPC

    @deprecated use parse_xmlrpc_response(); camel-case function names were deprecated in xml 1.3
 */
hash parseXMLRPCResponse(string xml, *string encoding) [flags=RET_VALUE_ONLY,DEPRECATED] {
   const QoreEncoding* qe = encoding ? QEM.findCreate(encoding) : QCS_DEFAULT;
   return parse_xmlrpc_response(xsink, xml, qe);
}

//! This is a variant that is basically a noop, included for backwards-compatibility for functions that ignored type errors in the calling parameters
/**
 */
nothing parseXMLRPCResponse() [flags=RUNTIME_NOOP,DEPRECATED] {
}

//! Helper function returning an XML value
/** This function returns the actual value of a complex data structure as returned by @ref parse_xml().
    When parsing XML attributes or comments (ex: @ref XPF_ADD_COMMENTS), then a hash is returned and the
    actual value of the XML appears under the \c "^value^" key.   This function makes it easier to handle
    this situation by returning the value given if the argument is not a hash or has no \c "^value^" key,
    otherwise, if so, it returns the value assigned to the \c "^value^" key.\n
    Note that only "^value^" is returned even when there are more values as result of @ref XPF_PRESERVE_ORDER flag.

    @param n a simple value or a complex hash as returned by @ref parse_xml(); if the value is a hash with a
    \c "^value^" key, then the value of this key is processed, otherwise the argument itself is processed.
    If the resulting value is a list or a hash, then @ref nothing is returned, otherwise the value is returned.

    @par Example:
    @code
    string xml = "
        <elem attr="a1">
          <!-- comment -->
          My value
          <!-- comment 2 -->
          is split
        </elem>
    ";
    hash h = parse_xml(xml);
    string val = get_xml_value(xml.elem);
    @endcode

    @since xml 1.4
 */
any get_xml_value(any n) [flags=CONSTANT] {
   if (n.isNothing()) {
      return QoreValue();
   }
   SimpleRefHolder<SimpleQoreNode> str;

   switch (n.getType()) {
      case NT_HASH: {
         const QoreHashNode* h = reinterpret_cast<const QoreHashNode*>(n.getInternalNode());
         const AbstractQoreNode* v = h->getKeyValue("^value^");
         if (is_nothing(v)) {
            return QoreValue();
         }
         switch (v->getType()) {
            case NT_HASH:
            case NT_LIST:
               return QoreValue();
            default:
               str = reinterpret_cast<SimpleQoreNode*>(v->refSelf());
         }
         break;
      }
      case NT_LIST:
         return QoreValue();
      default:
         // just return parameter as-is, we need inc reference
         str = reinterpret_cast<SimpleQoreNode*>(n.getInternalNode()->refSelf());
         break;
   }
   return str.release();
}

//@}
